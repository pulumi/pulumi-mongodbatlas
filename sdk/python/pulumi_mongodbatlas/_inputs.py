# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'AdvancedClusterAdvancedConfigurationArgs',
    'AdvancedClusterAdvancedConfigurationArgsDict',
    'AdvancedClusterBiConnectorConfigArgs',
    'AdvancedClusterBiConnectorConfigArgsDict',
    'AdvancedClusterConnectionStringArgs',
    'AdvancedClusterConnectionStringArgsDict',
    'AdvancedClusterConnectionStringPrivateEndpointArgs',
    'AdvancedClusterConnectionStringPrivateEndpointArgsDict',
    'AdvancedClusterConnectionStringPrivateEndpointEndpointArgs',
    'AdvancedClusterConnectionStringPrivateEndpointEndpointArgsDict',
    'AdvancedClusterLabelArgs',
    'AdvancedClusterLabelArgsDict',
    'AdvancedClusterReplicationSpecArgs',
    'AdvancedClusterReplicationSpecArgsDict',
    'AdvancedClusterReplicationSpecRegionConfigArgs',
    'AdvancedClusterReplicationSpecRegionConfigArgsDict',
    'AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScalingArgs',
    'AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScalingArgsDict',
    'AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsArgs',
    'AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsArgsDict',
    'AdvancedClusterReplicationSpecRegionConfigAutoScalingArgs',
    'AdvancedClusterReplicationSpecRegionConfigAutoScalingArgsDict',
    'AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs',
    'AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgsDict',
    'AdvancedClusterReplicationSpecRegionConfigReadOnlySpecsArgs',
    'AdvancedClusterReplicationSpecRegionConfigReadOnlySpecsArgsDict',
    'AdvancedClusterTagArgs',
    'AdvancedClusterTagArgsDict',
    'AlertConfigurationMatcherArgs',
    'AlertConfigurationMatcherArgsDict',
    'AlertConfigurationMetricThresholdConfigArgs',
    'AlertConfigurationMetricThresholdConfigArgsDict',
    'AlertConfigurationNotificationArgs',
    'AlertConfigurationNotificationArgsDict',
    'AlertConfigurationThresholdConfigArgs',
    'AlertConfigurationThresholdConfigArgsDict',
    'BackupCompliancePolicyOnDemandPolicyItemArgs',
    'BackupCompliancePolicyOnDemandPolicyItemArgsDict',
    'BackupCompliancePolicyPolicyItemDailyArgs',
    'BackupCompliancePolicyPolicyItemDailyArgsDict',
    'BackupCompliancePolicyPolicyItemHourlyArgs',
    'BackupCompliancePolicyPolicyItemHourlyArgsDict',
    'BackupCompliancePolicyPolicyItemMonthlyArgs',
    'BackupCompliancePolicyPolicyItemMonthlyArgsDict',
    'BackupCompliancePolicyPolicyItemWeeklyArgs',
    'BackupCompliancePolicyPolicyItemWeeklyArgsDict',
    'BackupCompliancePolicyPolicyItemYearlyArgs',
    'BackupCompliancePolicyPolicyItemYearlyArgsDict',
    'CloudBackupScheduleCopySettingArgs',
    'CloudBackupScheduleCopySettingArgsDict',
    'CloudBackupScheduleExportArgs',
    'CloudBackupScheduleExportArgsDict',
    'CloudBackupSchedulePolicyItemDailyArgs',
    'CloudBackupSchedulePolicyItemDailyArgsDict',
    'CloudBackupSchedulePolicyItemHourlyArgs',
    'CloudBackupSchedulePolicyItemHourlyArgsDict',
    'CloudBackupSchedulePolicyItemMonthlyArgs',
    'CloudBackupSchedulePolicyItemMonthlyArgsDict',
    'CloudBackupSchedulePolicyItemWeeklyArgs',
    'CloudBackupSchedulePolicyItemWeeklyArgsDict',
    'CloudBackupSchedulePolicyItemYearlyArgs',
    'CloudBackupSchedulePolicyItemYearlyArgsDict',
    'CloudBackupSnapshotExportJobComponentArgs',
    'CloudBackupSnapshotExportJobComponentArgsDict',
    'CloudBackupSnapshotExportJobCustomDataArgs',
    'CloudBackupSnapshotExportJobCustomDataArgsDict',
    'CloudBackupSnapshotMemberArgs',
    'CloudBackupSnapshotMemberArgsDict',
    'CloudBackupSnapshotRestoreJobDeliveryTypeConfigArgs',
    'CloudBackupSnapshotRestoreJobDeliveryTypeConfigArgsDict',
    'CloudProviderAccessAuthorizationAwsArgs',
    'CloudProviderAccessAuthorizationAwsArgsDict',
    'CloudProviderAccessAuthorizationAzureArgs',
    'CloudProviderAccessAuthorizationAzureArgsDict',
    'CloudProviderAccessAuthorizationFeatureUsageArgs',
    'CloudProviderAccessAuthorizationFeatureUsageArgsDict',
    'CloudProviderAccessSetupAwsConfigArgs',
    'CloudProviderAccessSetupAwsConfigArgsDict',
    'CloudProviderAccessSetupAzureConfigArgs',
    'CloudProviderAccessSetupAzureConfigArgsDict',
    'ClusterAdvancedConfigurationArgs',
    'ClusterAdvancedConfigurationArgsDict',
    'ClusterBiConnectorConfigArgs',
    'ClusterBiConnectorConfigArgsDict',
    'ClusterConnectionStringArgs',
    'ClusterConnectionStringArgsDict',
    'ClusterConnectionStringPrivateEndpointArgs',
    'ClusterConnectionStringPrivateEndpointArgsDict',
    'ClusterConnectionStringPrivateEndpointEndpointArgs',
    'ClusterConnectionStringPrivateEndpointEndpointArgsDict',
    'ClusterLabelArgs',
    'ClusterLabelArgsDict',
    'ClusterOutageSimulationOutageFilterArgs',
    'ClusterOutageSimulationOutageFilterArgsDict',
    'ClusterReplicationSpecArgs',
    'ClusterReplicationSpecArgsDict',
    'ClusterReplicationSpecRegionsConfigArgs',
    'ClusterReplicationSpecRegionsConfigArgsDict',
    'ClusterSnapshotBackupPolicyArgs',
    'ClusterSnapshotBackupPolicyArgsDict',
    'ClusterSnapshotBackupPolicyPolicyArgs',
    'ClusterSnapshotBackupPolicyPolicyArgsDict',
    'ClusterSnapshotBackupPolicyPolicyPolicyItemArgs',
    'ClusterSnapshotBackupPolicyPolicyPolicyItemArgsDict',
    'ClusterTagArgs',
    'ClusterTagArgsDict',
    'CustomDbRoleActionArgs',
    'CustomDbRoleActionArgsDict',
    'CustomDbRoleActionResourceArgs',
    'CustomDbRoleActionResourceArgsDict',
    'CustomDbRoleInheritedRoleArgs',
    'CustomDbRoleInheritedRoleArgsDict',
    'DataLakePipelineIngestionScheduleArgs',
    'DataLakePipelineIngestionScheduleArgsDict',
    'DataLakePipelineSinkArgs',
    'DataLakePipelineSinkArgsDict',
    'DataLakePipelineSinkPartitionFieldArgs',
    'DataLakePipelineSinkPartitionFieldArgsDict',
    'DataLakePipelineSnapshotArgs',
    'DataLakePipelineSnapshotArgsDict',
    'DataLakePipelineSourceArgs',
    'DataLakePipelineSourceArgsDict',
    'DataLakePipelineTransformationArgs',
    'DataLakePipelineTransformationArgsDict',
    'DatabaseUserLabelArgs',
    'DatabaseUserLabelArgsDict',
    'DatabaseUserRoleArgs',
    'DatabaseUserRoleArgsDict',
    'DatabaseUserScopeArgs',
    'DatabaseUserScopeArgsDict',
    'EncryptionAtRestAwsKmsConfigArgs',
    'EncryptionAtRestAwsKmsConfigArgsDict',
    'EncryptionAtRestAzureKeyVaultConfigArgs',
    'EncryptionAtRestAzureKeyVaultConfigArgsDict',
    'EncryptionAtRestGoogleCloudKmsConfigArgs',
    'EncryptionAtRestGoogleCloudKmsConfigArgsDict',
    'EventTriggerEventProcessorsArgs',
    'EventTriggerEventProcessorsArgsDict',
    'EventTriggerEventProcessorsAwsEventbridgeArgs',
    'EventTriggerEventProcessorsAwsEventbridgeArgsDict',
    'FederatedDatabaseInstanceCloudProviderConfigArgs',
    'FederatedDatabaseInstanceCloudProviderConfigArgsDict',
    'FederatedDatabaseInstanceCloudProviderConfigAwsArgs',
    'FederatedDatabaseInstanceCloudProviderConfigAwsArgsDict',
    'FederatedDatabaseInstanceDataProcessRegionArgs',
    'FederatedDatabaseInstanceDataProcessRegionArgsDict',
    'FederatedDatabaseInstanceStorageDatabaseArgs',
    'FederatedDatabaseInstanceStorageDatabaseArgsDict',
    'FederatedDatabaseInstanceStorageDatabaseCollectionArgs',
    'FederatedDatabaseInstanceStorageDatabaseCollectionArgsDict',
    'FederatedDatabaseInstanceStorageDatabaseCollectionDataSourceArgs',
    'FederatedDatabaseInstanceStorageDatabaseCollectionDataSourceArgsDict',
    'FederatedDatabaseInstanceStorageDatabaseViewArgs',
    'FederatedDatabaseInstanceStorageDatabaseViewArgsDict',
    'FederatedDatabaseInstanceStorageStoreArgs',
    'FederatedDatabaseInstanceStorageStoreArgsDict',
    'FederatedDatabaseInstanceStorageStoreReadPreferenceArgs',
    'FederatedDatabaseInstanceStorageStoreReadPreferenceArgsDict',
    'FederatedDatabaseInstanceStorageStoreReadPreferenceTagSetArgs',
    'FederatedDatabaseInstanceStorageStoreReadPreferenceTagSetArgsDict',
    'FederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTagArgs',
    'FederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTagArgsDict',
    'FederatedSettingsOrgConfigUserConflictArgs',
    'FederatedSettingsOrgConfigUserConflictArgsDict',
    'FederatedSettingsOrgRoleMappingRoleAssignmentArgs',
    'FederatedSettingsOrgRoleMappingRoleAssignmentArgsDict',
    'GlobalClusterConfigCustomZoneMappingArgs',
    'GlobalClusterConfigCustomZoneMappingArgsDict',
    'GlobalClusterConfigManagedNamespaceArgs',
    'GlobalClusterConfigManagedNamespaceArgsDict',
    'LdapConfigurationUserToDnMappingArgs',
    'LdapConfigurationUserToDnMappingArgsDict',
    'LdapVerifyLinkArgs',
    'LdapVerifyLinkArgsDict',
    'LdapVerifyValidationArgs',
    'LdapVerifyValidationArgsDict',
    'OnlineArchiveCriteriaArgs',
    'OnlineArchiveCriteriaArgsDict',
    'OnlineArchiveDataExpirationRuleArgs',
    'OnlineArchiveDataExpirationRuleArgsDict',
    'OnlineArchiveDataProcessRegionArgs',
    'OnlineArchiveDataProcessRegionArgsDict',
    'OnlineArchivePartitionFieldArgs',
    'OnlineArchivePartitionFieldArgsDict',
    'OnlineArchiveScheduleArgs',
    'OnlineArchiveScheduleArgsDict',
    'PrivateLinkEndpointServiceEndpointArgs',
    'PrivateLinkEndpointServiceEndpointArgsDict',
    'ProjectApiKeyProjectAssignmentArgs',
    'ProjectApiKeyProjectAssignmentArgsDict',
    'ProjectIpAccessListTimeoutsArgs',
    'ProjectIpAccessListTimeoutsArgsDict',
    'ProjectIpAddressesArgs',
    'ProjectIpAddressesArgsDict',
    'ProjectIpAddressesServicesArgs',
    'ProjectIpAddressesServicesArgsDict',
    'ProjectIpAddressesServicesClusterArgs',
    'ProjectIpAddressesServicesClusterArgsDict',
    'ProjectLimitArgs',
    'ProjectLimitArgsDict',
    'ProjectTeamArgs',
    'ProjectTeamArgsDict',
    'ProviderAssumeRoleArgs',
    'ProviderAssumeRoleArgsDict',
    'PushBasedLogExportTimeoutsArgs',
    'PushBasedLogExportTimeoutsArgsDict',
    'SearchDeploymentSpecArgs',
    'SearchDeploymentSpecArgsDict',
    'SearchDeploymentTimeoutsArgs',
    'SearchDeploymentTimeoutsArgsDict',
    'SearchIndexSynonymArgs',
    'SearchIndexSynonymArgsDict',
    'ServerlessInstanceLinkArgs',
    'ServerlessInstanceLinkArgsDict',
    'ServerlessInstanceTagArgs',
    'ServerlessInstanceTagArgsDict',
    'StreamConnectionAuthenticationArgs',
    'StreamConnectionAuthenticationArgsDict',
    'StreamConnectionDbRoleToExecuteArgs',
    'StreamConnectionDbRoleToExecuteArgsDict',
    'StreamConnectionSecurityArgs',
    'StreamConnectionSecurityArgsDict',
    'StreamInstanceDataProcessRegionArgs',
    'StreamInstanceDataProcessRegionArgsDict',
    'StreamInstanceStreamConfigArgs',
    'StreamInstanceStreamConfigArgsDict',
    'StreamProcessorOptionsArgs',
    'StreamProcessorOptionsArgsDict',
    'StreamProcessorOptionsDlqArgs',
    'StreamProcessorOptionsDlqArgsDict',
    'X509AuthenticationDatabaseUserCertificateArgs',
    'X509AuthenticationDatabaseUserCertificateArgsDict',
    'GetAlertConfigurationOutputArgs',
    'GetAlertConfigurationOutputArgsDict',
    'GetAlertConfigurationsListOptionArgs',
    'GetAlertConfigurationsListOptionArgsDict',
    'GetCloudProviderAccessSetupAzureConfigArgs',
    'GetCloudProviderAccessSetupAzureConfigArgsDict',
    'GetCustomDbRoleInheritedRoleArgs',
    'GetCustomDbRoleInheritedRoleArgsDict',
    'GetFederatedDatabaseInstanceCloudProviderConfigArgs',
    'GetFederatedDatabaseInstanceCloudProviderConfigArgsDict',
    'GetFederatedDatabaseInstanceCloudProviderConfigAwsArgs',
    'GetFederatedDatabaseInstanceCloudProviderConfigAwsArgsDict',
    'GetGlobalClusterConfigManagedNamespaceArgs',
    'GetGlobalClusterConfigManagedNamespaceArgsDict',
    'GetServerlessInstanceLinkArgs',
    'GetServerlessInstanceLinkArgsDict',
]

MYPY = False

if not MYPY:
    class AdvancedClusterAdvancedConfigurationArgsDict(TypedDict):
        change_stream_options_pre_and_post_images_expire_after_seconds: NotRequired[pulumi.Input[int]]
        """
        The minimum pre- and post-image retention time in seconds. This option corresponds to the `changeStreamOptions.preAndPostImages.expireAfterSeconds` cluster parameter. Defaults to `-1`(off). This setting controls the retention policy of change stream pre- and post-images. Pre- and post-images are the versions of a document before and after document modification, respectively. `expireAfterSeconds` controls how long MongoDB retains pre- and post-images. When set to -1 (off), MongoDB uses the default retention policy: pre- and post-images are retained until the corresponding change stream events are removed from the oplog. To set the minimum pre- and post-image retention time, specify an integer value greater than zero. Setting this too low could increase the risk of interrupting Realm sync or triggers processing. This parameter is only supported for MongoDB version 6.0 and above.
        """
        default_read_concern: NotRequired[pulumi.Input[str]]
        """
        [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/). **(DEPRECATED)** MongoDB 5.0 and later clusters default to `local`. To use a custom read concern level, please refer to your driver documentation.
        """
        default_write_concern: NotRequired[pulumi.Input[str]]
        """
        [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        """
        fail_index_key_too_long: NotRequired[pulumi.Input[bool]]
        """
        When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them. **(DEPRECATED)** This parameter has been removed as of [MongoDB 4.4](https://www.mongodb.com/docs/manual/reference/parameters/#mongodb-parameter-param.failIndexKeyTooLong).
        """
        javascript_enabled: NotRequired[pulumi.Input[bool]]
        """
        When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        """
        minimum_enabled_tls_protocol: NotRequired[pulumi.Input[str]]
        """
        Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:

        - TLS1_0
        - TLS1_1
        - TLS1_2
        """
        no_table_scan: NotRequired[pulumi.Input[bool]]
        """
        When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        """
        oplog_min_retention_hours: NotRequired[pulumi.Input[float]]
        """
        Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.
        * **Note**  A minimum oplog retention is required when seeking to change a cluster's class to Local NVMe SSD. To learn more and for latest guidance see [`oplogMinRetentionHours`](https://www.mongodb.com/docs/manual/core/replica-set-oplog/#std-label-replica-set-minimum-oplog-size)
        """
        oplog_size_mb: NotRequired[pulumi.Input[int]]
        """
        The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        """
        sample_refresh_interval_bi_connector: NotRequired[pulumi.Input[int]]
        """
        Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        sample_size_bi_connector: NotRequired[pulumi.Input[int]]
        """
        Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        transaction_lifetime_limit_seconds: NotRequired[pulumi.Input[int]]
        """
        Lifetime, in seconds, of multi-document transactions. Defaults to 60 seconds.
        """
elif False:
    AdvancedClusterAdvancedConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AdvancedClusterAdvancedConfigurationArgs:
    def __init__(__self__, *,
                 change_stream_options_pre_and_post_images_expire_after_seconds: Optional[pulumi.Input[int]] = None,
                 default_read_concern: Optional[pulumi.Input[str]] = None,
                 default_write_concern: Optional[pulumi.Input[str]] = None,
                 fail_index_key_too_long: Optional[pulumi.Input[bool]] = None,
                 javascript_enabled: Optional[pulumi.Input[bool]] = None,
                 minimum_enabled_tls_protocol: Optional[pulumi.Input[str]] = None,
                 no_table_scan: Optional[pulumi.Input[bool]] = None,
                 oplog_min_retention_hours: Optional[pulumi.Input[float]] = None,
                 oplog_size_mb: Optional[pulumi.Input[int]] = None,
                 sample_refresh_interval_bi_connector: Optional[pulumi.Input[int]] = None,
                 sample_size_bi_connector: Optional[pulumi.Input[int]] = None,
                 transaction_lifetime_limit_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] change_stream_options_pre_and_post_images_expire_after_seconds: The minimum pre- and post-image retention time in seconds. This option corresponds to the `changeStreamOptions.preAndPostImages.expireAfterSeconds` cluster parameter. Defaults to `-1`(off). This setting controls the retention policy of change stream pre- and post-images. Pre- and post-images are the versions of a document before and after document modification, respectively. `expireAfterSeconds` controls how long MongoDB retains pre- and post-images. When set to -1 (off), MongoDB uses the default retention policy: pre- and post-images are retained until the corresponding change stream events are removed from the oplog. To set the minimum pre- and post-image retention time, specify an integer value greater than zero. Setting this too low could increase the risk of interrupting Realm sync or triggers processing. This parameter is only supported for MongoDB version 6.0 and above.
        :param pulumi.Input[str] default_read_concern: [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/). **(DEPRECATED)** MongoDB 5.0 and later clusters default to `local`. To use a custom read concern level, please refer to your driver documentation.
        :param pulumi.Input[str] default_write_concern: [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        :param pulumi.Input[bool] fail_index_key_too_long: When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them. **(DEPRECATED)** This parameter has been removed as of [MongoDB 4.4](https://www.mongodb.com/docs/manual/reference/parameters/#mongodb-parameter-param.failIndexKeyTooLong).
        :param pulumi.Input[bool] javascript_enabled: When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        :param pulumi.Input[str] minimum_enabled_tls_protocol: Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:
               
               - TLS1_0
               - TLS1_1
               - TLS1_2
        :param pulumi.Input[bool] no_table_scan: When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        :param pulumi.Input[float] oplog_min_retention_hours: Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.
               * **Note**  A minimum oplog retention is required when seeking to change a cluster's class to Local NVMe SSD. To learn more and for latest guidance see [`oplogMinRetentionHours`](https://www.mongodb.com/docs/manual/core/replica-set-oplog/#std-label-replica-set-minimum-oplog-size)
        :param pulumi.Input[int] oplog_size_mb: The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        :param pulumi.Input[int] sample_refresh_interval_bi_connector: Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        :param pulumi.Input[int] sample_size_bi_connector: Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        :param pulumi.Input[int] transaction_lifetime_limit_seconds: Lifetime, in seconds, of multi-document transactions. Defaults to 60 seconds.
        """
        if change_stream_options_pre_and_post_images_expire_after_seconds is not None:
            pulumi.set(__self__, "change_stream_options_pre_and_post_images_expire_after_seconds", change_stream_options_pre_and_post_images_expire_after_seconds)
        if default_read_concern is not None:
            warnings.warn("""This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown""", DeprecationWarning)
            pulumi.log.warn("""default_read_concern is deprecated: This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown""")
        if default_read_concern is not None:
            pulumi.set(__self__, "default_read_concern", default_read_concern)
        if default_write_concern is not None:
            pulumi.set(__self__, "default_write_concern", default_write_concern)
        if fail_index_key_too_long is not None:
            warnings.warn("""This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown""", DeprecationWarning)
            pulumi.log.warn("""fail_index_key_too_long is deprecated: This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown""")
        if fail_index_key_too_long is not None:
            pulumi.set(__self__, "fail_index_key_too_long", fail_index_key_too_long)
        if javascript_enabled is not None:
            pulumi.set(__self__, "javascript_enabled", javascript_enabled)
        if minimum_enabled_tls_protocol is not None:
            pulumi.set(__self__, "minimum_enabled_tls_protocol", minimum_enabled_tls_protocol)
        if no_table_scan is not None:
            pulumi.set(__self__, "no_table_scan", no_table_scan)
        if oplog_min_retention_hours is not None:
            pulumi.set(__self__, "oplog_min_retention_hours", oplog_min_retention_hours)
        if oplog_size_mb is not None:
            pulumi.set(__self__, "oplog_size_mb", oplog_size_mb)
        if sample_refresh_interval_bi_connector is not None:
            pulumi.set(__self__, "sample_refresh_interval_bi_connector", sample_refresh_interval_bi_connector)
        if sample_size_bi_connector is not None:
            pulumi.set(__self__, "sample_size_bi_connector", sample_size_bi_connector)
        if transaction_lifetime_limit_seconds is not None:
            pulumi.set(__self__, "transaction_lifetime_limit_seconds", transaction_lifetime_limit_seconds)

    @property
    @pulumi.getter(name="changeStreamOptionsPreAndPostImagesExpireAfterSeconds")
    def change_stream_options_pre_and_post_images_expire_after_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The minimum pre- and post-image retention time in seconds. This option corresponds to the `changeStreamOptions.preAndPostImages.expireAfterSeconds` cluster parameter. Defaults to `-1`(off). This setting controls the retention policy of change stream pre- and post-images. Pre- and post-images are the versions of a document before and after document modification, respectively. `expireAfterSeconds` controls how long MongoDB retains pre- and post-images. When set to -1 (off), MongoDB uses the default retention policy: pre- and post-images are retained until the corresponding change stream events are removed from the oplog. To set the minimum pre- and post-image retention time, specify an integer value greater than zero. Setting this too low could increase the risk of interrupting Realm sync or triggers processing. This parameter is only supported for MongoDB version 6.0 and above.
        """
        return pulumi.get(self, "change_stream_options_pre_and_post_images_expire_after_seconds")

    @change_stream_options_pre_and_post_images_expire_after_seconds.setter
    def change_stream_options_pre_and_post_images_expire_after_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "change_stream_options_pre_and_post_images_expire_after_seconds", value)

    @property
    @pulumi.getter(name="defaultReadConcern")
    @_utilities.deprecated("""This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown""")
    def default_read_concern(self) -> Optional[pulumi.Input[str]]:
        """
        [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/). **(DEPRECATED)** MongoDB 5.0 and later clusters default to `local`. To use a custom read concern level, please refer to your driver documentation.
        """
        return pulumi.get(self, "default_read_concern")

    @default_read_concern.setter
    def default_read_concern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_read_concern", value)

    @property
    @pulumi.getter(name="defaultWriteConcern")
    def default_write_concern(self) -> Optional[pulumi.Input[str]]:
        """
        [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        """
        return pulumi.get(self, "default_write_concern")

    @default_write_concern.setter
    def default_write_concern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_write_concern", value)

    @property
    @pulumi.getter(name="failIndexKeyTooLong")
    @_utilities.deprecated("""This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown""")
    def fail_index_key_too_long(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them. **(DEPRECATED)** This parameter has been removed as of [MongoDB 4.4](https://www.mongodb.com/docs/manual/reference/parameters/#mongodb-parameter-param.failIndexKeyTooLong).
        """
        return pulumi.get(self, "fail_index_key_too_long")

    @fail_index_key_too_long.setter
    def fail_index_key_too_long(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fail_index_key_too_long", value)

    @property
    @pulumi.getter(name="javascriptEnabled")
    def javascript_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        """
        return pulumi.get(self, "javascript_enabled")

    @javascript_enabled.setter
    def javascript_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "javascript_enabled", value)

    @property
    @pulumi.getter(name="minimumEnabledTlsProtocol")
    def minimum_enabled_tls_protocol(self) -> Optional[pulumi.Input[str]]:
        """
        Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:

        - TLS1_0
        - TLS1_1
        - TLS1_2
        """
        return pulumi.get(self, "minimum_enabled_tls_protocol")

    @minimum_enabled_tls_protocol.setter
    def minimum_enabled_tls_protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "minimum_enabled_tls_protocol", value)

    @property
    @pulumi.getter(name="noTableScan")
    def no_table_scan(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        """
        return pulumi.get(self, "no_table_scan")

    @no_table_scan.setter
    def no_table_scan(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_table_scan", value)

    @property
    @pulumi.getter(name="oplogMinRetentionHours")
    def oplog_min_retention_hours(self) -> Optional[pulumi.Input[float]]:
        """
        Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.
        * **Note**  A minimum oplog retention is required when seeking to change a cluster's class to Local NVMe SSD. To learn more and for latest guidance see [`oplogMinRetentionHours`](https://www.mongodb.com/docs/manual/core/replica-set-oplog/#std-label-replica-set-minimum-oplog-size)
        """
        return pulumi.get(self, "oplog_min_retention_hours")

    @oplog_min_retention_hours.setter
    def oplog_min_retention_hours(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "oplog_min_retention_hours", value)

    @property
    @pulumi.getter(name="oplogSizeMb")
    def oplog_size_mb(self) -> Optional[pulumi.Input[int]]:
        """
        The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        """
        return pulumi.get(self, "oplog_size_mb")

    @oplog_size_mb.setter
    def oplog_size_mb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "oplog_size_mb", value)

    @property
    @pulumi.getter(name="sampleRefreshIntervalBiConnector")
    def sample_refresh_interval_bi_connector(self) -> Optional[pulumi.Input[int]]:
        """
        Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_refresh_interval_bi_connector")

    @sample_refresh_interval_bi_connector.setter
    def sample_refresh_interval_bi_connector(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "sample_refresh_interval_bi_connector", value)

    @property
    @pulumi.getter(name="sampleSizeBiConnector")
    def sample_size_bi_connector(self) -> Optional[pulumi.Input[int]]:
        """
        Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_size_bi_connector")

    @sample_size_bi_connector.setter
    def sample_size_bi_connector(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "sample_size_bi_connector", value)

    @property
    @pulumi.getter(name="transactionLifetimeLimitSeconds")
    def transaction_lifetime_limit_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Lifetime, in seconds, of multi-document transactions. Defaults to 60 seconds.
        """
        return pulumi.get(self, "transaction_lifetime_limit_seconds")

    @transaction_lifetime_limit_seconds.setter
    def transaction_lifetime_limit_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "transaction_lifetime_limit_seconds", value)


if not MYPY:
    class AdvancedClusterBiConnectorConfigArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Specifies whether or not BI Connector for Atlas is enabled on the cluster.l
        *
        - Set to `true` to enable BI Connector for Atlas.
        - Set to `false` to disable BI Connector for Atlas.
        """
        read_preference: NotRequired[pulumi.Input[str]]
        """
        Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).

        - Set to "primary" to have BI Connector for Atlas read from the primary.

        - Set to "secondary" to have BI Connector for Atlas read from a secondary member. Default if there are no analytics nodes in the cluster.

        - Set to "analytics" to have BI Connector for Atlas read from an analytics node. Default if the cluster contains analytics nodes.
        """
elif False:
    AdvancedClusterBiConnectorConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AdvancedClusterBiConnectorConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 read_preference: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Specifies whether or not BI Connector for Atlas is enabled on the cluster.l
               *
               - Set to `true` to enable BI Connector for Atlas.
               - Set to `false` to disable BI Connector for Atlas.
        :param pulumi.Input[str] read_preference: Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
               
               - Set to "primary" to have BI Connector for Atlas read from the primary.
               
               - Set to "secondary" to have BI Connector for Atlas read from a secondary member. Default if there are no analytics nodes in the cluster.
               
               - Set to "analytics" to have BI Connector for Atlas read from an analytics node. Default if the cluster contains analytics nodes.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if read_preference is not None:
            pulumi.set(__self__, "read_preference", read_preference)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether or not BI Connector for Atlas is enabled on the cluster.l
        *
        - Set to `true` to enable BI Connector for Atlas.
        - Set to `false` to disable BI Connector for Atlas.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="readPreference")
    def read_preference(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).

        - Set to "primary" to have BI Connector for Atlas read from the primary.

        - Set to "secondary" to have BI Connector for Atlas read from a secondary member. Default if there are no analytics nodes in the cluster.

        - Set to "analytics" to have BI Connector for Atlas read from an analytics node. Default if the cluster contains analytics nodes.
        """
        return pulumi.get(self, "read_preference")

    @read_preference.setter
    def read_preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "read_preference", value)


if not MYPY:
    class AdvancedClusterConnectionStringArgsDict(TypedDict):
        private: NotRequired[pulumi.Input[str]]
        """
        [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        """
        private_endpoints: NotRequired[pulumi.Input[Sequence[pulumi.Input['AdvancedClusterConnectionStringPrivateEndpointArgsDict']]]]
        """
        Private endpoint connection strings. Each object describes the connection strings you can use to connect to this cluster through a private endpoint. Atlas returns this parameter only if you deployed a private endpoint to all regions to which you deployed this cluster's nodes.
        - `connection_strings.private_endpoint.#.connection_string` - Private-endpoint-aware `mongodb://`connection string for this private endpoint.
        - `connection_strings.private_endpoint.#.srv_connection_string` - Private-endpoint-aware `mongodb+srv://` connection string for this private endpoint. The `mongodb+srv` protocol tells the driver to look up the seed list of hosts in DNS . Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don't need to: Append the seed list or Change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn't, use `connection_strings.private_endpoint[n].connection_string`
        - `connection_strings.private_endpoint.#.srv_shard_optimized_connection_string` - Private endpoint-aware connection string optimized for sharded clusters that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint. If the connection string uses this Uniform Resource Identifier (URI) format, you don't need to change the Uniform Resource Identifier (URI) if the nodes change. Use this Uniform Resource Identifier (URI) format if your application and Atlas cluster supports it. If it doesn't, use and consult the documentation for connectionStrings.privateEndpoint[n].srvConnectionString.
        - `connection_strings.private_endpoint.#.type` - Type of MongoDB process that you connect to with the connection strings. Atlas returns `MONGOD` for replica sets, or `MONGOS` for sharded clusters.
        - `connection_strings.private_endpoint.#.endpoints` - Private endpoint through which you connect to Atlas when you use `connection_strings.private_endpoint[n].connection_string` or `connection_strings.private_endpoint[n].srv_connection_string`
        - `connection_strings.private_endpoint.#.endpoints.#.endpoint_id` - Unique identifier of the private endpoint.
        - `connection_strings.private_endpoint.#.endpoints.#.provider_name` - Cloud provider to which you deployed the private endpoint. Atlas returns `AWS` or `AZURE`.
        - `connection_strings.private_endpoint.#.endpoints.#.region` - Region to which you deployed the private endpoint.
        """
        private_srv: NotRequired[pulumi.Input[str]]
        """
        [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        """
        standard: NotRequired[pulumi.Input[str]]
        """
        Public mongodb:// connection string for this cluster.
        """
        standard_srv: NotRequired[pulumi.Input[str]]
        """
        Public mongodb+srv:// connection string for this cluster. The mongodb+srv protocol tells the driver to look up the seed list of hosts in DNS. Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don’t need to append the seed list or change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn’t  , use connectionStrings.standard.
        """
elif False:
    AdvancedClusterConnectionStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AdvancedClusterConnectionStringArgs:
    def __init__(__self__, *,
                 private: Optional[pulumi.Input[str]] = None,
                 private_endpoints: Optional[pulumi.Input[Sequence[pulumi.Input['AdvancedClusterConnectionStringPrivateEndpointArgs']]]] = None,
                 private_srv: Optional[pulumi.Input[str]] = None,
                 standard: Optional[pulumi.Input[str]] = None,
                 standard_srv: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] private: [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        :param pulumi.Input[Sequence[pulumi.Input['AdvancedClusterConnectionStringPrivateEndpointArgs']]] private_endpoints: Private endpoint connection strings. Each object describes the connection strings you can use to connect to this cluster through a private endpoint. Atlas returns this parameter only if you deployed a private endpoint to all regions to which you deployed this cluster's nodes.
               - `connection_strings.private_endpoint.#.connection_string` - Private-endpoint-aware `mongodb://`connection string for this private endpoint.
               - `connection_strings.private_endpoint.#.srv_connection_string` - Private-endpoint-aware `mongodb+srv://` connection string for this private endpoint. The `mongodb+srv` protocol tells the driver to look up the seed list of hosts in DNS . Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don't need to: Append the seed list or Change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn't, use `connection_strings.private_endpoint[n].connection_string`
               - `connection_strings.private_endpoint.#.srv_shard_optimized_connection_string` - Private endpoint-aware connection string optimized for sharded clusters that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint. If the connection string uses this Uniform Resource Identifier (URI) format, you don't need to change the Uniform Resource Identifier (URI) if the nodes change. Use this Uniform Resource Identifier (URI) format if your application and Atlas cluster supports it. If it doesn't, use and consult the documentation for connectionStrings.privateEndpoint[n].srvConnectionString.
               - `connection_strings.private_endpoint.#.type` - Type of MongoDB process that you connect to with the connection strings. Atlas returns `MONGOD` for replica sets, or `MONGOS` for sharded clusters.
               - `connection_strings.private_endpoint.#.endpoints` - Private endpoint through which you connect to Atlas when you use `connection_strings.private_endpoint[n].connection_string` or `connection_strings.private_endpoint[n].srv_connection_string`
               - `connection_strings.private_endpoint.#.endpoints.#.endpoint_id` - Unique identifier of the private endpoint.
               - `connection_strings.private_endpoint.#.endpoints.#.provider_name` - Cloud provider to which you deployed the private endpoint. Atlas returns `AWS` or `AZURE`.
               - `connection_strings.private_endpoint.#.endpoints.#.region` - Region to which you deployed the private endpoint.
        :param pulumi.Input[str] private_srv: [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        :param pulumi.Input[str] standard: Public mongodb:// connection string for this cluster.
        :param pulumi.Input[str] standard_srv: Public mongodb+srv:// connection string for this cluster. The mongodb+srv protocol tells the driver to look up the seed list of hosts in DNS. Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don’t need to append the seed list or change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn’t  , use connectionStrings.standard.
        """
        if private is not None:
            pulumi.set(__self__, "private", private)
        if private_endpoints is not None:
            pulumi.set(__self__, "private_endpoints", private_endpoints)
        if private_srv is not None:
            pulumi.set(__self__, "private_srv", private_srv)
        if standard is not None:
            pulumi.set(__self__, "standard", standard)
        if standard_srv is not None:
            pulumi.set(__self__, "standard_srv", standard_srv)

    @property
    @pulumi.getter
    def private(self) -> Optional[pulumi.Input[str]]:
        """
        [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        """
        return pulumi.get(self, "private")

    @private.setter
    def private(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private", value)

    @property
    @pulumi.getter(name="privateEndpoints")
    def private_endpoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AdvancedClusterConnectionStringPrivateEndpointArgs']]]]:
        """
        Private endpoint connection strings. Each object describes the connection strings you can use to connect to this cluster through a private endpoint. Atlas returns this parameter only if you deployed a private endpoint to all regions to which you deployed this cluster's nodes.
        - `connection_strings.private_endpoint.#.connection_string` - Private-endpoint-aware `mongodb://`connection string for this private endpoint.
        - `connection_strings.private_endpoint.#.srv_connection_string` - Private-endpoint-aware `mongodb+srv://` connection string for this private endpoint. The `mongodb+srv` protocol tells the driver to look up the seed list of hosts in DNS . Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don't need to: Append the seed list or Change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn't, use `connection_strings.private_endpoint[n].connection_string`
        - `connection_strings.private_endpoint.#.srv_shard_optimized_connection_string` - Private endpoint-aware connection string optimized for sharded clusters that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint. If the connection string uses this Uniform Resource Identifier (URI) format, you don't need to change the Uniform Resource Identifier (URI) if the nodes change. Use this Uniform Resource Identifier (URI) format if your application and Atlas cluster supports it. If it doesn't, use and consult the documentation for connectionStrings.privateEndpoint[n].srvConnectionString.
        - `connection_strings.private_endpoint.#.type` - Type of MongoDB process that you connect to with the connection strings. Atlas returns `MONGOD` for replica sets, or `MONGOS` for sharded clusters.
        - `connection_strings.private_endpoint.#.endpoints` - Private endpoint through which you connect to Atlas when you use `connection_strings.private_endpoint[n].connection_string` or `connection_strings.private_endpoint[n].srv_connection_string`
        - `connection_strings.private_endpoint.#.endpoints.#.endpoint_id` - Unique identifier of the private endpoint.
        - `connection_strings.private_endpoint.#.endpoints.#.provider_name` - Cloud provider to which you deployed the private endpoint. Atlas returns `AWS` or `AZURE`.
        - `connection_strings.private_endpoint.#.endpoints.#.region` - Region to which you deployed the private endpoint.
        """
        return pulumi.get(self, "private_endpoints")

    @private_endpoints.setter
    def private_endpoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AdvancedClusterConnectionStringPrivateEndpointArgs']]]]):
        pulumi.set(self, "private_endpoints", value)

    @property
    @pulumi.getter(name="privateSrv")
    def private_srv(self) -> Optional[pulumi.Input[str]]:
        """
        [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        """
        return pulumi.get(self, "private_srv")

    @private_srv.setter
    def private_srv(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_srv", value)

    @property
    @pulumi.getter
    def standard(self) -> Optional[pulumi.Input[str]]:
        """
        Public mongodb:// connection string for this cluster.
        """
        return pulumi.get(self, "standard")

    @standard.setter
    def standard(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "standard", value)

    @property
    @pulumi.getter(name="standardSrv")
    def standard_srv(self) -> Optional[pulumi.Input[str]]:
        """
        Public mongodb+srv:// connection string for this cluster. The mongodb+srv protocol tells the driver to look up the seed list of hosts in DNS. Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don’t need to append the seed list or change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn’t  , use connectionStrings.standard.
        """
        return pulumi.get(self, "standard_srv")

    @standard_srv.setter
    def standard_srv(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "standard_srv", value)


if not MYPY:
    class AdvancedClusterConnectionStringPrivateEndpointArgsDict(TypedDict):
        connection_string: NotRequired[pulumi.Input[str]]
        endpoints: NotRequired[pulumi.Input[Sequence[pulumi.Input['AdvancedClusterConnectionStringPrivateEndpointEndpointArgsDict']]]]
        srv_connection_string: NotRequired[pulumi.Input[str]]
        srv_shard_optimized_connection_string: NotRequired[pulumi.Input[str]]
        type: NotRequired[pulumi.Input[str]]
elif False:
    AdvancedClusterConnectionStringPrivateEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AdvancedClusterConnectionStringPrivateEndpointArgs:
    def __init__(__self__, *,
                 connection_string: Optional[pulumi.Input[str]] = None,
                 endpoints: Optional[pulumi.Input[Sequence[pulumi.Input['AdvancedClusterConnectionStringPrivateEndpointEndpointArgs']]]] = None,
                 srv_connection_string: Optional[pulumi.Input[str]] = None,
                 srv_shard_optimized_connection_string: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if srv_connection_string is not None:
            pulumi.set(__self__, "srv_connection_string", srv_connection_string)
        if srv_shard_optimized_connection_string is not None:
            pulumi.set(__self__, "srv_shard_optimized_connection_string", srv_shard_optimized_connection_string)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AdvancedClusterConnectionStringPrivateEndpointEndpointArgs']]]]:
        return pulumi.get(self, "endpoints")

    @endpoints.setter
    def endpoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AdvancedClusterConnectionStringPrivateEndpointEndpointArgs']]]]):
        pulumi.set(self, "endpoints", value)

    @property
    @pulumi.getter(name="srvConnectionString")
    def srv_connection_string(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "srv_connection_string")

    @srv_connection_string.setter
    def srv_connection_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "srv_connection_string", value)

    @property
    @pulumi.getter(name="srvShardOptimizedConnectionString")
    def srv_shard_optimized_connection_string(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "srv_shard_optimized_connection_string")

    @srv_shard_optimized_connection_string.setter
    def srv_shard_optimized_connection_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "srv_shard_optimized_connection_string", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AdvancedClusterConnectionStringPrivateEndpointEndpointArgsDict(TypedDict):
        endpoint_id: NotRequired[pulumi.Input[str]]
        provider_name: NotRequired[pulumi.Input[str]]
        """
        Cloud service provider on which the servers are provisioned.
        The possible values are:

        - `AWS` - Amazon AWS
        - `GCP` - Google Cloud Platform
        - `AZURE` - Microsoft Azure
        - `TENANT` - M0, M2 or M5 multi-tenant cluster. Use `replication_specs.#.region_configs.#.backing_provider_name` to set the cloud service provider.
        """
        region: NotRequired[pulumi.Input[str]]
elif False:
    AdvancedClusterConnectionStringPrivateEndpointEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AdvancedClusterConnectionStringPrivateEndpointEndpointArgs:
    def __init__(__self__, *,
                 endpoint_id: Optional[pulumi.Input[str]] = None,
                 provider_name: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] provider_name: Cloud service provider on which the servers are provisioned.
               The possible values are:
               
               - `AWS` - Amazon AWS
               - `GCP` - Google Cloud Platform
               - `AZURE` - Microsoft Azure
               - `TENANT` - M0, M2 or M5 multi-tenant cluster. Use `replication_specs.#.region_configs.#.backing_provider_name` to set the cloud service provider.
        """
        if endpoint_id is not None:
            pulumi.set(__self__, "endpoint_id", endpoint_id)
        if provider_name is not None:
            pulumi.set(__self__, "provider_name", provider_name)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "endpoint_id")

    @endpoint_id.setter
    def endpoint_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint_id", value)

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> Optional[pulumi.Input[str]]:
        """
        Cloud service provider on which the servers are provisioned.
        The possible values are:

        - `AWS` - Amazon AWS
        - `GCP` - Google Cloud Platform
        - `AZURE` - Microsoft Azure
        - `TENANT` - M0, M2 or M5 multi-tenant cluster. Use `replication_specs.#.region_configs.#.backing_provider_name` to set the cloud service provider.
        """
        return pulumi.get(self, "provider_name")

    @provider_name.setter
    def provider_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "provider_name", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class AdvancedClusterLabelArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        The key that you want to write.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        The value that you want to write.

        > **NOTE:** MongoDB Atlas doesn't display your labels.
        """
elif False:
    AdvancedClusterLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AdvancedClusterLabelArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: The key that you want to write.
        :param pulumi.Input[str] value: The value that you want to write.
               
               > **NOTE:** MongoDB Atlas doesn't display your labels.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value that you want to write.

        > **NOTE:** MongoDB Atlas doesn't display your labels.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AdvancedClusterReplicationSpecArgsDict(TypedDict):
        region_configs: pulumi.Input[Sequence[pulumi.Input['AdvancedClusterReplicationSpecRegionConfigArgsDict']]]
        """
        Configuration for the hardware specifications for nodes set for a given regionEach `region_configs` object describes the region's priority in elections and the number and type of MongoDB nodes that Atlas deploys to the region. Each `region_configs` object must have either an `analytics_specs` object, `electable_specs` object, or `read_only_specs` object. See below
        """
        container_id: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        external_id: NotRequired[pulumi.Input[str]]
        """
        Unique 24-hexadecimal digit string that identifies the replication object for a shard in a Cluster. This value corresponds to Shard ID displayed in the UI. When using old sharding configuration (replication spec with `num_shards` greater than 1) this value is not populated.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        **(DEPRECATED)** Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        """
        num_shards: NotRequired[pulumi.Input[int]]
        """
        Provide this value if you set a `cluster_type` of SHARDED or GEOSHARDED. Omit this value if you selected a `cluster_type` of REPLICASET. This API resource accepts 1 through 50, inclusive. This parameter defaults to 1. If you specify a `num_shards` value of 1 and a `cluster_type` of SHARDED, Atlas deploys a single-shard [sharded cluster](https://docs.atlas.mongodb.com/reference/glossary/#std-term-sharded-cluster). Don't create a sharded cluster with a single shard for production environments. Single-shard sharded clusters don't provide the same benefits as multi-shard configurations.
        If you are upgrading a replica set to a sharded cluster, you cannot increase the number of shards in the same update request. You should wait until after the cluster has completed upgrading to sharded and you have reconnected all application clients to the MongoDB router before adding additional shards. Otherwise, your data might become inconsistent once MongoDB Cloud begins distributing data across shards. To learn more, see [Convert a replica set to a sharded cluster documentation](https://www.mongodb.com/docs/atlas/scale-cluster/#convert-a-replica-set-to-a-sharded-cluster) and [Convert a replica set to a sharded cluster tutorial](https://www.mongodb.com/docs/upcoming/tutorial/convert-replica-set-to-replicated-shard-cluster). **(DEPRECATED)** To learn more, see the 1.18.0 Upgrade Guide.
        """
        zone_id: NotRequired[pulumi.Input[str]]
        """
        Unique 24-hexadecimal digit string that identifies the zone in a Global Cluster. If clusterType is GEOSHARDED, this value indicates the zone that the given shard belongs to and can be used to configure Global Cluster backup policies.
        """
        zone_name: NotRequired[pulumi.Input[str]]
        """
        Name for the zone in a Global Cluster.
        """
elif False:
    AdvancedClusterReplicationSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AdvancedClusterReplicationSpecArgs:
    def __init__(__self__, *,
                 region_configs: pulumi.Input[Sequence[pulumi.Input['AdvancedClusterReplicationSpecRegionConfigArgs']]],
                 container_id: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 external_id: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 num_shards: Optional[pulumi.Input[int]] = None,
                 zone_id: Optional[pulumi.Input[str]] = None,
                 zone_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AdvancedClusterReplicationSpecRegionConfigArgs']]] region_configs: Configuration for the hardware specifications for nodes set for a given regionEach `region_configs` object describes the region's priority in elections and the number and type of MongoDB nodes that Atlas deploys to the region. Each `region_configs` object must have either an `analytics_specs` object, `electable_specs` object, or `read_only_specs` object. See below
        :param pulumi.Input[str] external_id: Unique 24-hexadecimal digit string that identifies the replication object for a shard in a Cluster. This value corresponds to Shard ID displayed in the UI. When using old sharding configuration (replication spec with `num_shards` greater than 1) this value is not populated.
        :param pulumi.Input[str] id: **(DEPRECATED)** Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        :param pulumi.Input[int] num_shards: Provide this value if you set a `cluster_type` of SHARDED or GEOSHARDED. Omit this value if you selected a `cluster_type` of REPLICASET. This API resource accepts 1 through 50, inclusive. This parameter defaults to 1. If you specify a `num_shards` value of 1 and a `cluster_type` of SHARDED, Atlas deploys a single-shard [sharded cluster](https://docs.atlas.mongodb.com/reference/glossary/#std-term-sharded-cluster). Don't create a sharded cluster with a single shard for production environments. Single-shard sharded clusters don't provide the same benefits as multi-shard configurations.
               If you are upgrading a replica set to a sharded cluster, you cannot increase the number of shards in the same update request. You should wait until after the cluster has completed upgrading to sharded and you have reconnected all application clients to the MongoDB router before adding additional shards. Otherwise, your data might become inconsistent once MongoDB Cloud begins distributing data across shards. To learn more, see [Convert a replica set to a sharded cluster documentation](https://www.mongodb.com/docs/atlas/scale-cluster/#convert-a-replica-set-to-a-sharded-cluster) and [Convert a replica set to a sharded cluster tutorial](https://www.mongodb.com/docs/upcoming/tutorial/convert-replica-set-to-replicated-shard-cluster). **(DEPRECATED)** To learn more, see the 1.18.0 Upgrade Guide.
        :param pulumi.Input[str] zone_id: Unique 24-hexadecimal digit string that identifies the zone in a Global Cluster. If clusterType is GEOSHARDED, this value indicates the zone that the given shard belongs to and can be used to configure Global Cluster backup policies.
        :param pulumi.Input[str] zone_name: Name for the zone in a Global Cluster.
        """
        pulumi.set(__self__, "region_configs", region_configs)
        if container_id is not None:
            pulumi.set(__self__, "container_id", container_id)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if id is not None:
            warnings.warn("""This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown""", DeprecationWarning)
            pulumi.log.warn("""id is deprecated: This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown""")
        if id is not None:
            pulumi.set(__self__, "id", id)
        if num_shards is not None:
            warnings.warn("""This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown""", DeprecationWarning)
            pulumi.log.warn("""num_shards is deprecated: This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown""")
        if num_shards is not None:
            pulumi.set(__self__, "num_shards", num_shards)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)
        if zone_name is not None:
            pulumi.set(__self__, "zone_name", zone_name)

    @property
    @pulumi.getter(name="regionConfigs")
    def region_configs(self) -> pulumi.Input[Sequence[pulumi.Input['AdvancedClusterReplicationSpecRegionConfigArgs']]]:
        """
        Configuration for the hardware specifications for nodes set for a given regionEach `region_configs` object describes the region's priority in elections and the number and type of MongoDB nodes that Atlas deploys to the region. Each `region_configs` object must have either an `analytics_specs` object, `electable_specs` object, or `read_only_specs` object. See below
        """
        return pulumi.get(self, "region_configs")

    @region_configs.setter
    def region_configs(self, value: pulumi.Input[Sequence[pulumi.Input['AdvancedClusterReplicationSpecRegionConfigArgs']]]):
        pulumi.set(self, "region_configs", value)

    @property
    @pulumi.getter(name="containerId")
    def container_id(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "container_id")

    @container_id.setter
    def container_id(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "container_id", value)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique 24-hexadecimal digit string that identifies the replication object for a shard in a Cluster. This value corresponds to Shard ID displayed in the UI. When using old sharding configuration (replication spec with `num_shards` greater than 1) this value is not populated.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "external_id", value)

    @property
    @pulumi.getter
    @_utilities.deprecated("""This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown""")
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        **(DEPRECATED)** Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="numShards")
    @_utilities.deprecated("""This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown""")
    def num_shards(self) -> Optional[pulumi.Input[int]]:
        """
        Provide this value if you set a `cluster_type` of SHARDED or GEOSHARDED. Omit this value if you selected a `cluster_type` of REPLICASET. This API resource accepts 1 through 50, inclusive. This parameter defaults to 1. If you specify a `num_shards` value of 1 and a `cluster_type` of SHARDED, Atlas deploys a single-shard [sharded cluster](https://docs.atlas.mongodb.com/reference/glossary/#std-term-sharded-cluster). Don't create a sharded cluster with a single shard for production environments. Single-shard sharded clusters don't provide the same benefits as multi-shard configurations.
        If you are upgrading a replica set to a sharded cluster, you cannot increase the number of shards in the same update request. You should wait until after the cluster has completed upgrading to sharded and you have reconnected all application clients to the MongoDB router before adding additional shards. Otherwise, your data might become inconsistent once MongoDB Cloud begins distributing data across shards. To learn more, see [Convert a replica set to a sharded cluster documentation](https://www.mongodb.com/docs/atlas/scale-cluster/#convert-a-replica-set-to-a-sharded-cluster) and [Convert a replica set to a sharded cluster tutorial](https://www.mongodb.com/docs/upcoming/tutorial/convert-replica-set-to-replicated-shard-cluster). **(DEPRECATED)** To learn more, see the 1.18.0 Upgrade Guide.
        """
        return pulumi.get(self, "num_shards")

    @num_shards.setter
    def num_shards(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_shards", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique 24-hexadecimal digit string that identifies the zone in a Global Cluster. If clusterType is GEOSHARDED, this value indicates the zone that the given shard belongs to and can be used to configure Global Cluster backup policies.
        """
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone_id", value)

    @property
    @pulumi.getter(name="zoneName")
    def zone_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name for the zone in a Global Cluster.
        """
        return pulumi.get(self, "zone_name")

    @zone_name.setter
    def zone_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone_name", value)


if not MYPY:
    class AdvancedClusterReplicationSpecRegionConfigArgsDict(TypedDict):
        priority: pulumi.Input[int]
        """
        Election priority of the region. For regions with only read-only nodes, set this value to 0.
        * If you have multiple `region_configs` objects (your cluster is multi-region or multi-cloud), they must have priorities in descending order. The highest priority is 7.
        * If your region has set `region_configs.#.electable_specs.0.node_count` to 1 or higher, it must have a priority of exactly one (1) less than another region in the `replication_specs.#.region_configs.#` array. The highest-priority region must have a priority of 7. The lowest possible priority is 1.
        """
        provider_name: pulumi.Input[str]
        """
        Cloud service provider on which the servers are provisioned.
        The possible values are:

        - `AWS` - Amazon AWS
        - `GCP` - Google Cloud Platform
        - `AZURE` - Microsoft Azure
        - `TENANT` - M0, M2 or M5 multi-tenant cluster. Use `replication_specs.#.region_configs.#.backing_provider_name` to set the cloud service provider.
        """
        region_name: pulumi.Input[str]
        """
        Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        """
        analytics_auto_scaling: NotRequired[pulumi.Input['AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScalingArgsDict']]
        """
        Configuration for the Collection of settings that configures analytics-auto-scaling information for the cluster. The values for the `analytics_auto_scaling` parameter must be the same for all `region_configs` in all `replication_specs`. See below
        """
        analytics_specs: NotRequired[pulumi.Input['AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsArgsDict']]
        """
        Hardware specifications for [analytics nodes](https://docs.atlas.mongodb.com/reference/faq/deployment/#std-label-analytics-nodes-overview) needed in the region. Analytics nodes handle analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only and can never become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary). If you don't specify this parameter, no analytics nodes deploy to this region. See below
        """
        auto_scaling: NotRequired[pulumi.Input['AdvancedClusterReplicationSpecRegionConfigAutoScalingArgsDict']]
        """
        Configuration for the Collection of settings that configures auto-scaling information for the cluster. The values for the `auto_scaling` parameter must be the same for all `region_configs` in all `replication_specs`. See below
        """
        backing_provider_name: NotRequired[pulumi.Input[str]]
        """
        Cloud service provider on which you provision the host for a multi-tenant cluster. Use this only when a `provider_name` is `TENANT` and `instance_size` of a specs is `M2` or `M5`.
        """
        electable_specs: NotRequired[pulumi.Input['AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgsDict']]
        """
        Hardware specifications for electable nodes in the region. Electable nodes can become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary) and can enable local reads. If you do not specify this option, no electable nodes are deployed to the region. See below
        """
        read_only_specs: NotRequired[pulumi.Input['AdvancedClusterReplicationSpecRegionConfigReadOnlySpecsArgsDict']]
        """
        Hardware specifications for read-only nodes in the region. Read-only nodes can become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary) and can enable local reads. If you don't specify this parameter, no read-only nodes are deployed to the region. See below
        """
elif False:
    AdvancedClusterReplicationSpecRegionConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AdvancedClusterReplicationSpecRegionConfigArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 provider_name: pulumi.Input[str],
                 region_name: pulumi.Input[str],
                 analytics_auto_scaling: Optional[pulumi.Input['AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScalingArgs']] = None,
                 analytics_specs: Optional[pulumi.Input['AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsArgs']] = None,
                 auto_scaling: Optional[pulumi.Input['AdvancedClusterReplicationSpecRegionConfigAutoScalingArgs']] = None,
                 backing_provider_name: Optional[pulumi.Input[str]] = None,
                 electable_specs: Optional[pulumi.Input['AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs']] = None,
                 read_only_specs: Optional[pulumi.Input['AdvancedClusterReplicationSpecRegionConfigReadOnlySpecsArgs']] = None):
        """
        :param pulumi.Input[int] priority: Election priority of the region. For regions with only read-only nodes, set this value to 0.
               * If you have multiple `region_configs` objects (your cluster is multi-region or multi-cloud), they must have priorities in descending order. The highest priority is 7.
               * If your region has set `region_configs.#.electable_specs.0.node_count` to 1 or higher, it must have a priority of exactly one (1) less than another region in the `replication_specs.#.region_configs.#` array. The highest-priority region must have a priority of 7. The lowest possible priority is 1.
        :param pulumi.Input[str] provider_name: Cloud service provider on which the servers are provisioned.
               The possible values are:
               
               - `AWS` - Amazon AWS
               - `GCP` - Google Cloud Platform
               - `AZURE` - Microsoft Azure
               - `TENANT` - M0, M2 or M5 multi-tenant cluster. Use `replication_specs.#.region_configs.#.backing_provider_name` to set the cloud service provider.
        :param pulumi.Input[str] region_name: Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        :param pulumi.Input['AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScalingArgs'] analytics_auto_scaling: Configuration for the Collection of settings that configures analytics-auto-scaling information for the cluster. The values for the `analytics_auto_scaling` parameter must be the same for all `region_configs` in all `replication_specs`. See below
        :param pulumi.Input['AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsArgs'] analytics_specs: Hardware specifications for [analytics nodes](https://docs.atlas.mongodb.com/reference/faq/deployment/#std-label-analytics-nodes-overview) needed in the region. Analytics nodes handle analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only and can never become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary). If you don't specify this parameter, no analytics nodes deploy to this region. See below
        :param pulumi.Input['AdvancedClusterReplicationSpecRegionConfigAutoScalingArgs'] auto_scaling: Configuration for the Collection of settings that configures auto-scaling information for the cluster. The values for the `auto_scaling` parameter must be the same for all `region_configs` in all `replication_specs`. See below
        :param pulumi.Input[str] backing_provider_name: Cloud service provider on which you provision the host for a multi-tenant cluster. Use this only when a `provider_name` is `TENANT` and `instance_size` of a specs is `M2` or `M5`.
        :param pulumi.Input['AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs'] electable_specs: Hardware specifications for electable nodes in the region. Electable nodes can become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary) and can enable local reads. If you do not specify this option, no electable nodes are deployed to the region. See below
        :param pulumi.Input['AdvancedClusterReplicationSpecRegionConfigReadOnlySpecsArgs'] read_only_specs: Hardware specifications for read-only nodes in the region. Read-only nodes can become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary) and can enable local reads. If you don't specify this parameter, no read-only nodes are deployed to the region. See below
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "region_name", region_name)
        if analytics_auto_scaling is not None:
            pulumi.set(__self__, "analytics_auto_scaling", analytics_auto_scaling)
        if analytics_specs is not None:
            pulumi.set(__self__, "analytics_specs", analytics_specs)
        if auto_scaling is not None:
            pulumi.set(__self__, "auto_scaling", auto_scaling)
        if backing_provider_name is not None:
            pulumi.set(__self__, "backing_provider_name", backing_provider_name)
        if electable_specs is not None:
            pulumi.set(__self__, "electable_specs", electable_specs)
        if read_only_specs is not None:
            pulumi.set(__self__, "read_only_specs", read_only_specs)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Election priority of the region. For regions with only read-only nodes, set this value to 0.
        * If you have multiple `region_configs` objects (your cluster is multi-region or multi-cloud), they must have priorities in descending order. The highest priority is 7.
        * If your region has set `region_configs.#.electable_specs.0.node_count` to 1 or higher, it must have a priority of exactly one (1) less than another region in the `replication_specs.#.region_configs.#` array. The highest-priority region must have a priority of 7. The lowest possible priority is 1.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> pulumi.Input[str]:
        """
        Cloud service provider on which the servers are provisioned.
        The possible values are:

        - `AWS` - Amazon AWS
        - `GCP` - Google Cloud Platform
        - `AZURE` - Microsoft Azure
        - `TENANT` - M0, M2 or M5 multi-tenant cluster. Use `replication_specs.#.region_configs.#.backing_provider_name` to set the cloud service provider.
        """
        return pulumi.get(self, "provider_name")

    @provider_name.setter
    def provider_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "provider_name", value)

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> pulumi.Input[str]:
        """
        Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        """
        return pulumi.get(self, "region_name")

    @region_name.setter
    def region_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "region_name", value)

    @property
    @pulumi.getter(name="analyticsAutoScaling")
    def analytics_auto_scaling(self) -> Optional[pulumi.Input['AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScalingArgs']]:
        """
        Configuration for the Collection of settings that configures analytics-auto-scaling information for the cluster. The values for the `analytics_auto_scaling` parameter must be the same for all `region_configs` in all `replication_specs`. See below
        """
        return pulumi.get(self, "analytics_auto_scaling")

    @analytics_auto_scaling.setter
    def analytics_auto_scaling(self, value: Optional[pulumi.Input['AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScalingArgs']]):
        pulumi.set(self, "analytics_auto_scaling", value)

    @property
    @pulumi.getter(name="analyticsSpecs")
    def analytics_specs(self) -> Optional[pulumi.Input['AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsArgs']]:
        """
        Hardware specifications for [analytics nodes](https://docs.atlas.mongodb.com/reference/faq/deployment/#std-label-analytics-nodes-overview) needed in the region. Analytics nodes handle analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only and can never become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary). If you don't specify this parameter, no analytics nodes deploy to this region. See below
        """
        return pulumi.get(self, "analytics_specs")

    @analytics_specs.setter
    def analytics_specs(self, value: Optional[pulumi.Input['AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsArgs']]):
        pulumi.set(self, "analytics_specs", value)

    @property
    @pulumi.getter(name="autoScaling")
    def auto_scaling(self) -> Optional[pulumi.Input['AdvancedClusterReplicationSpecRegionConfigAutoScalingArgs']]:
        """
        Configuration for the Collection of settings that configures auto-scaling information for the cluster. The values for the `auto_scaling` parameter must be the same for all `region_configs` in all `replication_specs`. See below
        """
        return pulumi.get(self, "auto_scaling")

    @auto_scaling.setter
    def auto_scaling(self, value: Optional[pulumi.Input['AdvancedClusterReplicationSpecRegionConfigAutoScalingArgs']]):
        pulumi.set(self, "auto_scaling", value)

    @property
    @pulumi.getter(name="backingProviderName")
    def backing_provider_name(self) -> Optional[pulumi.Input[str]]:
        """
        Cloud service provider on which you provision the host for a multi-tenant cluster. Use this only when a `provider_name` is `TENANT` and `instance_size` of a specs is `M2` or `M5`.
        """
        return pulumi.get(self, "backing_provider_name")

    @backing_provider_name.setter
    def backing_provider_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backing_provider_name", value)

    @property
    @pulumi.getter(name="electableSpecs")
    def electable_specs(self) -> Optional[pulumi.Input['AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs']]:
        """
        Hardware specifications for electable nodes in the region. Electable nodes can become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary) and can enable local reads. If you do not specify this option, no electable nodes are deployed to the region. See below
        """
        return pulumi.get(self, "electable_specs")

    @electable_specs.setter
    def electable_specs(self, value: Optional[pulumi.Input['AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs']]):
        pulumi.set(self, "electable_specs", value)

    @property
    @pulumi.getter(name="readOnlySpecs")
    def read_only_specs(self) -> Optional[pulumi.Input['AdvancedClusterReplicationSpecRegionConfigReadOnlySpecsArgs']]:
        """
        Hardware specifications for read-only nodes in the region. Read-only nodes can become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary) and can enable local reads. If you don't specify this parameter, no read-only nodes are deployed to the region. See below
        """
        return pulumi.get(self, "read_only_specs")

    @read_only_specs.setter
    def read_only_specs(self, value: Optional[pulumi.Input['AdvancedClusterReplicationSpecRegionConfigReadOnlySpecsArgs']]):
        pulumi.set(self, "read_only_specs", value)


if not MYPY:
    class AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScalingArgsDict(TypedDict):
        compute_enabled: NotRequired[pulumi.Input[bool]]
        compute_max_instance_size: NotRequired[pulumi.Input[str]]
        """
        Maximum instance size to which your cluster can automatically scale (such as M40). Atlas requires this parameter if `replication_specs.#.region_configs.#.analytics_auto_scaling.0.compute_enabled` is true.
        """
        compute_min_instance_size: NotRequired[pulumi.Input[str]]
        """
        Minimum instance size to which your cluster can automatically scale (such as M10). Atlas requires this parameter if `replication_specs.#.region_configs.#.analytics_auto_scaling.0.compute_scale_down_enabled` is true.
        """
        compute_scale_down_enabled: NotRequired[pulumi.Input[bool]]
        """
        Flag that indicates whether the instance size may scale down. Atlas requires this parameter if `replication_specs.#.region_configs.#.analytics_auto_scaling.0.compute_enabled` : true. If you enable this option, specify a value for `replication_specs.#.region_configs.#.analytics_auto_scaling.0.compute_min_instance_size`.
        """
        disk_gb_enabled: NotRequired[pulumi.Input[bool]]
        """
        Flag that indicates whether this cluster enables disk auto-scaling. This parameter defaults to false.
        """
elif False:
    AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScalingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScalingArgs:
    def __init__(__self__, *,
                 compute_enabled: Optional[pulumi.Input[bool]] = None,
                 compute_max_instance_size: Optional[pulumi.Input[str]] = None,
                 compute_min_instance_size: Optional[pulumi.Input[str]] = None,
                 compute_scale_down_enabled: Optional[pulumi.Input[bool]] = None,
                 disk_gb_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] compute_max_instance_size: Maximum instance size to which your cluster can automatically scale (such as M40). Atlas requires this parameter if `replication_specs.#.region_configs.#.analytics_auto_scaling.0.compute_enabled` is true.
        :param pulumi.Input[str] compute_min_instance_size: Minimum instance size to which your cluster can automatically scale (such as M10). Atlas requires this parameter if `replication_specs.#.region_configs.#.analytics_auto_scaling.0.compute_scale_down_enabled` is true.
        :param pulumi.Input[bool] compute_scale_down_enabled: Flag that indicates whether the instance size may scale down. Atlas requires this parameter if `replication_specs.#.region_configs.#.analytics_auto_scaling.0.compute_enabled` : true. If you enable this option, specify a value for `replication_specs.#.region_configs.#.analytics_auto_scaling.0.compute_min_instance_size`.
        :param pulumi.Input[bool] disk_gb_enabled: Flag that indicates whether this cluster enables disk auto-scaling. This parameter defaults to false.
        """
        if compute_enabled is not None:
            pulumi.set(__self__, "compute_enabled", compute_enabled)
        if compute_max_instance_size is not None:
            pulumi.set(__self__, "compute_max_instance_size", compute_max_instance_size)
        if compute_min_instance_size is not None:
            pulumi.set(__self__, "compute_min_instance_size", compute_min_instance_size)
        if compute_scale_down_enabled is not None:
            pulumi.set(__self__, "compute_scale_down_enabled", compute_scale_down_enabled)
        if disk_gb_enabled is not None:
            pulumi.set(__self__, "disk_gb_enabled", disk_gb_enabled)

    @property
    @pulumi.getter(name="computeEnabled")
    def compute_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "compute_enabled")

    @compute_enabled.setter
    def compute_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "compute_enabled", value)

    @property
    @pulumi.getter(name="computeMaxInstanceSize")
    def compute_max_instance_size(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum instance size to which your cluster can automatically scale (such as M40). Atlas requires this parameter if `replication_specs.#.region_configs.#.analytics_auto_scaling.0.compute_enabled` is true.
        """
        return pulumi.get(self, "compute_max_instance_size")

    @compute_max_instance_size.setter
    def compute_max_instance_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compute_max_instance_size", value)

    @property
    @pulumi.getter(name="computeMinInstanceSize")
    def compute_min_instance_size(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum instance size to which your cluster can automatically scale (such as M10). Atlas requires this parameter if `replication_specs.#.region_configs.#.analytics_auto_scaling.0.compute_scale_down_enabled` is true.
        """
        return pulumi.get(self, "compute_min_instance_size")

    @compute_min_instance_size.setter
    def compute_min_instance_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compute_min_instance_size", value)

    @property
    @pulumi.getter(name="computeScaleDownEnabled")
    def compute_scale_down_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag that indicates whether the instance size may scale down. Atlas requires this parameter if `replication_specs.#.region_configs.#.analytics_auto_scaling.0.compute_enabled` : true. If you enable this option, specify a value for `replication_specs.#.region_configs.#.analytics_auto_scaling.0.compute_min_instance_size`.
        """
        return pulumi.get(self, "compute_scale_down_enabled")

    @compute_scale_down_enabled.setter
    def compute_scale_down_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "compute_scale_down_enabled", value)

    @property
    @pulumi.getter(name="diskGbEnabled")
    def disk_gb_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag that indicates whether this cluster enables disk auto-scaling. This parameter defaults to false.
        """
        return pulumi.get(self, "disk_gb_enabled")

    @disk_gb_enabled.setter
    def disk_gb_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disk_gb_enabled", value)


if not MYPY:
    class AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsArgsDict(TypedDict):
        instance_size: pulumi.Input[str]
        """
        Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts in your instance size. Electable nodes and read-only nodes (known as "base nodes") within a single shard must use the same instance size. Analytics nodes can scale independently from base nodes within a shard. Both base nodes and analytics nodes can scale independently from their equivalents in other shards.
        """
        disk_iops: NotRequired[pulumi.Input[int]]
        """
        Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. Define this attribute only if you selected AWS as your cloud service provider, `instance_size` is set to "M30" or greater (not including "Mxx_NVME" tiers), and `ebs_volume_type` is "PROVISIONED". You can't set this attribute for a multi-cloud cluster.
        """
        disk_size_gb: NotRequired[pulumi.Input[float]]
        """
        Storage capacity that the host's root volume possesses expressed in gigabytes. This value must be equal for all shards and node types. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier. **Note:** Using `disk_size_gb` with Standard IOPS could lead to errors and configuration issues. Therefore, it should be used only with the Provisioned IOPS volume type. When using Provisioned IOPS, the disk_size_gb parameter specifies the storage capacity, but the IOPS are set independently. Ensuring that `disk_size_gb` is used exclusively with Provisioned IOPS will help avoid these issues.
        """
        ebs_volume_type: NotRequired[pulumi.Input[str]]
        """
        Type of storage you want to attach to your AWS-provisioned cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster. Valid values are:
        * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
        * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        """
        node_count: NotRequired[pulumi.Input[int]]
        """
        Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
elif False:
    AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsArgs:
    def __init__(__self__, *,
                 instance_size: pulumi.Input[str],
                 disk_iops: Optional[pulumi.Input[int]] = None,
                 disk_size_gb: Optional[pulumi.Input[float]] = None,
                 ebs_volume_type: Optional[pulumi.Input[str]] = None,
                 node_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] instance_size: Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts in your instance size. Electable nodes and read-only nodes (known as "base nodes") within a single shard must use the same instance size. Analytics nodes can scale independently from base nodes within a shard. Both base nodes and analytics nodes can scale independently from their equivalents in other shards.
        :param pulumi.Input[int] disk_iops: Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. Define this attribute only if you selected AWS as your cloud service provider, `instance_size` is set to "M30" or greater (not including "Mxx_NVME" tiers), and `ebs_volume_type` is "PROVISIONED". You can't set this attribute for a multi-cloud cluster.
        :param pulumi.Input[float] disk_size_gb: Storage capacity that the host's root volume possesses expressed in gigabytes. This value must be equal for all shards and node types. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier. **Note:** Using `disk_size_gb` with Standard IOPS could lead to errors and configuration issues. Therefore, it should be used only with the Provisioned IOPS volume type. When using Provisioned IOPS, the disk_size_gb parameter specifies the storage capacity, but the IOPS are set independently. Ensuring that `disk_size_gb` is used exclusively with Provisioned IOPS will help avoid these issues.
        :param pulumi.Input[str] ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster. Valid values are:
               * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
               * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        :param pulumi.Input[int] node_count: Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        pulumi.set(__self__, "instance_size", instance_size)
        if disk_iops is not None:
            pulumi.set(__self__, "disk_iops", disk_iops)
        if disk_size_gb is not None:
            pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)

    @property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> pulumi.Input[str]:
        """
        Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts in your instance size. Electable nodes and read-only nodes (known as "base nodes") within a single shard must use the same instance size. Analytics nodes can scale independently from base nodes within a shard. Both base nodes and analytics nodes can scale independently from their equivalents in other shards.
        """
        return pulumi.get(self, "instance_size")

    @instance_size.setter
    def instance_size(self, value: pulumi.Input[str]):
        pulumi.set(self, "instance_size", value)

    @property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> Optional[pulumi.Input[int]]:
        """
        Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. Define this attribute only if you selected AWS as your cloud service provider, `instance_size` is set to "M30" or greater (not including "Mxx_NVME" tiers), and `ebs_volume_type` is "PROVISIONED". You can't set this attribute for a multi-cloud cluster.
        """
        return pulumi.get(self, "disk_iops")

    @disk_iops.setter
    def disk_iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_iops", value)

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> Optional[pulumi.Input[float]]:
        """
        Storage capacity that the host's root volume possesses expressed in gigabytes. This value must be equal for all shards and node types. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier. **Note:** Using `disk_size_gb` with Standard IOPS could lead to errors and configuration issues. Therefore, it should be used only with the Provisioned IOPS volume type. When using Provisioned IOPS, the disk_size_gb parameter specifies the storage capacity, but the IOPS are set independently. Ensuring that `disk_size_gb` is used exclusively with Provisioned IOPS will help avoid these issues.
        """
        return pulumi.get(self, "disk_size_gb")

    @disk_size_gb.setter
    def disk_size_gb(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "disk_size_gb", value)

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of storage you want to attach to your AWS-provisioned cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster. Valid values are:
        * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
        * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        """
        return pulumi.get(self, "ebs_volume_type")

    @ebs_volume_type.setter
    def ebs_volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ebs_volume_type", value)

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[pulumi.Input[int]]:
        """
        Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        return pulumi.get(self, "node_count")

    @node_count.setter
    def node_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "node_count", value)


if not MYPY:
    class AdvancedClusterReplicationSpecRegionConfigAutoScalingArgsDict(TypedDict):
        compute_enabled: NotRequired[pulumi.Input[bool]]
        compute_max_instance_size: NotRequired[pulumi.Input[str]]
        """
        Maximum instance size to which your cluster can automatically scale (such as M40). Atlas requires this parameter if `replication_specs.#.region_configs.#.auto_scaling.0.compute_enabled` is true.
        """
        compute_min_instance_size: NotRequired[pulumi.Input[str]]
        """
        Minimum instance size to which your cluster can automatically scale (such as M10). Atlas requires this parameter if `replication_specs.#.region_configs.#.auto_scaling.0.compute_scale_down_enabled` is true.
        """
        compute_scale_down_enabled: NotRequired[pulumi.Input[bool]]
        """
        Flag that indicates whether the instance size may scale down. Atlas requires this parameter if `replication_specs.#.region_configs.#.auto_scaling.0.compute_enabled` : true. If you enable this option, specify a value for `replication_specs.#.region_configs.#.auto_scaling.0.compute_min_instance_size`.
        """
        disk_gb_enabled: NotRequired[pulumi.Input[bool]]
elif False:
    AdvancedClusterReplicationSpecRegionConfigAutoScalingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AdvancedClusterReplicationSpecRegionConfigAutoScalingArgs:
    def __init__(__self__, *,
                 compute_enabled: Optional[pulumi.Input[bool]] = None,
                 compute_max_instance_size: Optional[pulumi.Input[str]] = None,
                 compute_min_instance_size: Optional[pulumi.Input[str]] = None,
                 compute_scale_down_enabled: Optional[pulumi.Input[bool]] = None,
                 disk_gb_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] compute_max_instance_size: Maximum instance size to which your cluster can automatically scale (such as M40). Atlas requires this parameter if `replication_specs.#.region_configs.#.auto_scaling.0.compute_enabled` is true.
        :param pulumi.Input[str] compute_min_instance_size: Minimum instance size to which your cluster can automatically scale (such as M10). Atlas requires this parameter if `replication_specs.#.region_configs.#.auto_scaling.0.compute_scale_down_enabled` is true.
        :param pulumi.Input[bool] compute_scale_down_enabled: Flag that indicates whether the instance size may scale down. Atlas requires this parameter if `replication_specs.#.region_configs.#.auto_scaling.0.compute_enabled` : true. If you enable this option, specify a value for `replication_specs.#.region_configs.#.auto_scaling.0.compute_min_instance_size`.
        """
        if compute_enabled is not None:
            pulumi.set(__self__, "compute_enabled", compute_enabled)
        if compute_max_instance_size is not None:
            pulumi.set(__self__, "compute_max_instance_size", compute_max_instance_size)
        if compute_min_instance_size is not None:
            pulumi.set(__self__, "compute_min_instance_size", compute_min_instance_size)
        if compute_scale_down_enabled is not None:
            pulumi.set(__self__, "compute_scale_down_enabled", compute_scale_down_enabled)
        if disk_gb_enabled is not None:
            pulumi.set(__self__, "disk_gb_enabled", disk_gb_enabled)

    @property
    @pulumi.getter(name="computeEnabled")
    def compute_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "compute_enabled")

    @compute_enabled.setter
    def compute_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "compute_enabled", value)

    @property
    @pulumi.getter(name="computeMaxInstanceSize")
    def compute_max_instance_size(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum instance size to which your cluster can automatically scale (such as M40). Atlas requires this parameter if `replication_specs.#.region_configs.#.auto_scaling.0.compute_enabled` is true.
        """
        return pulumi.get(self, "compute_max_instance_size")

    @compute_max_instance_size.setter
    def compute_max_instance_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compute_max_instance_size", value)

    @property
    @pulumi.getter(name="computeMinInstanceSize")
    def compute_min_instance_size(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum instance size to which your cluster can automatically scale (such as M10). Atlas requires this parameter if `replication_specs.#.region_configs.#.auto_scaling.0.compute_scale_down_enabled` is true.
        """
        return pulumi.get(self, "compute_min_instance_size")

    @compute_min_instance_size.setter
    def compute_min_instance_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compute_min_instance_size", value)

    @property
    @pulumi.getter(name="computeScaleDownEnabled")
    def compute_scale_down_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag that indicates whether the instance size may scale down. Atlas requires this parameter if `replication_specs.#.region_configs.#.auto_scaling.0.compute_enabled` : true. If you enable this option, specify a value for `replication_specs.#.region_configs.#.auto_scaling.0.compute_min_instance_size`.
        """
        return pulumi.get(self, "compute_scale_down_enabled")

    @compute_scale_down_enabled.setter
    def compute_scale_down_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "compute_scale_down_enabled", value)

    @property
    @pulumi.getter(name="diskGbEnabled")
    def disk_gb_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "disk_gb_enabled")

    @disk_gb_enabled.setter
    def disk_gb_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disk_gb_enabled", value)


if not MYPY:
    class AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgsDict(TypedDict):
        instance_size: pulumi.Input[str]
        """
        Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts in your instance size. Electable nodes and read-only nodes (known as "base nodes") within a single shard must use the same instance size. Analytics nodes can scale independently from base nodes within a shard. Both base nodes and analytics nodes can scale independently from their equivalents in other shards.
        """
        disk_iops: NotRequired[pulumi.Input[int]]
        """
        Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. Define this attribute only if you selected AWS as your cloud service provider, `instance_size` is set to "M30" or greater (not including "Mxx_NVME" tiers), and `ebs_volume_type` is "PROVISIONED". You can't set this attribute for a multi-cloud cluster.
        """
        disk_size_gb: NotRequired[pulumi.Input[float]]
        """
        Storage capacity that the host's root volume possesses expressed in gigabytes. This value must be equal for all shards and node types. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier. **Note:** Using `disk_size_gb` with Standard IOPS could lead to errors and configuration issues. Therefore, it should be used only with the Provisioned IOPS volume type. When using Provisioned IOPS, the disk_size_gb parameter specifies the storage capacity, but the IOPS are set independently. Ensuring that `disk_size_gb` is used exclusively with Provisioned IOPS will help avoid these issues.
        """
        ebs_volume_type: NotRequired[pulumi.Input[str]]
        """
        Type of storage you want to attach to your AWS-provisioned cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster. Valid values are:
        * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
        * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        """
        node_count: NotRequired[pulumi.Input[int]]
        """
        Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
elif False:
    AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs:
    def __init__(__self__, *,
                 instance_size: pulumi.Input[str],
                 disk_iops: Optional[pulumi.Input[int]] = None,
                 disk_size_gb: Optional[pulumi.Input[float]] = None,
                 ebs_volume_type: Optional[pulumi.Input[str]] = None,
                 node_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] instance_size: Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts in your instance size. Electable nodes and read-only nodes (known as "base nodes") within a single shard must use the same instance size. Analytics nodes can scale independently from base nodes within a shard. Both base nodes and analytics nodes can scale independently from their equivalents in other shards.
        :param pulumi.Input[int] disk_iops: Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. Define this attribute only if you selected AWS as your cloud service provider, `instance_size` is set to "M30" or greater (not including "Mxx_NVME" tiers), and `ebs_volume_type` is "PROVISIONED". You can't set this attribute for a multi-cloud cluster.
        :param pulumi.Input[float] disk_size_gb: Storage capacity that the host's root volume possesses expressed in gigabytes. This value must be equal for all shards and node types. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier. **Note:** Using `disk_size_gb` with Standard IOPS could lead to errors and configuration issues. Therefore, it should be used only with the Provisioned IOPS volume type. When using Provisioned IOPS, the disk_size_gb parameter specifies the storage capacity, but the IOPS are set independently. Ensuring that `disk_size_gb` is used exclusively with Provisioned IOPS will help avoid these issues.
        :param pulumi.Input[str] ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster. Valid values are:
               * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
               * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        :param pulumi.Input[int] node_count: Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        pulumi.set(__self__, "instance_size", instance_size)
        if disk_iops is not None:
            pulumi.set(__self__, "disk_iops", disk_iops)
        if disk_size_gb is not None:
            pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)

    @property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> pulumi.Input[str]:
        """
        Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts in your instance size. Electable nodes and read-only nodes (known as "base nodes") within a single shard must use the same instance size. Analytics nodes can scale independently from base nodes within a shard. Both base nodes and analytics nodes can scale independently from their equivalents in other shards.
        """
        return pulumi.get(self, "instance_size")

    @instance_size.setter
    def instance_size(self, value: pulumi.Input[str]):
        pulumi.set(self, "instance_size", value)

    @property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> Optional[pulumi.Input[int]]:
        """
        Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. Define this attribute only if you selected AWS as your cloud service provider, `instance_size` is set to "M30" or greater (not including "Mxx_NVME" tiers), and `ebs_volume_type` is "PROVISIONED". You can't set this attribute for a multi-cloud cluster.
        """
        return pulumi.get(self, "disk_iops")

    @disk_iops.setter
    def disk_iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_iops", value)

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> Optional[pulumi.Input[float]]:
        """
        Storage capacity that the host's root volume possesses expressed in gigabytes. This value must be equal for all shards and node types. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier. **Note:** Using `disk_size_gb` with Standard IOPS could lead to errors and configuration issues. Therefore, it should be used only with the Provisioned IOPS volume type. When using Provisioned IOPS, the disk_size_gb parameter specifies the storage capacity, but the IOPS are set independently. Ensuring that `disk_size_gb` is used exclusively with Provisioned IOPS will help avoid these issues.
        """
        return pulumi.get(self, "disk_size_gb")

    @disk_size_gb.setter
    def disk_size_gb(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "disk_size_gb", value)

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of storage you want to attach to your AWS-provisioned cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster. Valid values are:
        * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
        * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        """
        return pulumi.get(self, "ebs_volume_type")

    @ebs_volume_type.setter
    def ebs_volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ebs_volume_type", value)

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[pulumi.Input[int]]:
        """
        Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        return pulumi.get(self, "node_count")

    @node_count.setter
    def node_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "node_count", value)


if not MYPY:
    class AdvancedClusterReplicationSpecRegionConfigReadOnlySpecsArgsDict(TypedDict):
        instance_size: pulumi.Input[str]
        """
        Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts in your instance size. Electable nodes and read-only nodes (known as "base nodes") within a single shard must use the same instance size. Analytics nodes can scale independently from base nodes within a shard. Both base nodes and analytics nodes can scale independently from their equivalents in other shards.
        """
        disk_iops: NotRequired[pulumi.Input[int]]
        """
        Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. Define this attribute only if you selected AWS as your cloud service provider, `instance_size` is set to "M30" or greater (not including "Mxx_NVME" tiers), and `ebs_volume_type` is "PROVISIONED". You can't set this attribute for a multi-cloud cluster. This parameter defaults to the cluster tier's standard IOPS value.
        """
        disk_size_gb: NotRequired[pulumi.Input[float]]
        """
        Storage capacity that the host's root volume possesses expressed in gigabytes. This value must be equal for all shards and node types. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier. **Note:** Using `disk_size_gb` with Standard IOPS could lead to errors and configuration issues. Therefore, it should be used only with the Provisioned IOPS volume type. When using Provisioned IOPS, the disk_size_gb parameter specifies the storage capacity, but the IOPS are set independently. Ensuring that `disk_size_gb` is used exclusively with Provisioned IOPS will help avoid these issues.
        """
        ebs_volume_type: NotRequired[pulumi.Input[str]]
        """
        Type of storage you want to attach to your AWS-provisioned cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster. Valid values are:
        * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
        * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        """
        node_count: NotRequired[pulumi.Input[int]]
        """
        Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
elif False:
    AdvancedClusterReplicationSpecRegionConfigReadOnlySpecsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AdvancedClusterReplicationSpecRegionConfigReadOnlySpecsArgs:
    def __init__(__self__, *,
                 instance_size: pulumi.Input[str],
                 disk_iops: Optional[pulumi.Input[int]] = None,
                 disk_size_gb: Optional[pulumi.Input[float]] = None,
                 ebs_volume_type: Optional[pulumi.Input[str]] = None,
                 node_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] instance_size: Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts in your instance size. Electable nodes and read-only nodes (known as "base nodes") within a single shard must use the same instance size. Analytics nodes can scale independently from base nodes within a shard. Both base nodes and analytics nodes can scale independently from their equivalents in other shards.
        :param pulumi.Input[int] disk_iops: Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. Define this attribute only if you selected AWS as your cloud service provider, `instance_size` is set to "M30" or greater (not including "Mxx_NVME" tiers), and `ebs_volume_type` is "PROVISIONED". You can't set this attribute for a multi-cloud cluster. This parameter defaults to the cluster tier's standard IOPS value.
        :param pulumi.Input[float] disk_size_gb: Storage capacity that the host's root volume possesses expressed in gigabytes. This value must be equal for all shards and node types. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier. **Note:** Using `disk_size_gb` with Standard IOPS could lead to errors and configuration issues. Therefore, it should be used only with the Provisioned IOPS volume type. When using Provisioned IOPS, the disk_size_gb parameter specifies the storage capacity, but the IOPS are set independently. Ensuring that `disk_size_gb` is used exclusively with Provisioned IOPS will help avoid these issues.
        :param pulumi.Input[str] ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster. Valid values are:
               * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
               * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        :param pulumi.Input[int] node_count: Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        pulumi.set(__self__, "instance_size", instance_size)
        if disk_iops is not None:
            pulumi.set(__self__, "disk_iops", disk_iops)
        if disk_size_gb is not None:
            pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)

    @property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> pulumi.Input[str]:
        """
        Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts in your instance size. Electable nodes and read-only nodes (known as "base nodes") within a single shard must use the same instance size. Analytics nodes can scale independently from base nodes within a shard. Both base nodes and analytics nodes can scale independently from their equivalents in other shards.
        """
        return pulumi.get(self, "instance_size")

    @instance_size.setter
    def instance_size(self, value: pulumi.Input[str]):
        pulumi.set(self, "instance_size", value)

    @property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> Optional[pulumi.Input[int]]:
        """
        Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. Define this attribute only if you selected AWS as your cloud service provider, `instance_size` is set to "M30" or greater (not including "Mxx_NVME" tiers), and `ebs_volume_type` is "PROVISIONED". You can't set this attribute for a multi-cloud cluster. This parameter defaults to the cluster tier's standard IOPS value.
        """
        return pulumi.get(self, "disk_iops")

    @disk_iops.setter
    def disk_iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_iops", value)

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> Optional[pulumi.Input[float]]:
        """
        Storage capacity that the host's root volume possesses expressed in gigabytes. This value must be equal for all shards and node types. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier. **Note:** Using `disk_size_gb` with Standard IOPS could lead to errors and configuration issues. Therefore, it should be used only with the Provisioned IOPS volume type. When using Provisioned IOPS, the disk_size_gb parameter specifies the storage capacity, but the IOPS are set independently. Ensuring that `disk_size_gb` is used exclusively with Provisioned IOPS will help avoid these issues.
        """
        return pulumi.get(self, "disk_size_gb")

    @disk_size_gb.setter
    def disk_size_gb(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "disk_size_gb", value)

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of storage you want to attach to your AWS-provisioned cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster. Valid values are:
        * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
        * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        """
        return pulumi.get(self, "ebs_volume_type")

    @ebs_volume_type.setter
    def ebs_volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ebs_volume_type", value)

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[pulumi.Input[int]]:
        """
        Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        return pulumi.get(self, "node_count")

    @node_count.setter
    def node_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "node_count", value)


if not MYPY:
    class AdvancedClusterTagArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Constant that defines the set of the tag.
        """
        value: pulumi.Input[str]
        """
        Variable that belongs to the set of the tag.

        To learn more, see [Resource Tags](https://dochub.mongodb.org/core/add-cluster-tag-atlas).
        """
elif False:
    AdvancedClusterTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AdvancedClusterTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Constant that defines the set of the tag.
        :param pulumi.Input[str] value: Variable that belongs to the set of the tag.
               
               To learn more, see [Resource Tags](https://dochub.mongodb.org/core/add-cluster-tag-atlas).
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Constant that defines the set of the tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Variable that belongs to the set of the tag.

        To learn more, see [Resource Tags](https://dochub.mongodb.org/core/add-cluster-tag-atlas).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AlertConfigurationMatcherArgsDict(TypedDict):
        field_name: pulumi.Input[str]
        """
        Name of the field in the target object to match on.

        | Host alerts         | Replica set alerts  |  Sharded cluster alerts |
        |:----------           |:-------------       |:------                 |
        | `TYPE_NAME`         | `REPLICA_SET_NAME`  | `CLUSTER_NAME`          |
        | `HOSTNAME`          | `SHARD_NAME`        | `SHARD_NAME`            |
        | `PORT`              | `CLUSTER_NAME`      |                         |
        | `HOSTNAME_AND_PORT` |                     |                         |
        | `REPLICA_SET_NAME`  |                     |                         |



        All other types of alerts do not support matchers.
        """
        operator: pulumi.Input[str]
        value: pulumi.Input[str]
        """
        Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:
        - `PRIMARY`
        - `SECONDARY`
        - `STANDALONE`
        - `CONFIG`
        - `MONGOS`
        """
elif False:
    AlertConfigurationMatcherArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertConfigurationMatcherArgs:
    def __init__(__self__, *,
                 field_name: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] field_name: Name of the field in the target object to match on.
               
               | Host alerts         | Replica set alerts  |  Sharded cluster alerts |
               |:----------           |:-------------       |:------                 |
               | `TYPE_NAME`         | `REPLICA_SET_NAME`  | `CLUSTER_NAME`          |
               | `HOSTNAME`          | `SHARD_NAME`        | `SHARD_NAME`            |
               | `PORT`              | `CLUSTER_NAME`      |                         |
               | `HOSTNAME_AND_PORT` |                     |                         |
               | `REPLICA_SET_NAME`  |                     |                         |
               
               
               
               All other types of alerts do not support matchers.
        :param pulumi.Input[str] value: Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:
               - `PRIMARY`
               - `SECONDARY`
               - `STANDALONE`
               - `CONFIG`
               - `MONGOS`
        """
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> pulumi.Input[str]:
        """
        Name of the field in the target object to match on.

        | Host alerts         | Replica set alerts  |  Sharded cluster alerts |
        |:----------           |:-------------       |:------                 |
        | `TYPE_NAME`         | `REPLICA_SET_NAME`  | `CLUSTER_NAME`          |
        | `HOSTNAME`          | `SHARD_NAME`        | `SHARD_NAME`            |
        | `PORT`              | `CLUSTER_NAME`      |                         |
        | `HOSTNAME_AND_PORT` |                     |                         |
        | `REPLICA_SET_NAME`  |                     |                         |



        All other types of alerts do not support matchers.
        """
        return pulumi.get(self, "field_name")

    @field_name.setter
    def field_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "field_name", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:
        - `PRIMARY`
        - `SECONDARY`
        - `STANDALONE`
        - `CONFIG`
        - `MONGOS`
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AlertConfigurationMetricThresholdConfigArgsDict(TypedDict):
        metric_name: pulumi.Input[str]
        """
        Name of the metric to check. The full list being quite large, please refer to atlas docs [here for general metrics](https://docs.atlas.mongodb.com/reference/alert-host-metrics/#measurement-types) and [here for serverless metrics](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-create-config/#serverless-measurements)
        """
        mode: NotRequired[pulumi.Input[str]]
        """
        This must be set to AVERAGE. Atlas computes the current metric value as an average.
        """
        operator: NotRequired[pulumi.Input[str]]
        threshold: NotRequired[pulumi.Input[float]]
        units: NotRequired[pulumi.Input[str]]
elif False:
    AlertConfigurationMetricThresholdConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertConfigurationMetricThresholdConfigArgs:
    def __init__(__self__, *,
                 metric_name: pulumi.Input[str],
                 mode: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 threshold: Optional[pulumi.Input[float]] = None,
                 units: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metric_name: Name of the metric to check. The full list being quite large, please refer to atlas docs [here for general metrics](https://docs.atlas.mongodb.com/reference/alert-host-metrics/#measurement-types) and [here for serverless metrics](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-create-config/#serverless-measurements)
        :param pulumi.Input[str] mode: This must be set to AVERAGE. Atlas computes the current metric value as an average.
        """
        pulumi.set(__self__, "metric_name", metric_name)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if units is not None:
            pulumi.set(__self__, "units", units)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[str]:
        """
        Name of the metric to check. The full list being quite large, please refer to atlas docs [here for general metrics](https://docs.atlas.mongodb.com/reference/alert-host-metrics/#measurement-types) and [here for serverless metrics](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-create-config/#serverless-measurements)
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_name", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        This must be set to AVERAGE. Atlas computes the current metric value as an average.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter
    def units(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "units")

    @units.setter
    def units(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "units", value)


if not MYPY:
    class AlertConfigurationNotificationArgsDict(TypedDict):
        type_name: pulumi.Input[str]
        """
        Type of alert notification.
        Accepted values are:
        - `DATADOG`
        - `EMAIL`
        - `GROUP` (Project)
        - `OPS_GENIE`
        - `ORG`
        - `PAGER_DUTY`
        - `SLACK`
        - `SMS`
        - `TEAM`
        - `USER`
        - `VICTOR_OPS`
        - `WEBHOOK`
        - `MICROSOFT_TEAMS`
        """
        api_token: NotRequired[pulumi.Input[str]]
        """
        Slack API token. Required for the SLACK notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        """
        channel_name: NotRequired[pulumi.Input[str]]
        """
        Slack channel name. Required for the SLACK notifications type.
        """
        datadog_api_key: NotRequired[pulumi.Input[str]]
        """
        Datadog API Key. Found in the Datadog dashboard. Required for the DATADOG notifications type.
        """
        datadog_region: NotRequired[pulumi.Input[str]]
        """
        Region that indicates which API URL to use. See the `datadogRegion` field in the `notifications` request parameter of [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/v2/#tag/Alert-Configurations/operation/createAlertConfiguration) for more details. The default Datadog region is US.
        """
        delay_min: NotRequired[pulumi.Input[int]]
        """
        Number of minutes to wait after an alert condition is detected before sending out the first notification.
        """
        email_address: NotRequired[pulumi.Input[str]]
        """
        Email address to which alert notifications are sent. Required for the EMAIL notifications type.
        """
        email_enabled: NotRequired[pulumi.Input[bool]]
        """
        Flag indicating email notifications should be sent. This flag is only valid if `type_name` is set to `ORG`, `GROUP`, or `USER`.
        """
        integration_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the associated integration, the credentials of which to use for requests.
        """
        interval_min: NotRequired[pulumi.Input[int]]
        """
        Number of minutes to wait between successive notifications for unacknowledged alerts that are not resolved. The minimum value is 5. **NOTE** `PAGER_DUTY`, `VICTOR_OPS`, and `OPS_GENIE` notifications do not return this value. The notification interval must be configured and managed within each external service.
        """
        microsoft_teams_webhook_url: NotRequired[pulumi.Input[str]]
        """
        Microsoft Teams Webhook Uniform Resource Locator (URL) that MongoDB Cloud needs to send this notification via Microsoft Teams. Required if `type_name` is `MICROSOFT_TEAMS`. If the URL later becomes invalid, MongoDB Cloud sends an email to the project owners. If the key remains invalid, MongoDB Cloud removes it.
        """
        mobile_number: NotRequired[pulumi.Input[str]]
        """
        Mobile number to which alert notifications are sent. Required for the SMS notifications type.
        """
        notifier_id: NotRequired[pulumi.Input[str]]
        """
        The notifier ID is a system-generated unique identifier assigned to each notification method. This is needed when updating third-party notifications without requiring explicit authentication credentials.
        """
        ops_genie_api_key: NotRequired[pulumi.Input[str]]
        """
        Opsgenie API Key. Required for the `OPS_GENIE` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        """
        ops_genie_region: NotRequired[pulumi.Input[str]]
        """
        Region that indicates which API URL to use. Accepted regions are: `US` ,`EU`. The default Opsgenie region is US.
        """
        roles: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Optional. One or more roles that receive the configured alert. If you include this field, Atlas sends alerts only to users assigned the roles you specify in the array. If you omit this field, Atlas sends alerts to users assigned any role. This parameter is only valid if `type_name` is set to `ORG`, `GROUP`, or `USER`.
        Accepted values are:

        | Project roles                   | Organization roles  |
        |:----------                      |:-----------         |
        | `GROUP_CLUSTER_MANAGER`         | `ORG_OWNER`         |
        | `GROUP_DATA_ACCESS_ADMIN`       | `ORG_MEMBER`        |
        | `GROUP_DATA_ACCESS_READ_ONLY`   | `ORG_GROUP_CREATOR` |
        | `GROUP_DATA_ACCESS_READ_WRITE`  | `ORG_BILLING_ADMIN` |
        | `GROUP_OWNER`                   | `ORG_READ_ONLY`     |
        | `GROUP_READ_ONLY`               |                     |
        """
        service_key: NotRequired[pulumi.Input[str]]
        """
        PagerDuty service key. Required for the PAGER_DUTY notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        sms_enabled: NotRequired[pulumi.Input[bool]]
        """
        Flag indicating if text message notifications should be sent to this user's mobile phone. This flag is only valid if `type_name` is set to `ORG`, `GROUP`, or `USER`.
        """
        team_id: NotRequired[pulumi.Input[str]]
        """
        Unique identifier of a team.
        """
        team_name: NotRequired[pulumi.Input[str]]
        """
        Label for the team that receives this notification.
        """
        username: NotRequired[pulumi.Input[str]]
        """
        Name of the Atlas user to which to send notifications. Only a user in the project that owns the alert configuration is allowed here. Required for the `USER` notifications type.
        """
        victor_ops_api_key: NotRequired[pulumi.Input[str]]
        """
        VictorOps API key. Required for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        victor_ops_routing_key: NotRequired[pulumi.Input[str]]
        """
        VictorOps routing key. Optional for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        webhook_secret: NotRequired[pulumi.Input[str]]
        """
        Optional authentication secret for the `WEBHOOK` notifications type.
        """
        webhook_url: NotRequired[pulumi.Input[str]]
        """
        Target URL  for the `WEBHOOK` notifications type.
        """
elif False:
    AlertConfigurationNotificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertConfigurationNotificationArgs:
    def __init__(__self__, *,
                 type_name: pulumi.Input[str],
                 api_token: Optional[pulumi.Input[str]] = None,
                 channel_name: Optional[pulumi.Input[str]] = None,
                 datadog_api_key: Optional[pulumi.Input[str]] = None,
                 datadog_region: Optional[pulumi.Input[str]] = None,
                 delay_min: Optional[pulumi.Input[int]] = None,
                 email_address: Optional[pulumi.Input[str]] = None,
                 email_enabled: Optional[pulumi.Input[bool]] = None,
                 integration_id: Optional[pulumi.Input[str]] = None,
                 interval_min: Optional[pulumi.Input[int]] = None,
                 microsoft_teams_webhook_url: Optional[pulumi.Input[str]] = None,
                 mobile_number: Optional[pulumi.Input[str]] = None,
                 notifier_id: Optional[pulumi.Input[str]] = None,
                 ops_genie_api_key: Optional[pulumi.Input[str]] = None,
                 ops_genie_region: Optional[pulumi.Input[str]] = None,
                 roles: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 service_key: Optional[pulumi.Input[str]] = None,
                 sms_enabled: Optional[pulumi.Input[bool]] = None,
                 team_id: Optional[pulumi.Input[str]] = None,
                 team_name: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None,
                 victor_ops_api_key: Optional[pulumi.Input[str]] = None,
                 victor_ops_routing_key: Optional[pulumi.Input[str]] = None,
                 webhook_secret: Optional[pulumi.Input[str]] = None,
                 webhook_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type_name: Type of alert notification.
               Accepted values are:
               - `DATADOG`
               - `EMAIL`
               - `GROUP` (Project)
               - `OPS_GENIE`
               - `ORG`
               - `PAGER_DUTY`
               - `SLACK`
               - `SMS`
               - `TEAM`
               - `USER`
               - `VICTOR_OPS`
               - `WEBHOOK`
               - `MICROSOFT_TEAMS`
        :param pulumi.Input[str] api_token: Slack API token. Required for the SLACK notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        :param pulumi.Input[str] channel_name: Slack channel name. Required for the SLACK notifications type.
        :param pulumi.Input[str] datadog_api_key: Datadog API Key. Found in the Datadog dashboard. Required for the DATADOG notifications type.
        :param pulumi.Input[str] datadog_region: Region that indicates which API URL to use. See the `datadogRegion` field in the `notifications` request parameter of [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/v2/#tag/Alert-Configurations/operation/createAlertConfiguration) for more details. The default Datadog region is US.
        :param pulumi.Input[int] delay_min: Number of minutes to wait after an alert condition is detected before sending out the first notification.
        :param pulumi.Input[str] email_address: Email address to which alert notifications are sent. Required for the EMAIL notifications type.
        :param pulumi.Input[bool] email_enabled: Flag indicating email notifications should be sent. This flag is only valid if `type_name` is set to `ORG`, `GROUP`, or `USER`.
        :param pulumi.Input[str] integration_id: The ID of the associated integration, the credentials of which to use for requests.
        :param pulumi.Input[int] interval_min: Number of minutes to wait between successive notifications for unacknowledged alerts that are not resolved. The minimum value is 5. **NOTE** `PAGER_DUTY`, `VICTOR_OPS`, and `OPS_GENIE` notifications do not return this value. The notification interval must be configured and managed within each external service.
        :param pulumi.Input[str] microsoft_teams_webhook_url: Microsoft Teams Webhook Uniform Resource Locator (URL) that MongoDB Cloud needs to send this notification via Microsoft Teams. Required if `type_name` is `MICROSOFT_TEAMS`. If the URL later becomes invalid, MongoDB Cloud sends an email to the project owners. If the key remains invalid, MongoDB Cloud removes it.
        :param pulumi.Input[str] mobile_number: Mobile number to which alert notifications are sent. Required for the SMS notifications type.
        :param pulumi.Input[str] notifier_id: The notifier ID is a system-generated unique identifier assigned to each notification method. This is needed when updating third-party notifications without requiring explicit authentication credentials.
        :param pulumi.Input[str] ops_genie_api_key: Opsgenie API Key. Required for the `OPS_GENIE` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        :param pulumi.Input[str] ops_genie_region: Region that indicates which API URL to use. Accepted regions are: `US` ,`EU`. The default Opsgenie region is US.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] roles: Optional. One or more roles that receive the configured alert. If you include this field, Atlas sends alerts only to users assigned the roles you specify in the array. If you omit this field, Atlas sends alerts to users assigned any role. This parameter is only valid if `type_name` is set to `ORG`, `GROUP`, or `USER`.
               Accepted values are:
               
               | Project roles                   | Organization roles  |
               |:----------                      |:-----------         |
               | `GROUP_CLUSTER_MANAGER`         | `ORG_OWNER`         |
               | `GROUP_DATA_ACCESS_ADMIN`       | `ORG_MEMBER`        |
               | `GROUP_DATA_ACCESS_READ_ONLY`   | `ORG_GROUP_CREATOR` |
               | `GROUP_DATA_ACCESS_READ_WRITE`  | `ORG_BILLING_ADMIN` |
               | `GROUP_OWNER`                   | `ORG_READ_ONLY`     |
               | `GROUP_READ_ONLY`               |                     |
        :param pulumi.Input[str] service_key: PagerDuty service key. Required for the PAGER_DUTY notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        :param pulumi.Input[bool] sms_enabled: Flag indicating if text message notifications should be sent to this user's mobile phone. This flag is only valid if `type_name` is set to `ORG`, `GROUP`, or `USER`.
        :param pulumi.Input[str] team_id: Unique identifier of a team.
        :param pulumi.Input[str] team_name: Label for the team that receives this notification.
        :param pulumi.Input[str] username: Name of the Atlas user to which to send notifications. Only a user in the project that owns the alert configuration is allowed here. Required for the `USER` notifications type.
        :param pulumi.Input[str] victor_ops_api_key: VictorOps API key. Required for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        :param pulumi.Input[str] victor_ops_routing_key: VictorOps routing key. Optional for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        :param pulumi.Input[str] webhook_secret: Optional authentication secret for the `WEBHOOK` notifications type.
        :param pulumi.Input[str] webhook_url: Target URL  for the `WEBHOOK` notifications type.
        """
        pulumi.set(__self__, "type_name", type_name)
        if api_token is not None:
            pulumi.set(__self__, "api_token", api_token)
        if channel_name is not None:
            pulumi.set(__self__, "channel_name", channel_name)
        if datadog_api_key is not None:
            pulumi.set(__self__, "datadog_api_key", datadog_api_key)
        if datadog_region is not None:
            pulumi.set(__self__, "datadog_region", datadog_region)
        if delay_min is not None:
            pulumi.set(__self__, "delay_min", delay_min)
        if email_address is not None:
            pulumi.set(__self__, "email_address", email_address)
        if email_enabled is not None:
            pulumi.set(__self__, "email_enabled", email_enabled)
        if integration_id is not None:
            pulumi.set(__self__, "integration_id", integration_id)
        if interval_min is not None:
            pulumi.set(__self__, "interval_min", interval_min)
        if microsoft_teams_webhook_url is not None:
            pulumi.set(__self__, "microsoft_teams_webhook_url", microsoft_teams_webhook_url)
        if mobile_number is not None:
            pulumi.set(__self__, "mobile_number", mobile_number)
        if notifier_id is not None:
            pulumi.set(__self__, "notifier_id", notifier_id)
        if ops_genie_api_key is not None:
            pulumi.set(__self__, "ops_genie_api_key", ops_genie_api_key)
        if ops_genie_region is not None:
            pulumi.set(__self__, "ops_genie_region", ops_genie_region)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)
        if service_key is not None:
            pulumi.set(__self__, "service_key", service_key)
        if sms_enabled is not None:
            pulumi.set(__self__, "sms_enabled", sms_enabled)
        if team_id is not None:
            pulumi.set(__self__, "team_id", team_id)
        if team_name is not None:
            pulumi.set(__self__, "team_name", team_name)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if victor_ops_api_key is not None:
            pulumi.set(__self__, "victor_ops_api_key", victor_ops_api_key)
        if victor_ops_routing_key is not None:
            pulumi.set(__self__, "victor_ops_routing_key", victor_ops_routing_key)
        if webhook_secret is not None:
            pulumi.set(__self__, "webhook_secret", webhook_secret)
        if webhook_url is not None:
            pulumi.set(__self__, "webhook_url", webhook_url)

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> pulumi.Input[str]:
        """
        Type of alert notification.
        Accepted values are:
        - `DATADOG`
        - `EMAIL`
        - `GROUP` (Project)
        - `OPS_GENIE`
        - `ORG`
        - `PAGER_DUTY`
        - `SLACK`
        - `SMS`
        - `TEAM`
        - `USER`
        - `VICTOR_OPS`
        - `WEBHOOK`
        - `MICROSOFT_TEAMS`
        """
        return pulumi.get(self, "type_name")

    @type_name.setter
    def type_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "type_name", value)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> Optional[pulumi.Input[str]]:
        """
        Slack API token. Required for the SLACK notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        """
        return pulumi.get(self, "api_token")

    @api_token.setter
    def api_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_token", value)

    @property
    @pulumi.getter(name="channelName")
    def channel_name(self) -> Optional[pulumi.Input[str]]:
        """
        Slack channel name. Required for the SLACK notifications type.
        """
        return pulumi.get(self, "channel_name")

    @channel_name.setter
    def channel_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "channel_name", value)

    @property
    @pulumi.getter(name="datadogApiKey")
    def datadog_api_key(self) -> Optional[pulumi.Input[str]]:
        """
        Datadog API Key. Found in the Datadog dashboard. Required for the DATADOG notifications type.
        """
        return pulumi.get(self, "datadog_api_key")

    @datadog_api_key.setter
    def datadog_api_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datadog_api_key", value)

    @property
    @pulumi.getter(name="datadogRegion")
    def datadog_region(self) -> Optional[pulumi.Input[str]]:
        """
        Region that indicates which API URL to use. See the `datadogRegion` field in the `notifications` request parameter of [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/v2/#tag/Alert-Configurations/operation/createAlertConfiguration) for more details. The default Datadog region is US.
        """
        return pulumi.get(self, "datadog_region")

    @datadog_region.setter
    def datadog_region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datadog_region", value)

    @property
    @pulumi.getter(name="delayMin")
    def delay_min(self) -> Optional[pulumi.Input[int]]:
        """
        Number of minutes to wait after an alert condition is detected before sending out the first notification.
        """
        return pulumi.get(self, "delay_min")

    @delay_min.setter
    def delay_min(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "delay_min", value)

    @property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> Optional[pulumi.Input[str]]:
        """
        Email address to which alert notifications are sent. Required for the EMAIL notifications type.
        """
        return pulumi.get(self, "email_address")

    @email_address.setter
    def email_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_address", value)

    @property
    @pulumi.getter(name="emailEnabled")
    def email_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag indicating email notifications should be sent. This flag is only valid if `type_name` is set to `ORG`, `GROUP`, or `USER`.
        """
        return pulumi.get(self, "email_enabled")

    @email_enabled.setter
    def email_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "email_enabled", value)

    @property
    @pulumi.getter(name="integrationId")
    def integration_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the associated integration, the credentials of which to use for requests.
        """
        return pulumi.get(self, "integration_id")

    @integration_id.setter
    def integration_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "integration_id", value)

    @property
    @pulumi.getter(name="intervalMin")
    def interval_min(self) -> Optional[pulumi.Input[int]]:
        """
        Number of minutes to wait between successive notifications for unacknowledged alerts that are not resolved. The minimum value is 5. **NOTE** `PAGER_DUTY`, `VICTOR_OPS`, and `OPS_GENIE` notifications do not return this value. The notification interval must be configured and managed within each external service.
        """
        return pulumi.get(self, "interval_min")

    @interval_min.setter
    def interval_min(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval_min", value)

    @property
    @pulumi.getter(name="microsoftTeamsWebhookUrl")
    def microsoft_teams_webhook_url(self) -> Optional[pulumi.Input[str]]:
        """
        Microsoft Teams Webhook Uniform Resource Locator (URL) that MongoDB Cloud needs to send this notification via Microsoft Teams. Required if `type_name` is `MICROSOFT_TEAMS`. If the URL later becomes invalid, MongoDB Cloud sends an email to the project owners. If the key remains invalid, MongoDB Cloud removes it.
        """
        return pulumi.get(self, "microsoft_teams_webhook_url")

    @microsoft_teams_webhook_url.setter
    def microsoft_teams_webhook_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "microsoft_teams_webhook_url", value)

    @property
    @pulumi.getter(name="mobileNumber")
    def mobile_number(self) -> Optional[pulumi.Input[str]]:
        """
        Mobile number to which alert notifications are sent. Required for the SMS notifications type.
        """
        return pulumi.get(self, "mobile_number")

    @mobile_number.setter
    def mobile_number(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mobile_number", value)

    @property
    @pulumi.getter(name="notifierId")
    def notifier_id(self) -> Optional[pulumi.Input[str]]:
        """
        The notifier ID is a system-generated unique identifier assigned to each notification method. This is needed when updating third-party notifications without requiring explicit authentication credentials.
        """
        return pulumi.get(self, "notifier_id")

    @notifier_id.setter
    def notifier_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "notifier_id", value)

    @property
    @pulumi.getter(name="opsGenieApiKey")
    def ops_genie_api_key(self) -> Optional[pulumi.Input[str]]:
        """
        Opsgenie API Key. Required for the `OPS_GENIE` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        """
        return pulumi.get(self, "ops_genie_api_key")

    @ops_genie_api_key.setter
    def ops_genie_api_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ops_genie_api_key", value)

    @property
    @pulumi.getter(name="opsGenieRegion")
    def ops_genie_region(self) -> Optional[pulumi.Input[str]]:
        """
        Region that indicates which API URL to use. Accepted regions are: `US` ,`EU`. The default Opsgenie region is US.
        """
        return pulumi.get(self, "ops_genie_region")

    @ops_genie_region.setter
    def ops_genie_region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ops_genie_region", value)

    @property
    @pulumi.getter
    def roles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Optional. One or more roles that receive the configured alert. If you include this field, Atlas sends alerts only to users assigned the roles you specify in the array. If you omit this field, Atlas sends alerts to users assigned any role. This parameter is only valid if `type_name` is set to `ORG`, `GROUP`, or `USER`.
        Accepted values are:

        | Project roles                   | Organization roles  |
        |:----------                      |:-----------         |
        | `GROUP_CLUSTER_MANAGER`         | `ORG_OWNER`         |
        | `GROUP_DATA_ACCESS_ADMIN`       | `ORG_MEMBER`        |
        | `GROUP_DATA_ACCESS_READ_ONLY`   | `ORG_GROUP_CREATOR` |
        | `GROUP_DATA_ACCESS_READ_WRITE`  | `ORG_BILLING_ADMIN` |
        | `GROUP_OWNER`                   | `ORG_READ_ONLY`     |
        | `GROUP_READ_ONLY`               |                     |
        """
        return pulumi.get(self, "roles")

    @roles.setter
    def roles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "roles", value)

    @property
    @pulumi.getter(name="serviceKey")
    def service_key(self) -> Optional[pulumi.Input[str]]:
        """
        PagerDuty service key. Required for the PAGER_DUTY notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        return pulumi.get(self, "service_key")

    @service_key.setter
    def service_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_key", value)

    @property
    @pulumi.getter(name="smsEnabled")
    def sms_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag indicating if text message notifications should be sent to this user's mobile phone. This flag is only valid if `type_name` is set to `ORG`, `GROUP`, or `USER`.
        """
        return pulumi.get(self, "sms_enabled")

    @sms_enabled.setter
    def sms_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sms_enabled", value)

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier of a team.
        """
        return pulumi.get(self, "team_id")

    @team_id.setter
    def team_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "team_id", value)

    @property
    @pulumi.getter(name="teamName")
    def team_name(self) -> Optional[pulumi.Input[str]]:
        """
        Label for the team that receives this notification.
        """
        return pulumi.get(self, "team_name")

    @team_name.setter
    def team_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "team_name", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Atlas user to which to send notifications. Only a user in the project that owns the alert configuration is allowed here. Required for the `USER` notifications type.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="victorOpsApiKey")
    def victor_ops_api_key(self) -> Optional[pulumi.Input[str]]:
        """
        VictorOps API key. Required for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        return pulumi.get(self, "victor_ops_api_key")

    @victor_ops_api_key.setter
    def victor_ops_api_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "victor_ops_api_key", value)

    @property
    @pulumi.getter(name="victorOpsRoutingKey")
    def victor_ops_routing_key(self) -> Optional[pulumi.Input[str]]:
        """
        VictorOps routing key. Optional for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        return pulumi.get(self, "victor_ops_routing_key")

    @victor_ops_routing_key.setter
    def victor_ops_routing_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "victor_ops_routing_key", value)

    @property
    @pulumi.getter(name="webhookSecret")
    def webhook_secret(self) -> Optional[pulumi.Input[str]]:
        """
        Optional authentication secret for the `WEBHOOK` notifications type.
        """
        return pulumi.get(self, "webhook_secret")

    @webhook_secret.setter
    def webhook_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "webhook_secret", value)

    @property
    @pulumi.getter(name="webhookUrl")
    def webhook_url(self) -> Optional[pulumi.Input[str]]:
        """
        Target URL  for the `WEBHOOK` notifications type.
        """
        return pulumi.get(self, "webhook_url")

    @webhook_url.setter
    def webhook_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "webhook_url", value)


if not MYPY:
    class AlertConfigurationThresholdConfigArgsDict(TypedDict):
        operator: NotRequired[pulumi.Input[str]]
        threshold: NotRequired[pulumi.Input[float]]
        units: NotRequired[pulumi.Input[str]]
elif False:
    AlertConfigurationThresholdConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertConfigurationThresholdConfigArgs:
    def __init__(__self__, *,
                 operator: Optional[pulumi.Input[str]] = None,
                 threshold: Optional[pulumi.Input[float]] = None,
                 units: Optional[pulumi.Input[str]] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if units is not None:
            pulumi.set(__self__, "units", units)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter
    def units(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "units")

    @units.setter
    def units(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "units", value)


if not MYPY:
    class BackupCompliancePolicyOnDemandPolicyItemArgsDict(TypedDict):
        frequency_interval: pulumi.Input[int]
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        retention_unit: pulumi.Input[str]
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        retention_value: pulumi.Input[int]
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        frequency_type: NotRequired[pulumi.Input[str]]
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Unique identifier of the backup policy item.
        """
elif False:
    BackupCompliancePolicyOnDemandPolicyItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackupCompliancePolicyOnDemandPolicyItemArgs:
    def __init__(__self__, *,
                 frequency_interval: pulumi.Input[int],
                 retention_unit: pulumi.Input[str],
                 retention_value: pulumi.Input[int],
                 frequency_type: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        :param pulumi.Input[str] retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param pulumi.Input[int] retention_value: Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        :param pulumi.Input[str] frequency_type: Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param pulumi.Input[str] id: Unique identifier of the backup policy item.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> pulumi.Input[int]:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @frequency_interval.setter
    def frequency_interval(self, value: pulumi.Input[int]):
        pulumi.set(self, "frequency_interval", value)

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> pulumi.Input[str]:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @retention_unit.setter
    def retention_unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "retention_unit", value)

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> pulumi.Input[int]:
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        return pulumi.get(self, "retention_value")

    @retention_value.setter
    def retention_value(self, value: pulumi.Input[int]):
        pulumi.set(self, "retention_value", value)

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[pulumi.Input[str]]:
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @frequency_type.setter
    def frequency_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "frequency_type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class BackupCompliancePolicyPolicyItemDailyArgsDict(TypedDict):
        frequency_interval: pulumi.Input[int]
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        retention_unit: pulumi.Input[str]
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        retention_value: pulumi.Input[int]
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        frequency_type: NotRequired[pulumi.Input[str]]
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Unique identifier of the backup policy item.
        """
elif False:
    BackupCompliancePolicyPolicyItemDailyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackupCompliancePolicyPolicyItemDailyArgs:
    def __init__(__self__, *,
                 frequency_interval: pulumi.Input[int],
                 retention_unit: pulumi.Input[str],
                 retention_value: pulumi.Input[int],
                 frequency_type: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        :param pulumi.Input[str] retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param pulumi.Input[int] retention_value: Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        :param pulumi.Input[str] frequency_type: Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param pulumi.Input[str] id: Unique identifier of the backup policy item.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> pulumi.Input[int]:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @frequency_interval.setter
    def frequency_interval(self, value: pulumi.Input[int]):
        pulumi.set(self, "frequency_interval", value)

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> pulumi.Input[str]:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @retention_unit.setter
    def retention_unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "retention_unit", value)

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> pulumi.Input[int]:
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        return pulumi.get(self, "retention_value")

    @retention_value.setter
    def retention_value(self, value: pulumi.Input[int]):
        pulumi.set(self, "retention_value", value)

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[pulumi.Input[str]]:
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @frequency_type.setter
    def frequency_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "frequency_type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class BackupCompliancePolicyPolicyItemHourlyArgsDict(TypedDict):
        frequency_interval: pulumi.Input[int]
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        retention_unit: pulumi.Input[str]
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        retention_value: pulumi.Input[int]
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        frequency_type: NotRequired[pulumi.Input[str]]
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Unique identifier of the backup policy item.
        """
elif False:
    BackupCompliancePolicyPolicyItemHourlyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackupCompliancePolicyPolicyItemHourlyArgs:
    def __init__(__self__, *,
                 frequency_interval: pulumi.Input[int],
                 retention_unit: pulumi.Input[str],
                 retention_value: pulumi.Input[int],
                 frequency_type: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        :param pulumi.Input[str] retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param pulumi.Input[int] retention_value: Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        :param pulumi.Input[str] frequency_type: Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param pulumi.Input[str] id: Unique identifier of the backup policy item.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> pulumi.Input[int]:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @frequency_interval.setter
    def frequency_interval(self, value: pulumi.Input[int]):
        pulumi.set(self, "frequency_interval", value)

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> pulumi.Input[str]:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @retention_unit.setter
    def retention_unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "retention_unit", value)

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> pulumi.Input[int]:
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        return pulumi.get(self, "retention_value")

    @retention_value.setter
    def retention_value(self, value: pulumi.Input[int]):
        pulumi.set(self, "retention_value", value)

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[pulumi.Input[str]]:
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @frequency_type.setter
    def frequency_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "frequency_type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class BackupCompliancePolicyPolicyItemMonthlyArgsDict(TypedDict):
        frequency_interval: pulumi.Input[int]
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        retention_unit: pulumi.Input[str]
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        retention_value: pulumi.Input[int]
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        frequency_type: NotRequired[pulumi.Input[str]]
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Unique identifier of the backup policy item.
        """
elif False:
    BackupCompliancePolicyPolicyItemMonthlyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackupCompliancePolicyPolicyItemMonthlyArgs:
    def __init__(__self__, *,
                 frequency_interval: pulumi.Input[int],
                 retention_unit: pulumi.Input[str],
                 retention_value: pulumi.Input[int],
                 frequency_type: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        :param pulumi.Input[str] retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param pulumi.Input[int] retention_value: Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        :param pulumi.Input[str] frequency_type: Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param pulumi.Input[str] id: Unique identifier of the backup policy item.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> pulumi.Input[int]:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @frequency_interval.setter
    def frequency_interval(self, value: pulumi.Input[int]):
        pulumi.set(self, "frequency_interval", value)

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> pulumi.Input[str]:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @retention_unit.setter
    def retention_unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "retention_unit", value)

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> pulumi.Input[int]:
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        return pulumi.get(self, "retention_value")

    @retention_value.setter
    def retention_value(self, value: pulumi.Input[int]):
        pulumi.set(self, "retention_value", value)

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[pulumi.Input[str]]:
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @frequency_type.setter
    def frequency_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "frequency_type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class BackupCompliancePolicyPolicyItemWeeklyArgsDict(TypedDict):
        frequency_interval: pulumi.Input[int]
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        retention_unit: pulumi.Input[str]
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        retention_value: pulumi.Input[int]
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        frequency_type: NotRequired[pulumi.Input[str]]
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Unique identifier of the backup policy item.
        """
elif False:
    BackupCompliancePolicyPolicyItemWeeklyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackupCompliancePolicyPolicyItemWeeklyArgs:
    def __init__(__self__, *,
                 frequency_interval: pulumi.Input[int],
                 retention_unit: pulumi.Input[str],
                 retention_value: pulumi.Input[int],
                 frequency_type: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        :param pulumi.Input[str] retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param pulumi.Input[int] retention_value: Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        :param pulumi.Input[str] frequency_type: Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param pulumi.Input[str] id: Unique identifier of the backup policy item.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> pulumi.Input[int]:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @frequency_interval.setter
    def frequency_interval(self, value: pulumi.Input[int]):
        pulumi.set(self, "frequency_interval", value)

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> pulumi.Input[str]:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @retention_unit.setter
    def retention_unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "retention_unit", value)

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> pulumi.Input[int]:
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        return pulumi.get(self, "retention_value")

    @retention_value.setter
    def retention_value(self, value: pulumi.Input[int]):
        pulumi.set(self, "retention_value", value)

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[pulumi.Input[str]]:
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @frequency_type.setter
    def frequency_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "frequency_type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class BackupCompliancePolicyPolicyItemYearlyArgsDict(TypedDict):
        frequency_interval: pulumi.Input[int]
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        retention_unit: pulumi.Input[str]
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        retention_value: pulumi.Input[int]
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        frequency_type: NotRequired[pulumi.Input[str]]
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Unique identifier of the backup policy item.
        """
elif False:
    BackupCompliancePolicyPolicyItemYearlyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackupCompliancePolicyPolicyItemYearlyArgs:
    def __init__(__self__, *,
                 frequency_interval: pulumi.Input[int],
                 retention_unit: pulumi.Input[str],
                 retention_value: pulumi.Input[int],
                 frequency_type: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        :param pulumi.Input[str] retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param pulumi.Input[int] retention_value: Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        :param pulumi.Input[str] frequency_type: Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param pulumi.Input[str] id: Unique identifier of the backup policy item.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> pulumi.Input[int]:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @frequency_interval.setter
    def frequency_interval(self, value: pulumi.Input[int]):
        pulumi.set(self, "frequency_interval", value)

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> pulumi.Input[str]:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @retention_unit.setter
    def retention_unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "retention_unit", value)

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> pulumi.Input[int]:
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        return pulumi.get(self, "retention_value")

    @retention_value.setter
    def retention_value(self, value: pulumi.Input[int]):
        pulumi.set(self, "retention_value", value)

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[pulumi.Input[str]]:
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @frequency_type.setter
    def frequency_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "frequency_type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class CloudBackupScheduleCopySettingArgsDict(TypedDict):
        cloud_provider: NotRequired[pulumi.Input[str]]
        """
        Human-readable label that identifies the cloud provider that stores the snapshot copy. i.e. "AWS" "AZURE" "GCP"
        """
        frequencies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List that describes which types of snapshots to copy. i.e. "HOURLY" "DAILY" "WEEKLY" "MONTHLY" "ON_DEMAND"
        """
        region_name: NotRequired[pulumi.Input[str]]
        """
        Target region to copy snapshots belonging to replicationSpecId to. Please supply the 'Atlas Region' which can be found under https://www.mongodb.com/docs/atlas/reference/cloud-providers/ 'regions' link
        """
        replication_spec_id: NotRequired[pulumi.Input[str]]
        """
        Unique 24-hexadecimal digit string that identifies the replication object for a zone in a cluster. For global clusters, there can be multiple zones to choose from. For sharded clusters and replica set clusters, there is only one zone in the cluster. To find the Replication Spec Id, consult the replicationSpecs array returned from [Return One Multi-Cloud Cluster in One Project](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/v2/#tag/Clusters/operation/getCluster). **(DEPRECATED)** Use `zone_id` instead. To learn more, see the 1.18.0 upgrade guide.
        """
        should_copy_oplogs: NotRequired[pulumi.Input[bool]]
        """
        Flag that indicates whether to copy the oplogs to the target region. You can use the oplogs to perform point-in-time restores.
        """
        zone_id: NotRequired[pulumi.Input[str]]
        """
        Unique 24-hexadecimal digit string that identifies the zone in a cluster. For global clusters, there can be multiple zones to choose from. For sharded clusters and replica set clusters, there is only one zone in the cluster. To find appropriate value for `zone_id`, do a GET request to Return One Cluster from One Project and consult the replicationSpecs array Return One Cluster From One Project. Alternately, use `AdvancedCluster` data source or resource and reference `replication_specs.#.zone_id`.
        """
elif False:
    CloudBackupScheduleCopySettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudBackupScheduleCopySettingArgs:
    def __init__(__self__, *,
                 cloud_provider: Optional[pulumi.Input[str]] = None,
                 frequencies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 region_name: Optional[pulumi.Input[str]] = None,
                 replication_spec_id: Optional[pulumi.Input[str]] = None,
                 should_copy_oplogs: Optional[pulumi.Input[bool]] = None,
                 zone_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cloud_provider: Human-readable label that identifies the cloud provider that stores the snapshot copy. i.e. "AWS" "AZURE" "GCP"
        :param pulumi.Input[Sequence[pulumi.Input[str]]] frequencies: List that describes which types of snapshots to copy. i.e. "HOURLY" "DAILY" "WEEKLY" "MONTHLY" "ON_DEMAND"
        :param pulumi.Input[str] region_name: Target region to copy snapshots belonging to replicationSpecId to. Please supply the 'Atlas Region' which can be found under https://www.mongodb.com/docs/atlas/reference/cloud-providers/ 'regions' link
        :param pulumi.Input[str] replication_spec_id: Unique 24-hexadecimal digit string that identifies the replication object for a zone in a cluster. For global clusters, there can be multiple zones to choose from. For sharded clusters and replica set clusters, there is only one zone in the cluster. To find the Replication Spec Id, consult the replicationSpecs array returned from [Return One Multi-Cloud Cluster in One Project](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/v2/#tag/Clusters/operation/getCluster). **(DEPRECATED)** Use `zone_id` instead. To learn more, see the 1.18.0 upgrade guide.
        :param pulumi.Input[bool] should_copy_oplogs: Flag that indicates whether to copy the oplogs to the target region. You can use the oplogs to perform point-in-time restores.
        :param pulumi.Input[str] zone_id: Unique 24-hexadecimal digit string that identifies the zone in a cluster. For global clusters, there can be multiple zones to choose from. For sharded clusters and replica set clusters, there is only one zone in the cluster. To find appropriate value for `zone_id`, do a GET request to Return One Cluster from One Project and consult the replicationSpecs array Return One Cluster From One Project. Alternately, use `AdvancedCluster` data source or resource and reference `replication_specs.#.zone_id`.
        """
        if cloud_provider is not None:
            pulumi.set(__self__, "cloud_provider", cloud_provider)
        if frequencies is not None:
            pulumi.set(__self__, "frequencies", frequencies)
        if region_name is not None:
            pulumi.set(__self__, "region_name", region_name)
        if replication_spec_id is not None:
            warnings.warn("""This parameter is deprecated. Please transition to `copy_settings.#.zone_id`. To learn more, see our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown""", DeprecationWarning)
            pulumi.log.warn("""replication_spec_id is deprecated: This parameter is deprecated. Please transition to `copy_settings.#.zone_id`. To learn more, see our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown""")
        if replication_spec_id is not None:
            pulumi.set(__self__, "replication_spec_id", replication_spec_id)
        if should_copy_oplogs is not None:
            pulumi.set(__self__, "should_copy_oplogs", should_copy_oplogs)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> Optional[pulumi.Input[str]]:
        """
        Human-readable label that identifies the cloud provider that stores the snapshot copy. i.e. "AWS" "AZURE" "GCP"
        """
        return pulumi.get(self, "cloud_provider")

    @cloud_provider.setter
    def cloud_provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_provider", value)

    @property
    @pulumi.getter
    def frequencies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List that describes which types of snapshots to copy. i.e. "HOURLY" "DAILY" "WEEKLY" "MONTHLY" "ON_DEMAND"
        """
        return pulumi.get(self, "frequencies")

    @frequencies.setter
    def frequencies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "frequencies", value)

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> Optional[pulumi.Input[str]]:
        """
        Target region to copy snapshots belonging to replicationSpecId to. Please supply the 'Atlas Region' which can be found under https://www.mongodb.com/docs/atlas/reference/cloud-providers/ 'regions' link
        """
        return pulumi.get(self, "region_name")

    @region_name.setter
    def region_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region_name", value)

    @property
    @pulumi.getter(name="replicationSpecId")
    @_utilities.deprecated("""This parameter is deprecated. Please transition to `copy_settings.#.zone_id`. To learn more, see our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown""")
    def replication_spec_id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique 24-hexadecimal digit string that identifies the replication object for a zone in a cluster. For global clusters, there can be multiple zones to choose from. For sharded clusters and replica set clusters, there is only one zone in the cluster. To find the Replication Spec Id, consult the replicationSpecs array returned from [Return One Multi-Cloud Cluster in One Project](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/v2/#tag/Clusters/operation/getCluster). **(DEPRECATED)** Use `zone_id` instead. To learn more, see the 1.18.0 upgrade guide.
        """
        return pulumi.get(self, "replication_spec_id")

    @replication_spec_id.setter
    def replication_spec_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replication_spec_id", value)

    @property
    @pulumi.getter(name="shouldCopyOplogs")
    def should_copy_oplogs(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag that indicates whether to copy the oplogs to the target region. You can use the oplogs to perform point-in-time restores.
        """
        return pulumi.get(self, "should_copy_oplogs")

    @should_copy_oplogs.setter
    def should_copy_oplogs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_copy_oplogs", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique 24-hexadecimal digit string that identifies the zone in a cluster. For global clusters, there can be multiple zones to choose from. For sharded clusters and replica set clusters, there is only one zone in the cluster. To find appropriate value for `zone_id`, do a GET request to Return One Cluster from One Project and consult the replicationSpecs array Return One Cluster From One Project. Alternately, use `AdvancedCluster` data source or resource and reference `replication_specs.#.zone_id`.
        """
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone_id", value)


if not MYPY:
    class CloudBackupScheduleExportArgsDict(TypedDict):
        export_bucket_id: NotRequired[pulumi.Input[str]]
        """
        Unique identifier of the CloudBackupSnapshotExportBucket export_bucket_id value.
        """
        frequency_type: NotRequired[pulumi.Input[str]]
        """
        Frequency associated with the export snapshot item.
        """
elif False:
    CloudBackupScheduleExportArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudBackupScheduleExportArgs:
    def __init__(__self__, *,
                 export_bucket_id: Optional[pulumi.Input[str]] = None,
                 frequency_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] export_bucket_id: Unique identifier of the CloudBackupSnapshotExportBucket export_bucket_id value.
        :param pulumi.Input[str] frequency_type: Frequency associated with the export snapshot item.
        """
        if export_bucket_id is not None:
            pulumi.set(__self__, "export_bucket_id", export_bucket_id)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)

    @property
    @pulumi.getter(name="exportBucketId")
    def export_bucket_id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier of the CloudBackupSnapshotExportBucket export_bucket_id value.
        """
        return pulumi.get(self, "export_bucket_id")

    @export_bucket_id.setter
    def export_bucket_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "export_bucket_id", value)

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[pulumi.Input[str]]:
        """
        Frequency associated with the export snapshot item.
        """
        return pulumi.get(self, "frequency_type")

    @frequency_type.setter
    def frequency_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "frequency_type", value)


if not MYPY:
    class CloudBackupSchedulePolicyItemDailyArgsDict(TypedDict):
        frequency_interval: pulumi.Input[int]
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (daily in this case). The only supported value for daily policies is `1` day.
        """
        retention_unit: pulumi.Input[str]
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        retention_value: pulumi.Input[int]
        """
        Value to associate with `retention_unit`.  Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the hourly policy item specifies a retention of two days, the daily retention policy must specify two days or greater.
        """
        frequency_type: NotRequired[pulumi.Input[str]]
        """
        Frequency associated with the backup policy item. For daily policies, the frequency type is defined as `daily`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Unique identifier of the backup policy item.
        """
elif False:
    CloudBackupSchedulePolicyItemDailyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudBackupSchedulePolicyItemDailyArgs:
    def __init__(__self__, *,
                 frequency_interval: pulumi.Input[int],
                 retention_unit: pulumi.Input[str],
                 retention_value: pulumi.Input[int],
                 frequency_type: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (daily in this case). The only supported value for daily policies is `1` day.
        :param pulumi.Input[str] retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param pulumi.Input[int] retention_value: Value to associate with `retention_unit`.  Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the hourly policy item specifies a retention of two days, the daily retention policy must specify two days or greater.
        :param pulumi.Input[str] frequency_type: Frequency associated with the backup policy item. For daily policies, the frequency type is defined as `daily`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param pulumi.Input[str] id: Unique identifier of the backup policy item.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> pulumi.Input[int]:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (daily in this case). The only supported value for daily policies is `1` day.
        """
        return pulumi.get(self, "frequency_interval")

    @frequency_interval.setter
    def frequency_interval(self, value: pulumi.Input[int]):
        pulumi.set(self, "frequency_interval", value)

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> pulumi.Input[str]:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @retention_unit.setter
    def retention_unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "retention_unit", value)

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> pulumi.Input[int]:
        """
        Value to associate with `retention_unit`.  Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the hourly policy item specifies a retention of two days, the daily retention policy must specify two days or greater.
        """
        return pulumi.get(self, "retention_value")

    @retention_value.setter
    def retention_value(self, value: pulumi.Input[int]):
        pulumi.set(self, "retention_value", value)

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[pulumi.Input[str]]:
        """
        Frequency associated with the backup policy item. For daily policies, the frequency type is defined as `daily`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @frequency_type.setter
    def frequency_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "frequency_type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class CloudBackupSchedulePolicyItemHourlyArgsDict(TypedDict):
        frequency_interval: pulumi.Input[int]
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (hourly in this case). The supported values for hourly policies are `1`, `2`, `4`, `6`, `8` or `12` hours. Note that `12` hours is the only accepted value for NVMe clusters.
        """
        retention_unit: pulumi.Input[str]
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        retention_value: pulumi.Input[int]
        """
        Value to associate with `retention_unit`.
        """
        frequency_type: NotRequired[pulumi.Input[str]]
        """
        Frequency associated with the backup policy item. For hourly policies, the frequency type is defined as `hourly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Unique identifier of the backup policy item.
        """
elif False:
    CloudBackupSchedulePolicyItemHourlyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudBackupSchedulePolicyItemHourlyArgs:
    def __init__(__self__, *,
                 frequency_interval: pulumi.Input[int],
                 retention_unit: pulumi.Input[str],
                 retention_value: pulumi.Input[int],
                 frequency_type: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (hourly in this case). The supported values for hourly policies are `1`, `2`, `4`, `6`, `8` or `12` hours. Note that `12` hours is the only accepted value for NVMe clusters.
        :param pulumi.Input[str] retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param pulumi.Input[int] retention_value: Value to associate with `retention_unit`.
        :param pulumi.Input[str] frequency_type: Frequency associated with the backup policy item. For hourly policies, the frequency type is defined as `hourly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param pulumi.Input[str] id: Unique identifier of the backup policy item.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> pulumi.Input[int]:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (hourly in this case). The supported values for hourly policies are `1`, `2`, `4`, `6`, `8` or `12` hours. Note that `12` hours is the only accepted value for NVMe clusters.
        """
        return pulumi.get(self, "frequency_interval")

    @frequency_interval.setter
    def frequency_interval(self, value: pulumi.Input[int]):
        pulumi.set(self, "frequency_interval", value)

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> pulumi.Input[str]:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @retention_unit.setter
    def retention_unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "retention_unit", value)

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> pulumi.Input[int]:
        """
        Value to associate with `retention_unit`.
        """
        return pulumi.get(self, "retention_value")

    @retention_value.setter
    def retention_value(self, value: pulumi.Input[int]):
        pulumi.set(self, "retention_value", value)

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[pulumi.Input[str]]:
        """
        Frequency associated with the backup policy item. For hourly policies, the frequency type is defined as `hourly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @frequency_type.setter
    def frequency_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "frequency_type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class CloudBackupSchedulePolicyItemMonthlyArgsDict(TypedDict):
        frequency_interval: pulumi.Input[int]
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (monthly in this case). The supported values for weekly policies are
        """
        retention_unit: pulumi.Input[str]
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        retention_value: pulumi.Input[int]
        """
        Value to associate with `retention_unit`. Monthly policy must have retention days of at least 31 days or 5 weeks or 1 month. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the weekly policy item specifies a retention of two weeks, the montly retention policy must specify two weeks or greater.
        """
        frequency_type: NotRequired[pulumi.Input[str]]
        """
        Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Unique identifier of the backup policy item.
        """
elif False:
    CloudBackupSchedulePolicyItemMonthlyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudBackupSchedulePolicyItemMonthlyArgs:
    def __init__(__self__, *,
                 frequency_interval: pulumi.Input[int],
                 retention_unit: pulumi.Input[str],
                 retention_value: pulumi.Input[int],
                 frequency_type: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (monthly in this case). The supported values for weekly policies are
        :param pulumi.Input[str] retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param pulumi.Input[int] retention_value: Value to associate with `retention_unit`. Monthly policy must have retention days of at least 31 days or 5 weeks or 1 month. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the weekly policy item specifies a retention of two weeks, the montly retention policy must specify two weeks or greater.
        :param pulumi.Input[str] frequency_type: Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param pulumi.Input[str] id: Unique identifier of the backup policy item.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> pulumi.Input[int]:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (monthly in this case). The supported values for weekly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @frequency_interval.setter
    def frequency_interval(self, value: pulumi.Input[int]):
        pulumi.set(self, "frequency_interval", value)

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> pulumi.Input[str]:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @retention_unit.setter
    def retention_unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "retention_unit", value)

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> pulumi.Input[int]:
        """
        Value to associate with `retention_unit`. Monthly policy must have retention days of at least 31 days or 5 weeks or 1 month. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the weekly policy item specifies a retention of two weeks, the montly retention policy must specify two weeks or greater.
        """
        return pulumi.get(self, "retention_value")

    @retention_value.setter
    def retention_value(self, value: pulumi.Input[int]):
        pulumi.set(self, "retention_value", value)

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[pulumi.Input[str]]:
        """
        Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @frequency_type.setter
    def frequency_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "frequency_type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class CloudBackupSchedulePolicyItemWeeklyArgsDict(TypedDict):
        frequency_interval: pulumi.Input[int]
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (weekly in this case). The supported values for weekly policies are `1` through `7`, where `1` represents Monday and `7` represents Sunday.
        """
        retention_unit: pulumi.Input[str]
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        retention_value: pulumi.Input[int]
        """
        Value to associate with `retention_unit`. Weekly policy must have retention of at least 7 days or 1 week. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the daily policy item specifies a retention of two weeks, the weekly retention policy must specify two weeks or greater.
        """
        frequency_type: NotRequired[pulumi.Input[str]]
        """
        Frequency associated with the backup policy item. For weekly policies, the frequency type is defined as `weekly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Unique identifier of the backup policy item.
        """
elif False:
    CloudBackupSchedulePolicyItemWeeklyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudBackupSchedulePolicyItemWeeklyArgs:
    def __init__(__self__, *,
                 frequency_interval: pulumi.Input[int],
                 retention_unit: pulumi.Input[str],
                 retention_value: pulumi.Input[int],
                 frequency_type: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (weekly in this case). The supported values for weekly policies are `1` through `7`, where `1` represents Monday and `7` represents Sunday.
        :param pulumi.Input[str] retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param pulumi.Input[int] retention_value: Value to associate with `retention_unit`. Weekly policy must have retention of at least 7 days or 1 week. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the daily policy item specifies a retention of two weeks, the weekly retention policy must specify two weeks or greater.
        :param pulumi.Input[str] frequency_type: Frequency associated with the backup policy item. For weekly policies, the frequency type is defined as `weekly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param pulumi.Input[str] id: Unique identifier of the backup policy item.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> pulumi.Input[int]:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (weekly in this case). The supported values for weekly policies are `1` through `7`, where `1` represents Monday and `7` represents Sunday.
        """
        return pulumi.get(self, "frequency_interval")

    @frequency_interval.setter
    def frequency_interval(self, value: pulumi.Input[int]):
        pulumi.set(self, "frequency_interval", value)

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> pulumi.Input[str]:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @retention_unit.setter
    def retention_unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "retention_unit", value)

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> pulumi.Input[int]:
        """
        Value to associate with `retention_unit`. Weekly policy must have retention of at least 7 days or 1 week. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the daily policy item specifies a retention of two weeks, the weekly retention policy must specify two weeks or greater.
        """
        return pulumi.get(self, "retention_value")

    @retention_value.setter
    def retention_value(self, value: pulumi.Input[int]):
        pulumi.set(self, "retention_value", value)

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[pulumi.Input[str]]:
        """
        Frequency associated with the backup policy item. For weekly policies, the frequency type is defined as `weekly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @frequency_type.setter
    def frequency_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "frequency_type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class CloudBackupSchedulePolicyItemYearlyArgsDict(TypedDict):
        frequency_interval: pulumi.Input[int]
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        retention_unit: pulumi.Input[str]
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        retention_value: pulumi.Input[int]
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        frequency_type: NotRequired[pulumi.Input[str]]
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Unique identifier of the backup policy item.
        """
elif False:
    CloudBackupSchedulePolicyItemYearlyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudBackupSchedulePolicyItemYearlyArgs:
    def __init__(__self__, *,
                 frequency_interval: pulumi.Input[int],
                 retention_unit: pulumi.Input[str],
                 retention_value: pulumi.Input[int],
                 frequency_type: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        :param pulumi.Input[str] retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param pulumi.Input[int] retention_value: Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        :param pulumi.Input[str] frequency_type: Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param pulumi.Input[str] id: Unique identifier of the backup policy item.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> pulumi.Input[int]:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @frequency_interval.setter
    def frequency_interval(self, value: pulumi.Input[int]):
        pulumi.set(self, "frequency_interval", value)

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> pulumi.Input[str]:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @retention_unit.setter
    def retention_unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "retention_unit", value)

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> pulumi.Input[int]:
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        return pulumi.get(self, "retention_value")

    @retention_value.setter
    def retention_value(self, value: pulumi.Input[int]):
        pulumi.set(self, "retention_value", value)

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[pulumi.Input[str]]:
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @frequency_type.setter
    def frequency_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "frequency_type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class CloudBackupSnapshotExportJobComponentArgsDict(TypedDict):
        export_id: NotRequired[pulumi.Input[str]]
        """
        _Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.
        """
        replica_set_name: NotRequired[pulumi.Input[str]]
        """
        _Returned for sharded clusters only._ Unique identifier of the export job for the replica set.
        """
elif False:
    CloudBackupSnapshotExportJobComponentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudBackupSnapshotExportJobComponentArgs:
    def __init__(__self__, *,
                 export_id: Optional[pulumi.Input[str]] = None,
                 replica_set_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] export_id: _Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.
        :param pulumi.Input[str] replica_set_name: _Returned for sharded clusters only._ Unique identifier of the export job for the replica set.
        """
        if export_id is not None:
            pulumi.set(__self__, "export_id", export_id)
        if replica_set_name is not None:
            pulumi.set(__self__, "replica_set_name", replica_set_name)

    @property
    @pulumi.getter(name="exportId")
    def export_id(self) -> Optional[pulumi.Input[str]]:
        """
        _Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.
        """
        return pulumi.get(self, "export_id")

    @export_id.setter
    def export_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "export_id", value)

    @property
    @pulumi.getter(name="replicaSetName")
    def replica_set_name(self) -> Optional[pulumi.Input[str]]:
        """
        _Returned for sharded clusters only._ Unique identifier of the export job for the replica set.
        """
        return pulumi.get(self, "replica_set_name")

    @replica_set_name.setter
    def replica_set_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replica_set_name", value)


if not MYPY:
    class CloudBackupSnapshotExportJobCustomDataArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Required if you want to include custom data using `custom_data` in the metadata file uploaded to the bucket. Key to include in the metadata file that Atlas uploads to the bucket when the export job finishes.
        """
        value: pulumi.Input[str]
        """
        Required if you specify `key`.
        """
elif False:
    CloudBackupSnapshotExportJobCustomDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudBackupSnapshotExportJobCustomDataArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Required if you want to include custom data using `custom_data` in the metadata file uploaded to the bucket. Key to include in the metadata file that Atlas uploads to the bucket when the export job finishes.
        :param pulumi.Input[str] value: Required if you specify `key`.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Required if you want to include custom data using `custom_data` in the metadata file uploaded to the bucket. Key to include in the metadata file that Atlas uploads to the bucket when the export job finishes.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Required if you specify `key`.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CloudBackupSnapshotMemberArgsDict(TypedDict):
        cloud_provider: NotRequired[pulumi.Input[str]]
        """
        Cloud provider that stores this snapshot.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Unique identifier for the sharded cluster snapshot.
        """
        replica_set_name: NotRequired[pulumi.Input[str]]
        """
        Label given to a shard or config server from which Atlas took this snapshot.
        """
elif False:
    CloudBackupSnapshotMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudBackupSnapshotMemberArgs:
    def __init__(__self__, *,
                 cloud_provider: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 replica_set_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cloud_provider: Cloud provider that stores this snapshot.
        :param pulumi.Input[str] id: Unique identifier for the sharded cluster snapshot.
        :param pulumi.Input[str] replica_set_name: Label given to a shard or config server from which Atlas took this snapshot.
        """
        if cloud_provider is not None:
            pulumi.set(__self__, "cloud_provider", cloud_provider)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if replica_set_name is not None:
            pulumi.set(__self__, "replica_set_name", replica_set_name)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> Optional[pulumi.Input[str]]:
        """
        Cloud provider that stores this snapshot.
        """
        return pulumi.get(self, "cloud_provider")

    @cloud_provider.setter
    def cloud_provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_provider", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier for the sharded cluster snapshot.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="replicaSetName")
    def replica_set_name(self) -> Optional[pulumi.Input[str]]:
        """
        Label given to a shard or config server from which Atlas took this snapshot.
        """
        return pulumi.get(self, "replica_set_name")

    @replica_set_name.setter
    def replica_set_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replica_set_name", value)


if not MYPY:
    class CloudBackupSnapshotRestoreJobDeliveryTypeConfigArgsDict(TypedDict):
        automated: NotRequired[pulumi.Input[bool]]
        download: NotRequired[pulumi.Input[bool]]
        oplog_inc: NotRequired[pulumi.Input[int]]
        oplog_ts: NotRequired[pulumi.Input[int]]
        point_in_time: NotRequired[pulumi.Input[bool]]
        point_in_time_utc_seconds: NotRequired[pulumi.Input[int]]
        target_cluster_name: NotRequired[pulumi.Input[str]]
        """
        Name of the target Atlas cluster to which the restore job restores the snapshot. Only visible if deliveryType is automated.
        """
        target_project_id: NotRequired[pulumi.Input[str]]
        """
        Name of the target Atlas project of the restore job. Only visible if deliveryType is automated.
        """
elif False:
    CloudBackupSnapshotRestoreJobDeliveryTypeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudBackupSnapshotRestoreJobDeliveryTypeConfigArgs:
    def __init__(__self__, *,
                 automated: Optional[pulumi.Input[bool]] = None,
                 download: Optional[pulumi.Input[bool]] = None,
                 oplog_inc: Optional[pulumi.Input[int]] = None,
                 oplog_ts: Optional[pulumi.Input[int]] = None,
                 point_in_time: Optional[pulumi.Input[bool]] = None,
                 point_in_time_utc_seconds: Optional[pulumi.Input[int]] = None,
                 target_cluster_name: Optional[pulumi.Input[str]] = None,
                 target_project_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] target_cluster_name: Name of the target Atlas cluster to which the restore job restores the snapshot. Only visible if deliveryType is automated.
        :param pulumi.Input[str] target_project_id: Name of the target Atlas project of the restore job. Only visible if deliveryType is automated.
        """
        if automated is not None:
            pulumi.set(__self__, "automated", automated)
        if download is not None:
            pulumi.set(__self__, "download", download)
        if oplog_inc is not None:
            pulumi.set(__self__, "oplog_inc", oplog_inc)
        if oplog_ts is not None:
            pulumi.set(__self__, "oplog_ts", oplog_ts)
        if point_in_time is not None:
            pulumi.set(__self__, "point_in_time", point_in_time)
        if point_in_time_utc_seconds is not None:
            pulumi.set(__self__, "point_in_time_utc_seconds", point_in_time_utc_seconds)
        if target_cluster_name is not None:
            pulumi.set(__self__, "target_cluster_name", target_cluster_name)
        if target_project_id is not None:
            pulumi.set(__self__, "target_project_id", target_project_id)

    @property
    @pulumi.getter
    def automated(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "automated")

    @automated.setter
    def automated(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "automated", value)

    @property
    @pulumi.getter
    def download(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "download")

    @download.setter
    def download(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "download", value)

    @property
    @pulumi.getter(name="oplogInc")
    def oplog_inc(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "oplog_inc")

    @oplog_inc.setter
    def oplog_inc(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "oplog_inc", value)

    @property
    @pulumi.getter(name="oplogTs")
    def oplog_ts(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "oplog_ts")

    @oplog_ts.setter
    def oplog_ts(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "oplog_ts", value)

    @property
    @pulumi.getter(name="pointInTime")
    def point_in_time(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "point_in_time")

    @point_in_time.setter
    def point_in_time(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "point_in_time", value)

    @property
    @pulumi.getter(name="pointInTimeUtcSeconds")
    def point_in_time_utc_seconds(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "point_in_time_utc_seconds")

    @point_in_time_utc_seconds.setter
    def point_in_time_utc_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "point_in_time_utc_seconds", value)

    @property
    @pulumi.getter(name="targetClusterName")
    def target_cluster_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the target Atlas cluster to which the restore job restores the snapshot. Only visible if deliveryType is automated.
        """
        return pulumi.get(self, "target_cluster_name")

    @target_cluster_name.setter
    def target_cluster_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_cluster_name", value)

    @property
    @pulumi.getter(name="targetProjectId")
    def target_project_id(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the target Atlas project of the restore job. Only visible if deliveryType is automated.
        """
        return pulumi.get(self, "target_project_id")

    @target_project_id.setter
    def target_project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_project_id", value)


if not MYPY:
    class CloudProviderAccessAuthorizationAwsArgsDict(TypedDict):
        iam_assumed_role_arn: pulumi.Input[str]
elif False:
    CloudProviderAccessAuthorizationAwsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudProviderAccessAuthorizationAwsArgs:
    def __init__(__self__, *,
                 iam_assumed_role_arn: pulumi.Input[str]):
        pulumi.set(__self__, "iam_assumed_role_arn", iam_assumed_role_arn)

    @property
    @pulumi.getter(name="iamAssumedRoleArn")
    def iam_assumed_role_arn(self) -> pulumi.Input[str]:
        return pulumi.get(self, "iam_assumed_role_arn")

    @iam_assumed_role_arn.setter
    def iam_assumed_role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "iam_assumed_role_arn", value)


if not MYPY:
    class CloudProviderAccessAuthorizationAzureArgsDict(TypedDict):
        atlas_azure_app_id: pulumi.Input[str]
        service_principal_id: pulumi.Input[str]
        tenant_id: pulumi.Input[str]
elif False:
    CloudProviderAccessAuthorizationAzureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudProviderAccessAuthorizationAzureArgs:
    def __init__(__self__, *,
                 atlas_azure_app_id: pulumi.Input[str],
                 service_principal_id: pulumi.Input[str],
                 tenant_id: pulumi.Input[str]):
        pulumi.set(__self__, "atlas_azure_app_id", atlas_azure_app_id)
        pulumi.set(__self__, "service_principal_id", service_principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="atlasAzureAppId")
    def atlas_azure_app_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "atlas_azure_app_id")

    @atlas_azure_app_id.setter
    def atlas_azure_app_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "atlas_azure_app_id", value)

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "service_principal_id")

    @service_principal_id.setter
    def service_principal_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class CloudProviderAccessAuthorizationFeatureUsageArgsDict(TypedDict):
        feature_id: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        feature_type: NotRequired[pulumi.Input[str]]
elif False:
    CloudProviderAccessAuthorizationFeatureUsageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudProviderAccessAuthorizationFeatureUsageArgs:
    def __init__(__self__, *,
                 feature_id: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 feature_type: Optional[pulumi.Input[str]] = None):
        if feature_id is not None:
            pulumi.set(__self__, "feature_id", feature_id)
        if feature_type is not None:
            pulumi.set(__self__, "feature_type", feature_type)

    @property
    @pulumi.getter(name="featureId")
    def feature_id(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "feature_id")

    @feature_id.setter
    def feature_id(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "feature_id", value)

    @property
    @pulumi.getter(name="featureType")
    def feature_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "feature_type")

    @feature_type.setter
    def feature_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "feature_type", value)


if not MYPY:
    class CloudProviderAccessSetupAwsConfigArgsDict(TypedDict):
        atlas_assumed_role_external_id: NotRequired[pulumi.Input[str]]
        atlas_aws_account_arn: NotRequired[pulumi.Input[str]]
elif False:
    CloudProviderAccessSetupAwsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudProviderAccessSetupAwsConfigArgs:
    def __init__(__self__, *,
                 atlas_assumed_role_external_id: Optional[pulumi.Input[str]] = None,
                 atlas_aws_account_arn: Optional[pulumi.Input[str]] = None):
        if atlas_assumed_role_external_id is not None:
            pulumi.set(__self__, "atlas_assumed_role_external_id", atlas_assumed_role_external_id)
        if atlas_aws_account_arn is not None:
            pulumi.set(__self__, "atlas_aws_account_arn", atlas_aws_account_arn)

    @property
    @pulumi.getter(name="atlasAssumedRoleExternalId")
    def atlas_assumed_role_external_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "atlas_assumed_role_external_id")

    @atlas_assumed_role_external_id.setter
    def atlas_assumed_role_external_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "atlas_assumed_role_external_id", value)

    @property
    @pulumi.getter(name="atlasAwsAccountArn")
    def atlas_aws_account_arn(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "atlas_aws_account_arn")

    @atlas_aws_account_arn.setter
    def atlas_aws_account_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "atlas_aws_account_arn", value)


if not MYPY:
    class CloudProviderAccessSetupAzureConfigArgsDict(TypedDict):
        atlas_azure_app_id: pulumi.Input[str]
        service_principal_id: pulumi.Input[str]
        tenant_id: pulumi.Input[str]
elif False:
    CloudProviderAccessSetupAzureConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudProviderAccessSetupAzureConfigArgs:
    def __init__(__self__, *,
                 atlas_azure_app_id: pulumi.Input[str],
                 service_principal_id: pulumi.Input[str],
                 tenant_id: pulumi.Input[str]):
        pulumi.set(__self__, "atlas_azure_app_id", atlas_azure_app_id)
        pulumi.set(__self__, "service_principal_id", service_principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="atlasAzureAppId")
    def atlas_azure_app_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "atlas_azure_app_id")

    @atlas_azure_app_id.setter
    def atlas_azure_app_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "atlas_azure_app_id", value)

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "service_principal_id")

    @service_principal_id.setter
    def service_principal_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class ClusterAdvancedConfigurationArgsDict(TypedDict):
        change_stream_options_pre_and_post_images_expire_after_seconds: NotRequired[pulumi.Input[int]]
        """
        The minimum pre- and post-image retention time in seconds. This option corresponds to the `changeStreamOptions.preAndPostImages.expireAfterSeconds` cluster parameter. Defaults to `-1`(off). This setting controls the retention policy of change stream pre- and post-images. Pre- and post-images are the versions of a document before and after document modification, respectively.`expireAfterSeconds` controls how long MongoDB retains pre- and post-images. When set to -1 (off), MongoDB uses the default retention policy: pre- and post-images are retained until the corresponding change stream events are removed from the oplog. To set the minimum pre- and post-image retention time, specify an integer value greater than zero. Setting this too low could increase the risk of interrupting Realm sync or triggers processing. This parameter is only supported for MongoDB version 6.0 and above.
        """
        default_read_concern: NotRequired[pulumi.Input[str]]
        """
        [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).
        """
        default_write_concern: NotRequired[pulumi.Input[str]]
        """
        [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        """
        fail_index_key_too_long: NotRequired[pulumi.Input[bool]]
        """
        When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.
        """
        javascript_enabled: NotRequired[pulumi.Input[bool]]
        """
        When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        """
        minimum_enabled_tls_protocol: NotRequired[pulumi.Input[str]]
        """
        Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:

        - TLS1_0
        - TLS1_1
        - TLS1_2
        """
        no_table_scan: NotRequired[pulumi.Input[bool]]
        """
        When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        """
        oplog_min_retention_hours: NotRequired[pulumi.Input[float]]
        """
        Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.
        * **Note**  A minimum oplog retention is required when seeking to change a cluster's class to Local NVMe SSD. To learn more and for latest guidance see  [`oplogMinRetentionHours`](https://www.mongodb.com/docs/manual/core/replica-set-oplog/#std-label-replica-set-minimum-oplog-size)
        """
        oplog_size_mb: NotRequired[pulumi.Input[int]]
        """
        The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        """
        sample_refresh_interval_bi_connector: NotRequired[pulumi.Input[int]]
        """
        Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        sample_size_bi_connector: NotRequired[pulumi.Input[int]]
        """
        Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        transaction_lifetime_limit_seconds: NotRequired[pulumi.Input[int]]
        """
        Lifetime, in seconds, of multi-document transactions. Defaults to 60 seconds.
        """
elif False:
    ClusterAdvancedConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAdvancedConfigurationArgs:
    def __init__(__self__, *,
                 change_stream_options_pre_and_post_images_expire_after_seconds: Optional[pulumi.Input[int]] = None,
                 default_read_concern: Optional[pulumi.Input[str]] = None,
                 default_write_concern: Optional[pulumi.Input[str]] = None,
                 fail_index_key_too_long: Optional[pulumi.Input[bool]] = None,
                 javascript_enabled: Optional[pulumi.Input[bool]] = None,
                 minimum_enabled_tls_protocol: Optional[pulumi.Input[str]] = None,
                 no_table_scan: Optional[pulumi.Input[bool]] = None,
                 oplog_min_retention_hours: Optional[pulumi.Input[float]] = None,
                 oplog_size_mb: Optional[pulumi.Input[int]] = None,
                 sample_refresh_interval_bi_connector: Optional[pulumi.Input[int]] = None,
                 sample_size_bi_connector: Optional[pulumi.Input[int]] = None,
                 transaction_lifetime_limit_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] change_stream_options_pre_and_post_images_expire_after_seconds: The minimum pre- and post-image retention time in seconds. This option corresponds to the `changeStreamOptions.preAndPostImages.expireAfterSeconds` cluster parameter. Defaults to `-1`(off). This setting controls the retention policy of change stream pre- and post-images. Pre- and post-images are the versions of a document before and after document modification, respectively.`expireAfterSeconds` controls how long MongoDB retains pre- and post-images. When set to -1 (off), MongoDB uses the default retention policy: pre- and post-images are retained until the corresponding change stream events are removed from the oplog. To set the minimum pre- and post-image retention time, specify an integer value greater than zero. Setting this too low could increase the risk of interrupting Realm sync or triggers processing. This parameter is only supported for MongoDB version 6.0 and above.
        :param pulumi.Input[str] default_read_concern: [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).
        :param pulumi.Input[str] default_write_concern: [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        :param pulumi.Input[bool] fail_index_key_too_long: When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.
        :param pulumi.Input[bool] javascript_enabled: When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        :param pulumi.Input[str] minimum_enabled_tls_protocol: Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:
               
               - TLS1_0
               - TLS1_1
               - TLS1_2
        :param pulumi.Input[bool] no_table_scan: When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        :param pulumi.Input[float] oplog_min_retention_hours: Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.
               * **Note**  A minimum oplog retention is required when seeking to change a cluster's class to Local NVMe SSD. To learn more and for latest guidance see  [`oplogMinRetentionHours`](https://www.mongodb.com/docs/manual/core/replica-set-oplog/#std-label-replica-set-minimum-oplog-size)
        :param pulumi.Input[int] oplog_size_mb: The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        :param pulumi.Input[int] sample_refresh_interval_bi_connector: Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        :param pulumi.Input[int] sample_size_bi_connector: Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        :param pulumi.Input[int] transaction_lifetime_limit_seconds: Lifetime, in seconds, of multi-document transactions. Defaults to 60 seconds.
        """
        if change_stream_options_pre_and_post_images_expire_after_seconds is not None:
            pulumi.set(__self__, "change_stream_options_pre_and_post_images_expire_after_seconds", change_stream_options_pre_and_post_images_expire_after_seconds)
        if default_read_concern is not None:
            warnings.warn("""This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown""", DeprecationWarning)
            pulumi.log.warn("""default_read_concern is deprecated: This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown""")
        if default_read_concern is not None:
            pulumi.set(__self__, "default_read_concern", default_read_concern)
        if default_write_concern is not None:
            pulumi.set(__self__, "default_write_concern", default_write_concern)
        if fail_index_key_too_long is not None:
            warnings.warn("""This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown""", DeprecationWarning)
            pulumi.log.warn("""fail_index_key_too_long is deprecated: This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown""")
        if fail_index_key_too_long is not None:
            pulumi.set(__self__, "fail_index_key_too_long", fail_index_key_too_long)
        if javascript_enabled is not None:
            pulumi.set(__self__, "javascript_enabled", javascript_enabled)
        if minimum_enabled_tls_protocol is not None:
            pulumi.set(__self__, "minimum_enabled_tls_protocol", minimum_enabled_tls_protocol)
        if no_table_scan is not None:
            pulumi.set(__self__, "no_table_scan", no_table_scan)
        if oplog_min_retention_hours is not None:
            pulumi.set(__self__, "oplog_min_retention_hours", oplog_min_retention_hours)
        if oplog_size_mb is not None:
            pulumi.set(__self__, "oplog_size_mb", oplog_size_mb)
        if sample_refresh_interval_bi_connector is not None:
            pulumi.set(__self__, "sample_refresh_interval_bi_connector", sample_refresh_interval_bi_connector)
        if sample_size_bi_connector is not None:
            pulumi.set(__self__, "sample_size_bi_connector", sample_size_bi_connector)
        if transaction_lifetime_limit_seconds is not None:
            pulumi.set(__self__, "transaction_lifetime_limit_seconds", transaction_lifetime_limit_seconds)

    @property
    @pulumi.getter(name="changeStreamOptionsPreAndPostImagesExpireAfterSeconds")
    def change_stream_options_pre_and_post_images_expire_after_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The minimum pre- and post-image retention time in seconds. This option corresponds to the `changeStreamOptions.preAndPostImages.expireAfterSeconds` cluster parameter. Defaults to `-1`(off). This setting controls the retention policy of change stream pre- and post-images. Pre- and post-images are the versions of a document before and after document modification, respectively.`expireAfterSeconds` controls how long MongoDB retains pre- and post-images. When set to -1 (off), MongoDB uses the default retention policy: pre- and post-images are retained until the corresponding change stream events are removed from the oplog. To set the minimum pre- and post-image retention time, specify an integer value greater than zero. Setting this too low could increase the risk of interrupting Realm sync or triggers processing. This parameter is only supported for MongoDB version 6.0 and above.
        """
        return pulumi.get(self, "change_stream_options_pre_and_post_images_expire_after_seconds")

    @change_stream_options_pre_and_post_images_expire_after_seconds.setter
    def change_stream_options_pre_and_post_images_expire_after_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "change_stream_options_pre_and_post_images_expire_after_seconds", value)

    @property
    @pulumi.getter(name="defaultReadConcern")
    @_utilities.deprecated("""This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown""")
    def default_read_concern(self) -> Optional[pulumi.Input[str]]:
        """
        [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).
        """
        return pulumi.get(self, "default_read_concern")

    @default_read_concern.setter
    def default_read_concern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_read_concern", value)

    @property
    @pulumi.getter(name="defaultWriteConcern")
    def default_write_concern(self) -> Optional[pulumi.Input[str]]:
        """
        [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        """
        return pulumi.get(self, "default_write_concern")

    @default_write_concern.setter
    def default_write_concern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_write_concern", value)

    @property
    @pulumi.getter(name="failIndexKeyTooLong")
    @_utilities.deprecated("""This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown""")
    def fail_index_key_too_long(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.
        """
        return pulumi.get(self, "fail_index_key_too_long")

    @fail_index_key_too_long.setter
    def fail_index_key_too_long(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fail_index_key_too_long", value)

    @property
    @pulumi.getter(name="javascriptEnabled")
    def javascript_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        """
        return pulumi.get(self, "javascript_enabled")

    @javascript_enabled.setter
    def javascript_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "javascript_enabled", value)

    @property
    @pulumi.getter(name="minimumEnabledTlsProtocol")
    def minimum_enabled_tls_protocol(self) -> Optional[pulumi.Input[str]]:
        """
        Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:

        - TLS1_0
        - TLS1_1
        - TLS1_2
        """
        return pulumi.get(self, "minimum_enabled_tls_protocol")

    @minimum_enabled_tls_protocol.setter
    def minimum_enabled_tls_protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "minimum_enabled_tls_protocol", value)

    @property
    @pulumi.getter(name="noTableScan")
    def no_table_scan(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        """
        return pulumi.get(self, "no_table_scan")

    @no_table_scan.setter
    def no_table_scan(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_table_scan", value)

    @property
    @pulumi.getter(name="oplogMinRetentionHours")
    def oplog_min_retention_hours(self) -> Optional[pulumi.Input[float]]:
        """
        Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.
        * **Note**  A minimum oplog retention is required when seeking to change a cluster's class to Local NVMe SSD. To learn more and for latest guidance see  [`oplogMinRetentionHours`](https://www.mongodb.com/docs/manual/core/replica-set-oplog/#std-label-replica-set-minimum-oplog-size)
        """
        return pulumi.get(self, "oplog_min_retention_hours")

    @oplog_min_retention_hours.setter
    def oplog_min_retention_hours(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "oplog_min_retention_hours", value)

    @property
    @pulumi.getter(name="oplogSizeMb")
    def oplog_size_mb(self) -> Optional[pulumi.Input[int]]:
        """
        The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        """
        return pulumi.get(self, "oplog_size_mb")

    @oplog_size_mb.setter
    def oplog_size_mb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "oplog_size_mb", value)

    @property
    @pulumi.getter(name="sampleRefreshIntervalBiConnector")
    def sample_refresh_interval_bi_connector(self) -> Optional[pulumi.Input[int]]:
        """
        Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_refresh_interval_bi_connector")

    @sample_refresh_interval_bi_connector.setter
    def sample_refresh_interval_bi_connector(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "sample_refresh_interval_bi_connector", value)

    @property
    @pulumi.getter(name="sampleSizeBiConnector")
    def sample_size_bi_connector(self) -> Optional[pulumi.Input[int]]:
        """
        Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_size_bi_connector")

    @sample_size_bi_connector.setter
    def sample_size_bi_connector(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "sample_size_bi_connector", value)

    @property
    @pulumi.getter(name="transactionLifetimeLimitSeconds")
    def transaction_lifetime_limit_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Lifetime, in seconds, of multi-document transactions. Defaults to 60 seconds.
        """
        return pulumi.get(self, "transaction_lifetime_limit_seconds")

    @transaction_lifetime_limit_seconds.setter
    def transaction_lifetime_limit_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "transaction_lifetime_limit_seconds", value)


if not MYPY:
    class ClusterBiConnectorConfigArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Specifies whether or not BI Connector for Atlas is enabled on the cluster.l
        *
        - Set to `true` to enable BI Connector for Atlas.
        - Set to `false` to disable BI Connector for Atlas.
        """
        read_preference: NotRequired[pulumi.Input[str]]
        """
        Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).

        - Set to "primary" to have BI Connector for Atlas read from the primary.

        - Set to "secondary" to have BI Connector for Atlas read from a secondary member. Default if there are no analytics nodes in the cluster.

        - Set to "analytics" to have BI Connector for Atlas read from an analytics node. Default if the cluster contains analytics nodes.
        """
elif False:
    ClusterBiConnectorConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterBiConnectorConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 read_preference: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Specifies whether or not BI Connector for Atlas is enabled on the cluster.l
               *
               - Set to `true` to enable BI Connector for Atlas.
               - Set to `false` to disable BI Connector for Atlas.
        :param pulumi.Input[str] read_preference: Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
               
               - Set to "primary" to have BI Connector for Atlas read from the primary.
               
               - Set to "secondary" to have BI Connector for Atlas read from a secondary member. Default if there are no analytics nodes in the cluster.
               
               - Set to "analytics" to have BI Connector for Atlas read from an analytics node. Default if the cluster contains analytics nodes.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if read_preference is not None:
            pulumi.set(__self__, "read_preference", read_preference)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether or not BI Connector for Atlas is enabled on the cluster.l
        *
        - Set to `true` to enable BI Connector for Atlas.
        - Set to `false` to disable BI Connector for Atlas.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="readPreference")
    def read_preference(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).

        - Set to "primary" to have BI Connector for Atlas read from the primary.

        - Set to "secondary" to have BI Connector for Atlas read from a secondary member. Default if there are no analytics nodes in the cluster.

        - Set to "analytics" to have BI Connector for Atlas read from an analytics node. Default if the cluster contains analytics nodes.
        """
        return pulumi.get(self, "read_preference")

    @read_preference.setter
    def read_preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "read_preference", value)


if not MYPY:
    class ClusterConnectionStringArgsDict(TypedDict):
        private: NotRequired[pulumi.Input[str]]
        """
        [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        """
        private_endpoints: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterConnectionStringPrivateEndpointArgsDict']]]]
        """
        Private endpoint connection strings. Each object describes the connection strings you can use to connect to this cluster through a private endpoint. Atlas returns this parameter only if you deployed a private endpoint to all regions to which you deployed this cluster's nodes.
        - `connection_strings.private_endpoint.#.connection_string` - Private-endpoint-aware `mongodb://`connection string for this private endpoint.
        - `connection_strings.private_endpoint.#.srv_connection_string` - Private-endpoint-aware `mongodb+srv://` connection string for this private endpoint. The `mongodb+srv` protocol tells the driver to look up the seed list of hosts in DNS . Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don't need to: Append the seed list or Change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn't, use `connection_strings.private_endpoint[n].connection_string`
        - `connection_strings.private_endpoint.#.srv_shard_optimized_connection_string` - Private endpoint-aware connection string optimized for sharded clusters that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint. If the connection string uses this Uniform Resource Identifier (URI) format, you don't need to change the Uniform Resource Identifier (URI) if the nodes change. Use this Uniform Resource Identifier (URI) format if your application and Atlas cluster supports it. If it doesn't, use and consult the documentation for connectionStrings.privateEndpoint[n].srvConnectionString.
        - `connection_strings.private_endpoint.#.type` - Type of MongoDB process that you connect to with the connection strings. Atlas returns `MONGOD` for replica sets, or `MONGOS` for sharded clusters.
        - `connection_strings.private_endpoint.#.endpoints` - Private endpoint through which you connect to Atlas when you use `connection_strings.private_endpoint[n].connection_string` or `connection_strings.private_endpoint[n].srv_connection_string`
        - `connection_strings.private_endpoint.#.endpoints.#.endpoint_id` - Unique identifier of the private endpoint.
        - `connection_strings.private_endpoint.#.endpoints.#.provider_name` - Cloud provider to which you deployed the private endpoint. Atlas returns `AWS` or `AZURE`.
        - `connection_strings.private_endpoint.#.endpoints.#.region` - Region to which you deployed the private endpoint.
        """
        private_srv: NotRequired[pulumi.Input[str]]
        """
        [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        """
        standard: NotRequired[pulumi.Input[str]]
        """
        Public mongodb:// connection string for this cluster.
        """
        standard_srv: NotRequired[pulumi.Input[str]]
        """
        Public mongodb+srv:// connection string for this cluster. The mongodb+srv protocol tells the driver to look up the seed list of hosts in DNS. Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don’t need to append the seed list or change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn’t  , use connectionStrings.standard.
        """
elif False:
    ClusterConnectionStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterConnectionStringArgs:
    def __init__(__self__, *,
                 private: Optional[pulumi.Input[str]] = None,
                 private_endpoints: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterConnectionStringPrivateEndpointArgs']]]] = None,
                 private_srv: Optional[pulumi.Input[str]] = None,
                 standard: Optional[pulumi.Input[str]] = None,
                 standard_srv: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] private: [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterConnectionStringPrivateEndpointArgs']]] private_endpoints: Private endpoint connection strings. Each object describes the connection strings you can use to connect to this cluster through a private endpoint. Atlas returns this parameter only if you deployed a private endpoint to all regions to which you deployed this cluster's nodes.
               - `connection_strings.private_endpoint.#.connection_string` - Private-endpoint-aware `mongodb://`connection string for this private endpoint.
               - `connection_strings.private_endpoint.#.srv_connection_string` - Private-endpoint-aware `mongodb+srv://` connection string for this private endpoint. The `mongodb+srv` protocol tells the driver to look up the seed list of hosts in DNS . Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don't need to: Append the seed list or Change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn't, use `connection_strings.private_endpoint[n].connection_string`
               - `connection_strings.private_endpoint.#.srv_shard_optimized_connection_string` - Private endpoint-aware connection string optimized for sharded clusters that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint. If the connection string uses this Uniform Resource Identifier (URI) format, you don't need to change the Uniform Resource Identifier (URI) if the nodes change. Use this Uniform Resource Identifier (URI) format if your application and Atlas cluster supports it. If it doesn't, use and consult the documentation for connectionStrings.privateEndpoint[n].srvConnectionString.
               - `connection_strings.private_endpoint.#.type` - Type of MongoDB process that you connect to with the connection strings. Atlas returns `MONGOD` for replica sets, or `MONGOS` for sharded clusters.
               - `connection_strings.private_endpoint.#.endpoints` - Private endpoint through which you connect to Atlas when you use `connection_strings.private_endpoint[n].connection_string` or `connection_strings.private_endpoint[n].srv_connection_string`
               - `connection_strings.private_endpoint.#.endpoints.#.endpoint_id` - Unique identifier of the private endpoint.
               - `connection_strings.private_endpoint.#.endpoints.#.provider_name` - Cloud provider to which you deployed the private endpoint. Atlas returns `AWS` or `AZURE`.
               - `connection_strings.private_endpoint.#.endpoints.#.region` - Region to which you deployed the private endpoint.
        :param pulumi.Input[str] private_srv: [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        :param pulumi.Input[str] standard: Public mongodb:// connection string for this cluster.
        :param pulumi.Input[str] standard_srv: Public mongodb+srv:// connection string for this cluster. The mongodb+srv protocol tells the driver to look up the seed list of hosts in DNS. Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don’t need to append the seed list or change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn’t  , use connectionStrings.standard.
        """
        if private is not None:
            pulumi.set(__self__, "private", private)
        if private_endpoints is not None:
            pulumi.set(__self__, "private_endpoints", private_endpoints)
        if private_srv is not None:
            pulumi.set(__self__, "private_srv", private_srv)
        if standard is not None:
            pulumi.set(__self__, "standard", standard)
        if standard_srv is not None:
            pulumi.set(__self__, "standard_srv", standard_srv)

    @property
    @pulumi.getter
    def private(self) -> Optional[pulumi.Input[str]]:
        """
        [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        """
        return pulumi.get(self, "private")

    @private.setter
    def private(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private", value)

    @property
    @pulumi.getter(name="privateEndpoints")
    def private_endpoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterConnectionStringPrivateEndpointArgs']]]]:
        """
        Private endpoint connection strings. Each object describes the connection strings you can use to connect to this cluster through a private endpoint. Atlas returns this parameter only if you deployed a private endpoint to all regions to which you deployed this cluster's nodes.
        - `connection_strings.private_endpoint.#.connection_string` - Private-endpoint-aware `mongodb://`connection string for this private endpoint.
        - `connection_strings.private_endpoint.#.srv_connection_string` - Private-endpoint-aware `mongodb+srv://` connection string for this private endpoint. The `mongodb+srv` protocol tells the driver to look up the seed list of hosts in DNS . Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don't need to: Append the seed list or Change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn't, use `connection_strings.private_endpoint[n].connection_string`
        - `connection_strings.private_endpoint.#.srv_shard_optimized_connection_string` - Private endpoint-aware connection string optimized for sharded clusters that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint. If the connection string uses this Uniform Resource Identifier (URI) format, you don't need to change the Uniform Resource Identifier (URI) if the nodes change. Use this Uniform Resource Identifier (URI) format if your application and Atlas cluster supports it. If it doesn't, use and consult the documentation for connectionStrings.privateEndpoint[n].srvConnectionString.
        - `connection_strings.private_endpoint.#.type` - Type of MongoDB process that you connect to with the connection strings. Atlas returns `MONGOD` for replica sets, or `MONGOS` for sharded clusters.
        - `connection_strings.private_endpoint.#.endpoints` - Private endpoint through which you connect to Atlas when you use `connection_strings.private_endpoint[n].connection_string` or `connection_strings.private_endpoint[n].srv_connection_string`
        - `connection_strings.private_endpoint.#.endpoints.#.endpoint_id` - Unique identifier of the private endpoint.
        - `connection_strings.private_endpoint.#.endpoints.#.provider_name` - Cloud provider to which you deployed the private endpoint. Atlas returns `AWS` or `AZURE`.
        - `connection_strings.private_endpoint.#.endpoints.#.region` - Region to which you deployed the private endpoint.
        """
        return pulumi.get(self, "private_endpoints")

    @private_endpoints.setter
    def private_endpoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterConnectionStringPrivateEndpointArgs']]]]):
        pulumi.set(self, "private_endpoints", value)

    @property
    @pulumi.getter(name="privateSrv")
    def private_srv(self) -> Optional[pulumi.Input[str]]:
        """
        [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        """
        return pulumi.get(self, "private_srv")

    @private_srv.setter
    def private_srv(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_srv", value)

    @property
    @pulumi.getter
    def standard(self) -> Optional[pulumi.Input[str]]:
        """
        Public mongodb:// connection string for this cluster.
        """
        return pulumi.get(self, "standard")

    @standard.setter
    def standard(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "standard", value)

    @property
    @pulumi.getter(name="standardSrv")
    def standard_srv(self) -> Optional[pulumi.Input[str]]:
        """
        Public mongodb+srv:// connection string for this cluster. The mongodb+srv protocol tells the driver to look up the seed list of hosts in DNS. Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don’t need to append the seed list or change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn’t  , use connectionStrings.standard.
        """
        return pulumi.get(self, "standard_srv")

    @standard_srv.setter
    def standard_srv(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "standard_srv", value)


if not MYPY:
    class ClusterConnectionStringPrivateEndpointArgsDict(TypedDict):
        connection_string: NotRequired[pulumi.Input[str]]
        endpoints: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterConnectionStringPrivateEndpointEndpointArgsDict']]]]
        srv_connection_string: NotRequired[pulumi.Input[str]]
        srv_shard_optimized_connection_string: NotRequired[pulumi.Input[str]]
        type: NotRequired[pulumi.Input[str]]
elif False:
    ClusterConnectionStringPrivateEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterConnectionStringPrivateEndpointArgs:
    def __init__(__self__, *,
                 connection_string: Optional[pulumi.Input[str]] = None,
                 endpoints: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterConnectionStringPrivateEndpointEndpointArgs']]]] = None,
                 srv_connection_string: Optional[pulumi.Input[str]] = None,
                 srv_shard_optimized_connection_string: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if srv_connection_string is not None:
            pulumi.set(__self__, "srv_connection_string", srv_connection_string)
        if srv_shard_optimized_connection_string is not None:
            pulumi.set(__self__, "srv_shard_optimized_connection_string", srv_shard_optimized_connection_string)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterConnectionStringPrivateEndpointEndpointArgs']]]]:
        return pulumi.get(self, "endpoints")

    @endpoints.setter
    def endpoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterConnectionStringPrivateEndpointEndpointArgs']]]]):
        pulumi.set(self, "endpoints", value)

    @property
    @pulumi.getter(name="srvConnectionString")
    def srv_connection_string(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "srv_connection_string")

    @srv_connection_string.setter
    def srv_connection_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "srv_connection_string", value)

    @property
    @pulumi.getter(name="srvShardOptimizedConnectionString")
    def srv_shard_optimized_connection_string(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "srv_shard_optimized_connection_string")

    @srv_shard_optimized_connection_string.setter
    def srv_shard_optimized_connection_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "srv_shard_optimized_connection_string", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ClusterConnectionStringPrivateEndpointEndpointArgsDict(TypedDict):
        endpoint_id: NotRequired[pulumi.Input[str]]
        provider_name: NotRequired[pulumi.Input[str]]
        """
        Cloud service provider on which the servers are provisioned.

        The possible values are:

        - `AWS` - Amazon AWS
        - `GCP` - Google Cloud Platform
        - `AZURE` - Microsoft Azure
        - `TENANT` - A multi-tenant deployment on one of the supported cloud service providers. Only valid when providerSettings.instanceSizeName is either M2 or M5.
        """
        region: NotRequired[pulumi.Input[str]]
elif False:
    ClusterConnectionStringPrivateEndpointEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterConnectionStringPrivateEndpointEndpointArgs:
    def __init__(__self__, *,
                 endpoint_id: Optional[pulumi.Input[str]] = None,
                 provider_name: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] provider_name: Cloud service provider on which the servers are provisioned.
               
               The possible values are:
               
               - `AWS` - Amazon AWS
               - `GCP` - Google Cloud Platform
               - `AZURE` - Microsoft Azure
               - `TENANT` - A multi-tenant deployment on one of the supported cloud service providers. Only valid when providerSettings.instanceSizeName is either M2 or M5.
        """
        if endpoint_id is not None:
            pulumi.set(__self__, "endpoint_id", endpoint_id)
        if provider_name is not None:
            pulumi.set(__self__, "provider_name", provider_name)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "endpoint_id")

    @endpoint_id.setter
    def endpoint_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint_id", value)

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> Optional[pulumi.Input[str]]:
        """
        Cloud service provider on which the servers are provisioned.

        The possible values are:

        - `AWS` - Amazon AWS
        - `GCP` - Google Cloud Platform
        - `AZURE` - Microsoft Azure
        - `TENANT` - A multi-tenant deployment on one of the supported cloud service providers. Only valid when providerSettings.instanceSizeName is either M2 or M5.
        """
        return pulumi.get(self, "provider_name")

    @provider_name.setter
    def provider_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "provider_name", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class ClusterLabelArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        The key that you want to write.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        The value that you want to write.

        > **NOTE:** MongoDB Atlas doesn't display your labels.
        """
elif False:
    ClusterLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterLabelArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: The key that you want to write.
        :param pulumi.Input[str] value: The value that you want to write.
               
               > **NOTE:** MongoDB Atlas doesn't display your labels.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value that you want to write.

        > **NOTE:** MongoDB Atlas doesn't display your labels.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ClusterOutageSimulationOutageFilterArgsDict(TypedDict):
        cloud_provider: pulumi.Input[str]
        """
        The cloud provider of the region that undergoes the outage simulation. Following values are supported:
        * `AWS`
        * `GCP`
        * `AZURE`
        """
        region_name: pulumi.Input[str]
        """
        The Atlas name of the region to undergo an outage simulation.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The type of cluster outage simulation. Following values are supported:
        * `REGION` - Simulates a cluster outage for a region
        """
elif False:
    ClusterOutageSimulationOutageFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterOutageSimulationOutageFilterArgs:
    def __init__(__self__, *,
                 cloud_provider: pulumi.Input[str],
                 region_name: pulumi.Input[str],
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cloud_provider: The cloud provider of the region that undergoes the outage simulation. Following values are supported:
               * `AWS`
               * `GCP`
               * `AZURE`
        :param pulumi.Input[str] region_name: The Atlas name of the region to undergo an outage simulation.
        :param pulumi.Input[str] type: The type of cluster outage simulation. Following values are supported:
               * `REGION` - Simulates a cluster outage for a region
        """
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "region_name", region_name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> pulumi.Input[str]:
        """
        The cloud provider of the region that undergoes the outage simulation. Following values are supported:
        * `AWS`
        * `GCP`
        * `AZURE`
        """
        return pulumi.get(self, "cloud_provider")

    @cloud_provider.setter
    def cloud_provider(self, value: pulumi.Input[str]):
        pulumi.set(self, "cloud_provider", value)

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> pulumi.Input[str]:
        """
        The Atlas name of the region to undergo an outage simulation.
        """
        return pulumi.get(self, "region_name")

    @region_name.setter
    def region_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "region_name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of cluster outage simulation. Following values are supported:
        * `REGION` - Simulates a cluster outage for a region
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ClusterReplicationSpecArgsDict(TypedDict):
        num_shards: pulumi.Input[int]
        """
        Selects whether the cluster is a replica set or a sharded cluster. If you use the replicationSpecs parameter, you must set num_shards.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        """
        regions_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterReplicationSpecRegionsConfigArgsDict']]]]
        """
        Physical location of the region. Each regionsConfig document describes the region’s priority in elections and the number and type of MongoDB nodes Atlas deploys to the region. You must order each regionsConfigs document by regionsConfig.priority, descending. See Region Config below for more details.
        """
        zone_name: NotRequired[pulumi.Input[str]]
        """
        Name for the zone in a Global Cluster.


        **Region Config**
        """
elif False:
    ClusterReplicationSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterReplicationSpecArgs:
    def __init__(__self__, *,
                 num_shards: pulumi.Input[int],
                 id: Optional[pulumi.Input[str]] = None,
                 regions_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterReplicationSpecRegionsConfigArgs']]]] = None,
                 zone_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] num_shards: Selects whether the cluster is a replica set or a sharded cluster. If you use the replicationSpecs parameter, you must set num_shards.
        :param pulumi.Input[str] id: Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterReplicationSpecRegionsConfigArgs']]] regions_configs: Physical location of the region. Each regionsConfig document describes the region’s priority in elections and the number and type of MongoDB nodes Atlas deploys to the region. You must order each regionsConfigs document by regionsConfig.priority, descending. See Region Config below for more details.
        :param pulumi.Input[str] zone_name: Name for the zone in a Global Cluster.
               
               
               **Region Config**
        """
        pulumi.set(__self__, "num_shards", num_shards)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if regions_configs is not None:
            pulumi.set(__self__, "regions_configs", regions_configs)
        if zone_name is not None:
            pulumi.set(__self__, "zone_name", zone_name)

    @property
    @pulumi.getter(name="numShards")
    def num_shards(self) -> pulumi.Input[int]:
        """
        Selects whether the cluster is a replica set or a sharded cluster. If you use the replicationSpecs parameter, you must set num_shards.
        """
        return pulumi.get(self, "num_shards")

    @num_shards.setter
    def num_shards(self, value: pulumi.Input[int]):
        pulumi.set(self, "num_shards", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="regionsConfigs")
    def regions_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterReplicationSpecRegionsConfigArgs']]]]:
        """
        Physical location of the region. Each regionsConfig document describes the region’s priority in elections and the number and type of MongoDB nodes Atlas deploys to the region. You must order each regionsConfigs document by regionsConfig.priority, descending. See Region Config below for more details.
        """
        return pulumi.get(self, "regions_configs")

    @regions_configs.setter
    def regions_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterReplicationSpecRegionsConfigArgs']]]]):
        pulumi.set(self, "regions_configs", value)

    @property
    @pulumi.getter(name="zoneName")
    def zone_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name for the zone in a Global Cluster.


        **Region Config**
        """
        return pulumi.get(self, "zone_name")

    @zone_name.setter
    def zone_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone_name", value)


if not MYPY:
    class ClusterReplicationSpecRegionsConfigArgsDict(TypedDict):
        region_name: pulumi.Input[str]
        """
        Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        """
        analytics_nodes: NotRequired[pulumi.Input[int]]
        """
        The number of analytics nodes for Atlas to deploy to the region. Analytics nodes are useful for handling analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only, and can never become the primary. If you do not specify this option, no analytics nodes are deployed to the region.
        """
        electable_nodes: NotRequired[pulumi.Input[int]]
        """
        Number of electable nodes for Atlas to deploy to the region. Electable nodes can become the primary and can facilitate local reads.
        * The total number of electableNodes across all replication spec regions  must total 3, 5, or 7.
        * Specify 0 if you do not want any electable nodes in the region.
        * You cannot create electable nodes in a region if `priority` is 0.
        """
        priority: NotRequired[pulumi.Input[int]]
        """
        Election priority of the region. For regions with only read-only nodes, set this value to 0.
        * For regions where `electable_nodes` is at least 1, each region must have a priority of exactly one (1) less than the previous region. The first region must have a priority of 7. The lowest possible priority is 1.
        * The priority 7 region identifies the Preferred Region of the cluster. Atlas places the primary node in the Preferred Region. Priorities 1 through 7 are exclusive - no more than one region per cluster can be assigned a given priority.
        * Example: If you have three regions, their priorities would be 7, 6, and 5 respectively. If you added two more regions for supporting electable nodes, the priorities of those regions would be 4 and 3 respectively.
        """
        read_only_nodes: NotRequired[pulumi.Input[int]]
        """
        Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the primary, but can facilitate local-reads. Specify 0 if you do not want any read-only nodes in the region.
        """
elif False:
    ClusterReplicationSpecRegionsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterReplicationSpecRegionsConfigArgs:
    def __init__(__self__, *,
                 region_name: pulumi.Input[str],
                 analytics_nodes: Optional[pulumi.Input[int]] = None,
                 electable_nodes: Optional[pulumi.Input[int]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 read_only_nodes: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] region_name: Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        :param pulumi.Input[int] analytics_nodes: The number of analytics nodes for Atlas to deploy to the region. Analytics nodes are useful for handling analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only, and can never become the primary. If you do not specify this option, no analytics nodes are deployed to the region.
        :param pulumi.Input[int] electable_nodes: Number of electable nodes for Atlas to deploy to the region. Electable nodes can become the primary and can facilitate local reads.
               * The total number of electableNodes across all replication spec regions  must total 3, 5, or 7.
               * Specify 0 if you do not want any electable nodes in the region.
               * You cannot create electable nodes in a region if `priority` is 0.
        :param pulumi.Input[int] priority: Election priority of the region. For regions with only read-only nodes, set this value to 0.
               * For regions where `electable_nodes` is at least 1, each region must have a priority of exactly one (1) less than the previous region. The first region must have a priority of 7. The lowest possible priority is 1.
               * The priority 7 region identifies the Preferred Region of the cluster. Atlas places the primary node in the Preferred Region. Priorities 1 through 7 are exclusive - no more than one region per cluster can be assigned a given priority.
               * Example: If you have three regions, their priorities would be 7, 6, and 5 respectively. If you added two more regions for supporting electable nodes, the priorities of those regions would be 4 and 3 respectively.
        :param pulumi.Input[int] read_only_nodes: Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the primary, but can facilitate local-reads. Specify 0 if you do not want any read-only nodes in the region.
        """
        pulumi.set(__self__, "region_name", region_name)
        if analytics_nodes is not None:
            pulumi.set(__self__, "analytics_nodes", analytics_nodes)
        if electable_nodes is not None:
            pulumi.set(__self__, "electable_nodes", electable_nodes)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if read_only_nodes is not None:
            pulumi.set(__self__, "read_only_nodes", read_only_nodes)

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> pulumi.Input[str]:
        """
        Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        """
        return pulumi.get(self, "region_name")

    @region_name.setter
    def region_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "region_name", value)

    @property
    @pulumi.getter(name="analyticsNodes")
    def analytics_nodes(self) -> Optional[pulumi.Input[int]]:
        """
        The number of analytics nodes for Atlas to deploy to the region. Analytics nodes are useful for handling analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only, and can never become the primary. If you do not specify this option, no analytics nodes are deployed to the region.
        """
        return pulumi.get(self, "analytics_nodes")

    @analytics_nodes.setter
    def analytics_nodes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "analytics_nodes", value)

    @property
    @pulumi.getter(name="electableNodes")
    def electable_nodes(self) -> Optional[pulumi.Input[int]]:
        """
        Number of electable nodes for Atlas to deploy to the region. Electable nodes can become the primary and can facilitate local reads.
        * The total number of electableNodes across all replication spec regions  must total 3, 5, or 7.
        * Specify 0 if you do not want any electable nodes in the region.
        * You cannot create electable nodes in a region if `priority` is 0.
        """
        return pulumi.get(self, "electable_nodes")

    @electable_nodes.setter
    def electable_nodes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "electable_nodes", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        Election priority of the region. For regions with only read-only nodes, set this value to 0.
        * For regions where `electable_nodes` is at least 1, each region must have a priority of exactly one (1) less than the previous region. The first region must have a priority of 7. The lowest possible priority is 1.
        * The priority 7 region identifies the Preferred Region of the cluster. Atlas places the primary node in the Preferred Region. Priorities 1 through 7 are exclusive - no more than one region per cluster can be assigned a given priority.
        * Example: If you have three regions, their priorities would be 7, 6, and 5 respectively. If you added two more regions for supporting electable nodes, the priorities of those regions would be 4 and 3 respectively.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="readOnlyNodes")
    def read_only_nodes(self) -> Optional[pulumi.Input[int]]:
        """
        Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the primary, but can facilitate local-reads. Specify 0 if you do not want any read-only nodes in the region.
        """
        return pulumi.get(self, "read_only_nodes")

    @read_only_nodes.setter
    def read_only_nodes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "read_only_nodes", value)


if not MYPY:
    class ClusterSnapshotBackupPolicyArgsDict(TypedDict):
        cluster_id: NotRequired[pulumi.Input[str]]
        """
        The cluster ID.
        """
        cluster_name: NotRequired[pulumi.Input[str]]
        next_snapshot: NotRequired[pulumi.Input[str]]
        policies: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterSnapshotBackupPolicyPolicyArgsDict']]]]
        reference_hour_of_day: NotRequired[pulumi.Input[int]]
        reference_minute_of_hour: NotRequired[pulumi.Input[int]]
        restore_window_days: NotRequired[pulumi.Input[int]]
        update_snapshots: NotRequired[pulumi.Input[bool]]
elif False:
    ClusterSnapshotBackupPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterSnapshotBackupPolicyArgs:
    def __init__(__self__, *,
                 cluster_id: Optional[pulumi.Input[str]] = None,
                 cluster_name: Optional[pulumi.Input[str]] = None,
                 next_snapshot: Optional[pulumi.Input[str]] = None,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterSnapshotBackupPolicyPolicyArgs']]]] = None,
                 reference_hour_of_day: Optional[pulumi.Input[int]] = None,
                 reference_minute_of_hour: Optional[pulumi.Input[int]] = None,
                 restore_window_days: Optional[pulumi.Input[int]] = None,
                 update_snapshots: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] cluster_id: The cluster ID.
        """
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if next_snapshot is not None:
            pulumi.set(__self__, "next_snapshot", next_snapshot)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if reference_hour_of_day is not None:
            pulumi.set(__self__, "reference_hour_of_day", reference_hour_of_day)
        if reference_minute_of_hour is not None:
            pulumi.set(__self__, "reference_minute_of_hour", reference_minute_of_hour)
        if restore_window_days is not None:
            pulumi.set(__self__, "restore_window_days", restore_window_days)
        if update_snapshots is not None:
            pulumi.set(__self__, "update_snapshots", update_snapshots)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[str]]:
        """
        The cluster ID.
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="nextSnapshot")
    def next_snapshot(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "next_snapshot")

    @next_snapshot.setter
    def next_snapshot(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "next_snapshot", value)

    @property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterSnapshotBackupPolicyPolicyArgs']]]]:
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterSnapshotBackupPolicyPolicyArgs']]]]):
        pulumi.set(self, "policies", value)

    @property
    @pulumi.getter(name="referenceHourOfDay")
    def reference_hour_of_day(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "reference_hour_of_day")

    @reference_hour_of_day.setter
    def reference_hour_of_day(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "reference_hour_of_day", value)

    @property
    @pulumi.getter(name="referenceMinuteOfHour")
    def reference_minute_of_hour(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "reference_minute_of_hour")

    @reference_minute_of_hour.setter
    def reference_minute_of_hour(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "reference_minute_of_hour", value)

    @property
    @pulumi.getter(name="restoreWindowDays")
    def restore_window_days(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "restore_window_days")

    @restore_window_days.setter
    def restore_window_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "restore_window_days", value)

    @property
    @pulumi.getter(name="updateSnapshots")
    def update_snapshots(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "update_snapshots")

    @update_snapshots.setter
    def update_snapshots(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "update_snapshots", value)


if not MYPY:
    class ClusterSnapshotBackupPolicyPolicyArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[str]]
        """
        Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        """
        policy_items: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterSnapshotBackupPolicyPolicyPolicyItemArgsDict']]]]
elif False:
    ClusterSnapshotBackupPolicyPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterSnapshotBackupPolicyPolicyArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 policy_items: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterSnapshotBackupPolicyPolicyPolicyItemArgs']]]] = None):
        """
        :param pulumi.Input[str] id: Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if policy_items is not None:
            pulumi.set(__self__, "policy_items", policy_items)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="policyItems")
    def policy_items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterSnapshotBackupPolicyPolicyPolicyItemArgs']]]]:
        return pulumi.get(self, "policy_items")

    @policy_items.setter
    def policy_items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterSnapshotBackupPolicyPolicyPolicyItemArgs']]]]):
        pulumi.set(self, "policy_items", value)


if not MYPY:
    class ClusterSnapshotBackupPolicyPolicyPolicyItemArgsDict(TypedDict):
        frequency_interval: NotRequired[pulumi.Input[int]]
        frequency_type: NotRequired[pulumi.Input[str]]
        id: NotRequired[pulumi.Input[str]]
        """
        Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        """
        retention_unit: NotRequired[pulumi.Input[str]]
        retention_value: NotRequired[pulumi.Input[int]]
elif False:
    ClusterSnapshotBackupPolicyPolicyPolicyItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterSnapshotBackupPolicyPolicyPolicyItemArgs:
    def __init__(__self__, *,
                 frequency_interval: Optional[pulumi.Input[int]] = None,
                 frequency_type: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 retention_unit: Optional[pulumi.Input[str]] = None,
                 retention_value: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] id: Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        """
        if frequency_interval is not None:
            pulumi.set(__self__, "frequency_interval", frequency_interval)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if retention_unit is not None:
            pulumi.set(__self__, "retention_unit", retention_unit)
        if retention_value is not None:
            pulumi.set(__self__, "retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "frequency_interval")

    @frequency_interval.setter
    def frequency_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "frequency_interval", value)

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "frequency_type")

    @frequency_type.setter
    def frequency_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "frequency_type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "retention_unit")

    @retention_unit.setter
    def retention_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "retention_unit", value)

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "retention_value")

    @retention_value.setter
    def retention_value(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retention_value", value)


if not MYPY:
    class ClusterTagArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Constant that defines the set of the tag.
        """
        value: pulumi.Input[str]
        """
        Variable that belongs to the set of the tag.

        To learn more, see [Resource Tags](https://dochub.mongodb.org/core/add-cluster-tag-atlas).
        """
elif False:
    ClusterTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Constant that defines the set of the tag.
        :param pulumi.Input[str] value: Variable that belongs to the set of the tag.
               
               To learn more, see [Resource Tags](https://dochub.mongodb.org/core/add-cluster-tag-atlas).
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Constant that defines the set of the tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Variable that belongs to the set of the tag.

        To learn more, see [Resource Tags](https://dochub.mongodb.org/core/add-cluster-tag-atlas).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CustomDbRoleActionArgsDict(TypedDict):
        action: pulumi.Input[str]
        """
        Name of the privilege action. For a complete list of actions available in the Atlas API, see [Custom Role Actions](https://docs.atlas.mongodb.com/reference/api/custom-role-actions)
        > **Note**: The privilege actions available to the Custom Roles API resource represent a subset of the privilege actions available in the Atlas Custom Roles UI.
        """
        resources: pulumi.Input[Sequence[pulumi.Input['CustomDbRoleActionResourceArgsDict']]]
        """
        Contains information on where the action is granted. Each object in the array either indicates a database and collection on which the action is granted, or indicates that the action is granted on the cluster resource.

        * `resources.#.collection_name` - (Optional) Collection on which the action is granted. If this value is an empty string, the action is granted on all collections within the database specified in the actions.resources.db field.

        > **NOTE** This field is mutually exclusive with the `actions.resources.cluster` field.

        * `resources.#.database_name`	Database on which the action is granted.

        > **NOTE** This field is mutually exclusive with the `actions.resources.cluster` field.

        * `resources.#.cluster`	(Optional) Set to true to indicate that the action is granted on the cluster resource.

        > **NOTE** This field is mutually exclusive with the `actions.resources.collection` and `actions.resources.db fields`.
        """
elif False:
    CustomDbRoleActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomDbRoleActionArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 resources: pulumi.Input[Sequence[pulumi.Input['CustomDbRoleActionResourceArgs']]]):
        """
        :param pulumi.Input[str] action: Name of the privilege action. For a complete list of actions available in the Atlas API, see [Custom Role Actions](https://docs.atlas.mongodb.com/reference/api/custom-role-actions)
               > **Note**: The privilege actions available to the Custom Roles API resource represent a subset of the privilege actions available in the Atlas Custom Roles UI.
        :param pulumi.Input[Sequence[pulumi.Input['CustomDbRoleActionResourceArgs']]] resources: Contains information on where the action is granted. Each object in the array either indicates a database and collection on which the action is granted, or indicates that the action is granted on the cluster resource.
               
               * `resources.#.collection_name` - (Optional) Collection on which the action is granted. If this value is an empty string, the action is granted on all collections within the database specified in the actions.resources.db field.
               
               > **NOTE** This field is mutually exclusive with the `actions.resources.cluster` field.
               
               * `resources.#.database_name`	Database on which the action is granted.
               
               > **NOTE** This field is mutually exclusive with the `actions.resources.cluster` field.
               
               * `resources.#.cluster`	(Optional) Set to true to indicate that the action is granted on the cluster resource.
               
               > **NOTE** This field is mutually exclusive with the `actions.resources.collection` and `actions.resources.db fields`.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        Name of the privilege action. For a complete list of actions available in the Atlas API, see [Custom Role Actions](https://docs.atlas.mongodb.com/reference/api/custom-role-actions)
        > **Note**: The privilege actions available to the Custom Roles API resource represent a subset of the privilege actions available in the Atlas Custom Roles UI.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def resources(self) -> pulumi.Input[Sequence[pulumi.Input['CustomDbRoleActionResourceArgs']]]:
        """
        Contains information on where the action is granted. Each object in the array either indicates a database and collection on which the action is granted, or indicates that the action is granted on the cluster resource.

        * `resources.#.collection_name` - (Optional) Collection on which the action is granted. If this value is an empty string, the action is granted on all collections within the database specified in the actions.resources.db field.

        > **NOTE** This field is mutually exclusive with the `actions.resources.cluster` field.

        * `resources.#.database_name`	Database on which the action is granted.

        > **NOTE** This field is mutually exclusive with the `actions.resources.cluster` field.

        * `resources.#.cluster`	(Optional) Set to true to indicate that the action is granted on the cluster resource.

        > **NOTE** This field is mutually exclusive with the `actions.resources.collection` and `actions.resources.db fields`.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: pulumi.Input[Sequence[pulumi.Input['CustomDbRoleActionResourceArgs']]]):
        pulumi.set(self, "resources", value)


if not MYPY:
    class CustomDbRoleActionResourceArgsDict(TypedDict):
        cluster: NotRequired[pulumi.Input[bool]]
        collection_name: NotRequired[pulumi.Input[str]]
        database_name: NotRequired[pulumi.Input[str]]
        """
        Database on which the inherited role is granted.

        > **NOTE** This value should be admin for all roles except read and readWrite.
        """
elif False:
    CustomDbRoleActionResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomDbRoleActionResourceArgs:
    def __init__(__self__, *,
                 cluster: Optional[pulumi.Input[bool]] = None,
                 collection_name: Optional[pulumi.Input[str]] = None,
                 database_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] database_name: Database on which the inherited role is granted.
               
               > **NOTE** This value should be admin for all roles except read and readWrite.
        """
        if cluster is not None:
            pulumi.set(__self__, "cluster", cluster)
        if collection_name is not None:
            pulumi.set(__self__, "collection_name", collection_name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)

    @property
    @pulumi.getter
    def cluster(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "cluster")

    @cluster.setter
    def cluster(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cluster", value)

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "collection_name")

    @collection_name.setter
    def collection_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "collection_name", value)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[str]]:
        """
        Database on which the inherited role is granted.

        > **NOTE** This value should be admin for all roles except read and readWrite.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_name", value)


if not MYPY:
    class CustomDbRoleInheritedRoleArgsDict(TypedDict):
        database_name: pulumi.Input[str]
        """
        Database on which the inherited role is granted.

        > **NOTE** This value should be admin for all roles except read and readWrite.
        """
        role_name: pulumi.Input[str]
        """
        Name of the inherited role. This can either be another custom role or a built-in role.
        """
elif False:
    CustomDbRoleInheritedRoleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomDbRoleInheritedRoleArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[str],
                 role_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] database_name: Database on which the inherited role is granted.
               
               > **NOTE** This value should be admin for all roles except read and readWrite.
        :param pulumi.Input[str] role_name: Name of the inherited role. This can either be another custom role or a built-in role.
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "role_name", role_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[str]:
        """
        Database on which the inherited role is granted.

        > **NOTE** This value should be admin for all roles except read and readWrite.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> pulumi.Input[str]:
        """
        Name of the inherited role. This can either be another custom role or a built-in role.
        """
        return pulumi.get(self, "role_name")

    @role_name.setter
    def role_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_name", value)


if not MYPY:
    class DataLakePipelineIngestionScheduleArgsDict(TypedDict):
        frequency_interval: NotRequired[pulumi.Input[int]]
        frequency_type: NotRequired[pulumi.Input[str]]
        id: NotRequired[pulumi.Input[str]]
        """
        Unique 24-hexadecimal digit string that identifies the Data Lake Pipeline.
        """
        retention_unit: NotRequired[pulumi.Input[str]]
        retention_value: NotRequired[pulumi.Input[int]]
elif False:
    DataLakePipelineIngestionScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataLakePipelineIngestionScheduleArgs:
    def __init__(__self__, *,
                 frequency_interval: Optional[pulumi.Input[int]] = None,
                 frequency_type: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 retention_unit: Optional[pulumi.Input[str]] = None,
                 retention_value: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] id: Unique 24-hexadecimal digit string that identifies the Data Lake Pipeline.
        """
        if frequency_interval is not None:
            pulumi.set(__self__, "frequency_interval", frequency_interval)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if retention_unit is not None:
            pulumi.set(__self__, "retention_unit", retention_unit)
        if retention_value is not None:
            pulumi.set(__self__, "retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "frequency_interval")

    @frequency_interval.setter
    def frequency_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "frequency_interval", value)

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "frequency_type")

    @frequency_type.setter
    def frequency_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "frequency_type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique 24-hexadecimal digit string that identifies the Data Lake Pipeline.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "retention_unit")

    @retention_unit.setter
    def retention_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "retention_unit", value)

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "retention_value")

    @retention_value.setter
    def retention_value(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retention_value", value)


if not MYPY:
    class DataLakePipelineSinkArgsDict(TypedDict):
        partition_fields: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataLakePipelineSinkPartitionFieldArgsDict']]]]
        """
        Ordered fields used to physically organize data in the destination.
        * `partition_fields.#.field_name` - Human-readable label that identifies the field name used to partition data.
        * `partition_fields.#.order` - Sequence in which MongoDB Atlas slices the collection data to create partitions. The resource expresses this sequence starting with zero.
        """
        provider: NotRequired[pulumi.Input[str]]
        """
        Target cloud provider for this Data Lake Pipeline.
        """
        region: NotRequired[pulumi.Input[str]]
        """
        Target cloud provider region for this Data Lake Pipeline. [Supported cloud provider regions](https://www.mongodb.com/docs/datalake/limitations).
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of ingestion source of this Data Lake Pipeline.
        """
elif False:
    DataLakePipelineSinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataLakePipelineSinkArgs:
    def __init__(__self__, *,
                 partition_fields: Optional[pulumi.Input[Sequence[pulumi.Input['DataLakePipelineSinkPartitionFieldArgs']]]] = None,
                 provider: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DataLakePipelineSinkPartitionFieldArgs']]] partition_fields: Ordered fields used to physically organize data in the destination.
               * `partition_fields.#.field_name` - Human-readable label that identifies the field name used to partition data.
               * `partition_fields.#.order` - Sequence in which MongoDB Atlas slices the collection data to create partitions. The resource expresses this sequence starting with zero.
        :param pulumi.Input[str] provider: Target cloud provider for this Data Lake Pipeline.
        :param pulumi.Input[str] region: Target cloud provider region for this Data Lake Pipeline. [Supported cloud provider regions](https://www.mongodb.com/docs/datalake/limitations).
        :param pulumi.Input[str] type: Type of ingestion source of this Data Lake Pipeline.
        """
        if partition_fields is not None:
            pulumi.set(__self__, "partition_fields", partition_fields)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="partitionFields")
    def partition_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataLakePipelineSinkPartitionFieldArgs']]]]:
        """
        Ordered fields used to physically organize data in the destination.
        * `partition_fields.#.field_name` - Human-readable label that identifies the field name used to partition data.
        * `partition_fields.#.order` - Sequence in which MongoDB Atlas slices the collection data to create partitions. The resource expresses this sequence starting with zero.
        """
        return pulumi.get(self, "partition_fields")

    @partition_fields.setter
    def partition_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataLakePipelineSinkPartitionFieldArgs']]]]):
        pulumi.set(self, "partition_fields", value)

    @property
    @pulumi.getter
    def provider(self) -> Optional[pulumi.Input[str]]:
        """
        Target cloud provider for this Data Lake Pipeline.
        """
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "provider", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        Target cloud provider region for this Data Lake Pipeline. [Supported cloud provider regions](https://www.mongodb.com/docs/datalake/limitations).
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of ingestion source of this Data Lake Pipeline.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DataLakePipelineSinkPartitionFieldArgsDict(TypedDict):
        field_name: pulumi.Input[str]
        order: pulumi.Input[int]
elif False:
    DataLakePipelineSinkPartitionFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataLakePipelineSinkPartitionFieldArgs:
    def __init__(__self__, *,
                 field_name: pulumi.Input[str],
                 order: pulumi.Input[int]):
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "field_name")

    @field_name.setter
    def field_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "field_name", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[int]:
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[int]):
        pulumi.set(self, "order", value)


if not MYPY:
    class DataLakePipelineSnapshotArgsDict(TypedDict):
        copy_region: NotRequired[pulumi.Input[str]]
        created_at: NotRequired[pulumi.Input[str]]
        expires_at: NotRequired[pulumi.Input[str]]
        frequency_yype: NotRequired[pulumi.Input[str]]
        id: NotRequired[pulumi.Input[str]]
        """
        Unique 24-hexadecimal digit string that identifies the Data Lake Pipeline.
        """
        master_key: NotRequired[pulumi.Input[str]]
        mongod_version: NotRequired[pulumi.Input[str]]
        policies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        provider: NotRequired[pulumi.Input[str]]
        """
        Target cloud provider for this Data Lake Pipeline.
        """
        replica_set_name: NotRequired[pulumi.Input[str]]
        size: NotRequired[pulumi.Input[int]]
        snapshot_type: NotRequired[pulumi.Input[str]]
        status: NotRequired[pulumi.Input[str]]
        type: NotRequired[pulumi.Input[str]]
        """
        Type of ingestion source of this Data Lake Pipeline.
        """
elif False:
    DataLakePipelineSnapshotArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataLakePipelineSnapshotArgs:
    def __init__(__self__, *,
                 copy_region: Optional[pulumi.Input[str]] = None,
                 created_at: Optional[pulumi.Input[str]] = None,
                 expires_at: Optional[pulumi.Input[str]] = None,
                 frequency_yype: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 master_key: Optional[pulumi.Input[str]] = None,
                 mongod_version: Optional[pulumi.Input[str]] = None,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 provider: Optional[pulumi.Input[str]] = None,
                 replica_set_name: Optional[pulumi.Input[str]] = None,
                 size: Optional[pulumi.Input[int]] = None,
                 snapshot_type: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: Unique 24-hexadecimal digit string that identifies the Data Lake Pipeline.
        :param pulumi.Input[str] provider: Target cloud provider for this Data Lake Pipeline.
        :param pulumi.Input[str] type: Type of ingestion source of this Data Lake Pipeline.
        """
        if copy_region is not None:
            pulumi.set(__self__, "copy_region", copy_region)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if expires_at is not None:
            pulumi.set(__self__, "expires_at", expires_at)
        if frequency_yype is not None:
            pulumi.set(__self__, "frequency_yype", frequency_yype)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if master_key is not None:
            pulumi.set(__self__, "master_key", master_key)
        if mongod_version is not None:
            pulumi.set(__self__, "mongod_version", mongod_version)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if replica_set_name is not None:
            pulumi.set(__self__, "replica_set_name", replica_set_name)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if snapshot_type is not None:
            pulumi.set(__self__, "snapshot_type", snapshot_type)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="copyRegion")
    def copy_region(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "copy_region")

    @copy_region.setter
    def copy_region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "copy_region", value)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "expires_at")

    @expires_at.setter
    def expires_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expires_at", value)

    @property
    @pulumi.getter(name="frequencyYype")
    def frequency_yype(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "frequency_yype")

    @frequency_yype.setter
    def frequency_yype(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "frequency_yype", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique 24-hexadecimal digit string that identifies the Data Lake Pipeline.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="masterKey")
    def master_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "master_key")

    @master_key.setter
    def master_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "master_key", value)

    @property
    @pulumi.getter(name="mongodVersion")
    def mongod_version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mongod_version")

    @mongod_version.setter
    def mongod_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mongod_version", value)

    @property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "policies", value)

    @property
    @pulumi.getter
    def provider(self) -> Optional[pulumi.Input[str]]:
        """
        Target cloud provider for this Data Lake Pipeline.
        """
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "provider", value)

    @property
    @pulumi.getter(name="replicaSetName")
    def replica_set_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "replica_set_name")

    @replica_set_name.setter
    def replica_set_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replica_set_name", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="snapshotType")
    def snapshot_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "snapshot_type")

    @snapshot_type.setter
    def snapshot_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snapshot_type", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of ingestion source of this Data Lake Pipeline.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DataLakePipelineSourceArgsDict(TypedDict):
        cluster_name: NotRequired[pulumi.Input[str]]
        """
        Human-readable name that identifies the cluster.
        """
        collection_name: NotRequired[pulumi.Input[str]]
        """
        Human-readable name that identifies the collection.
        """
        database_name: NotRequired[pulumi.Input[str]]
        """
        Human-readable name that identifies the database.
        """
        policy_item_id: NotRequired[pulumi.Input[str]]
        project_id: NotRequired[pulumi.Input[str]]
        """
        The unique ID for the project to create a data lake pipeline.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of ingestion source of this Data Lake Pipeline.
        """
elif False:
    DataLakePipelineSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataLakePipelineSourceArgs:
    def __init__(__self__, *,
                 cluster_name: Optional[pulumi.Input[str]] = None,
                 collection_name: Optional[pulumi.Input[str]] = None,
                 database_name: Optional[pulumi.Input[str]] = None,
                 policy_item_id: Optional[pulumi.Input[str]] = None,
                 project_id: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cluster_name: Human-readable name that identifies the cluster.
        :param pulumi.Input[str] collection_name: Human-readable name that identifies the collection.
        :param pulumi.Input[str] database_name: Human-readable name that identifies the database.
        :param pulumi.Input[str] project_id: The unique ID for the project to create a data lake pipeline.
        :param pulumi.Input[str] type: Type of ingestion source of this Data Lake Pipeline.
        """
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if collection_name is not None:
            pulumi.set(__self__, "collection_name", collection_name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if policy_item_id is not None:
            pulumi.set(__self__, "policy_item_id", policy_item_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[pulumi.Input[str]]:
        """
        Human-readable name that identifies the cluster.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> Optional[pulumi.Input[str]]:
        """
        Human-readable name that identifies the collection.
        """
        return pulumi.get(self, "collection_name")

    @collection_name.setter
    def collection_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "collection_name", value)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[str]]:
        """
        Human-readable name that identifies the database.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter(name="policyItemId")
    def policy_item_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "policy_item_id")

    @policy_item_id.setter
    def policy_item_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "policy_item_id", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique ID for the project to create a data lake pipeline.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of ingestion source of this Data Lake Pipeline.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DataLakePipelineTransformationArgsDict(TypedDict):
        field: NotRequired[pulumi.Input[str]]
        type: NotRequired[pulumi.Input[str]]
        """
        Type of ingestion source of this Data Lake Pipeline.
        """
elif False:
    DataLakePipelineTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataLakePipelineTransformationArgs:
    def __init__(__self__, *,
                 field: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Type of ingestion source of this Data Lake Pipeline.
        """
        if field is not None:
            pulumi.set(__self__, "field", field)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def field(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of ingestion source of this Data Lake Pipeline.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DatabaseUserLabelArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        The key that you want to write.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        The value that you want to write.
        """
elif False:
    DatabaseUserLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseUserLabelArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: The key that you want to write.
        :param pulumi.Input[str] value: The value that you want to write.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value that you want to write.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DatabaseUserRoleArgsDict(TypedDict):
        database_name: pulumi.Input[str]
        """
        Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases. This field should be set to `admin` for a custom MongoDB role.
        """
        role_name: pulumi.Input[str]
        """
        Name of the role to grant. See [Create a Database User](https://docs.atlas.mongodb.com/reference/api/database-users-create-a-user/) `roles.roleName` for valid values and restrictions.
        """
        collection_name: NotRequired[pulumi.Input[str]]
        """
        Collection for which the role applies. You can specify a collection for the `read` and `readWrite` roles. If you do not specify a collection for `read` and `readWrite`, the role applies to all collections in the database (excluding some collections in the `system`. database).
        """
elif False:
    DatabaseUserRoleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseUserRoleArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[str],
                 role_name: pulumi.Input[str],
                 collection_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] database_name: Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases. This field should be set to `admin` for a custom MongoDB role.
        :param pulumi.Input[str] role_name: Name of the role to grant. See [Create a Database User](https://docs.atlas.mongodb.com/reference/api/database-users-create-a-user/) `roles.roleName` for valid values and restrictions.
        :param pulumi.Input[str] collection_name: Collection for which the role applies. You can specify a collection for the `read` and `readWrite` roles. If you do not specify a collection for `read` and `readWrite`, the role applies to all collections in the database (excluding some collections in the `system`. database).
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "role_name", role_name)
        if collection_name is not None:
            pulumi.set(__self__, "collection_name", collection_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[str]:
        """
        Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases. This field should be set to `admin` for a custom MongoDB role.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> pulumi.Input[str]:
        """
        Name of the role to grant. See [Create a Database User](https://docs.atlas.mongodb.com/reference/api/database-users-create-a-user/) `roles.roleName` for valid values and restrictions.
        """
        return pulumi.get(self, "role_name")

    @role_name.setter
    def role_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_name", value)

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> Optional[pulumi.Input[str]]:
        """
        Collection for which the role applies. You can specify a collection for the `read` and `readWrite` roles. If you do not specify a collection for `read` and `readWrite`, the role applies to all collections in the database (excluding some collections in the `system`. database).
        """
        return pulumi.get(self, "collection_name")

    @collection_name.setter
    def collection_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "collection_name", value)


if not MYPY:
    class DatabaseUserScopeArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the cluster or Atlas Data Lake that the user has access to.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of resource that the user has access to. Valid values are: `CLUSTER` and `DATA_LAKE`
        """
elif False:
    DatabaseUserScopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseUserScopeArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the cluster or Atlas Data Lake that the user has access to.
        :param pulumi.Input[str] type: Type of resource that the user has access to. Valid values are: `CLUSTER` and `DATA_LAKE`
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the cluster or Atlas Data Lake that the user has access to.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of resource that the user has access to. Valid values are: `CLUSTER` and `DATA_LAKE`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class EncryptionAtRestAwsKmsConfigArgsDict(TypedDict):
        access_key_id: NotRequired[pulumi.Input[str]]
        """
        Unique alphanumeric string that identifies an Identity and Access Management (IAM) access key with permissions required to access your Amazon Web Services (AWS) Customer Master Key (CMK).
        """
        customer_master_key_id: NotRequired[pulumi.Input[str]]
        """
        Unique alphanumeric string that identifies the Amazon Web Services (AWS) Customer Master Key (CMK) you used to encrypt and decrypt the MongoDB master keys.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Flag that indicates whether someone enabled encryption at rest for the specified project through Amazon Web Services (AWS) Key Management Service (KMS). To disable encryption at rest using customer key management and remove the configuration details, pass only this parameter with a value of `false`.
        """
        region: NotRequired[pulumi.Input[str]]
        """
        Physical location where MongoDB Atlas deploys your AWS-hosted MongoDB cluster nodes. The region you choose can affect network latency for clients accessing your databases. When MongoDB Cloud deploys a dedicated cluster, it checks if a VPC or VPC connection exists for that provider and region. If not, MongoDB Atlas creates them as part of the deployment. MongoDB Atlas assigns the VPC a CIDR block. To limit a new VPC peering connection to one CIDR block and region, create the connection first. Deploy the cluster after the connection starts.
        """
        role_id: NotRequired[pulumi.Input[str]]
        """
        Unique 24-hexadecimal digit string that identifies an Amazon Web Services (AWS) Identity and Access Management (IAM) role. This IAM role has the permissions required to manage your AWS customer master key.
        """
        secret_access_key: NotRequired[pulumi.Input[str]]
        """
        Human-readable label of the Identity and Access Management (IAM) secret access key with permissions required to access your Amazon Web Services (AWS) customer master key.
        """
        valid: NotRequired[pulumi.Input[bool]]
        """
        Flag that indicates whether the Amazon Web Services (AWS) Key Management Service (KMS) encryption key can encrypt and decrypt data.
        """
elif False:
    EncryptionAtRestAwsKmsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EncryptionAtRestAwsKmsConfigArgs:
    def __init__(__self__, *,
                 access_key_id: Optional[pulumi.Input[str]] = None,
                 customer_master_key_id: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 role_id: Optional[pulumi.Input[str]] = None,
                 secret_access_key: Optional[pulumi.Input[str]] = None,
                 valid: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] access_key_id: Unique alphanumeric string that identifies an Identity and Access Management (IAM) access key with permissions required to access your Amazon Web Services (AWS) Customer Master Key (CMK).
        :param pulumi.Input[str] customer_master_key_id: Unique alphanumeric string that identifies the Amazon Web Services (AWS) Customer Master Key (CMK) you used to encrypt and decrypt the MongoDB master keys.
        :param pulumi.Input[bool] enabled: Flag that indicates whether someone enabled encryption at rest for the specified project through Amazon Web Services (AWS) Key Management Service (KMS). To disable encryption at rest using customer key management and remove the configuration details, pass only this parameter with a value of `false`.
        :param pulumi.Input[str] region: Physical location where MongoDB Atlas deploys your AWS-hosted MongoDB cluster nodes. The region you choose can affect network latency for clients accessing your databases. When MongoDB Cloud deploys a dedicated cluster, it checks if a VPC or VPC connection exists for that provider and region. If not, MongoDB Atlas creates them as part of the deployment. MongoDB Atlas assigns the VPC a CIDR block. To limit a new VPC peering connection to one CIDR block and region, create the connection first. Deploy the cluster after the connection starts.
        :param pulumi.Input[str] role_id: Unique 24-hexadecimal digit string that identifies an Amazon Web Services (AWS) Identity and Access Management (IAM) role. This IAM role has the permissions required to manage your AWS customer master key.
        :param pulumi.Input[str] secret_access_key: Human-readable label of the Identity and Access Management (IAM) secret access key with permissions required to access your Amazon Web Services (AWS) customer master key.
        :param pulumi.Input[bool] valid: Flag that indicates whether the Amazon Web Services (AWS) Key Management Service (KMS) encryption key can encrypt and decrypt data.
        """
        if access_key_id is not None:
            pulumi.set(__self__, "access_key_id", access_key_id)
        if customer_master_key_id is not None:
            pulumi.set(__self__, "customer_master_key_id", customer_master_key_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_id is not None:
            pulumi.set(__self__, "role_id", role_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if valid is not None:
            pulumi.set(__self__, "valid", valid)

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique alphanumeric string that identifies an Identity and Access Management (IAM) access key with permissions required to access your Amazon Web Services (AWS) Customer Master Key (CMK).
        """
        return pulumi.get(self, "access_key_id")

    @access_key_id.setter
    def access_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_key_id", value)

    @property
    @pulumi.getter(name="customerMasterKeyId")
    def customer_master_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique alphanumeric string that identifies the Amazon Web Services (AWS) Customer Master Key (CMK) you used to encrypt and decrypt the MongoDB master keys.
        """
        return pulumi.get(self, "customer_master_key_id")

    @customer_master_key_id.setter
    def customer_master_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "customer_master_key_id", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag that indicates whether someone enabled encryption at rest for the specified project through Amazon Web Services (AWS) Key Management Service (KMS). To disable encryption at rest using customer key management and remove the configuration details, pass only this parameter with a value of `false`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        Physical location where MongoDB Atlas deploys your AWS-hosted MongoDB cluster nodes. The region you choose can affect network latency for clients accessing your databases. When MongoDB Cloud deploys a dedicated cluster, it checks if a VPC or VPC connection exists for that provider and region. If not, MongoDB Atlas creates them as part of the deployment. MongoDB Atlas assigns the VPC a CIDR block. To limit a new VPC peering connection to one CIDR block and region, create the connection first. Deploy the cluster after the connection starts.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="roleId")
    def role_id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique 24-hexadecimal digit string that identifies an Amazon Web Services (AWS) Identity and Access Management (IAM) role. This IAM role has the permissions required to manage your AWS customer master key.
        """
        return pulumi.get(self, "role_id")

    @role_id.setter
    def role_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role_id", value)

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[pulumi.Input[str]]:
        """
        Human-readable label of the Identity and Access Management (IAM) secret access key with permissions required to access your Amazon Web Services (AWS) customer master key.
        """
        return pulumi.get(self, "secret_access_key")

    @secret_access_key.setter
    def secret_access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_access_key", value)

    @property
    @pulumi.getter
    def valid(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag that indicates whether the Amazon Web Services (AWS) Key Management Service (KMS) encryption key can encrypt and decrypt data.
        """
        return pulumi.get(self, "valid")

    @valid.setter
    def valid(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "valid", value)


if not MYPY:
    class EncryptionAtRestAzureKeyVaultConfigArgsDict(TypedDict):
        azure_environment: NotRequired[pulumi.Input[str]]
        """
        Azure environment in which your account credentials reside.
        """
        client_id: NotRequired[pulumi.Input[str]]
        """
        Unique 36-hexadecimal character string that identifies an Azure application associated with your Azure Active Directory tenant.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Flag that indicates whether someone enabled encryption at rest for the specified  project. To disable encryption at rest using customer key management and remove the configuration details, pass only this parameter with a value of `false`.
        """
        key_identifier: NotRequired[pulumi.Input[str]]
        """
        Web address with a unique key that identifies for your Azure Key Vault.
        """
        key_vault_name: NotRequired[pulumi.Input[str]]
        """
        Unique string that identifies the Azure Key Vault that contains your key.
        """
        require_private_networking: NotRequired[pulumi.Input[bool]]
        """
        Enable connection to your Azure Key Vault over private networking.
        """
        resource_group_name: NotRequired[pulumi.Input[str]]
        """
        Name of the Azure resource group that contains your Azure Key Vault.
        """
        secret: NotRequired[pulumi.Input[str]]
        """
        Private data that you need secured and that belongs to the specified Azure Key Vault (AKV) tenant (**azureKeyVault.tenantID**). This data can include any type of sensitive data such as passwords, database connection strings, API keys, and the like. AKV stores this information as encrypted binary data.
        """
        subscription_id: NotRequired[pulumi.Input[str]]
        """
        Unique 36-hexadecimal character string that identifies your Azure subscription.
        """
        tenant_id: NotRequired[pulumi.Input[str]]
        """
        Unique 36-hexadecimal character string that identifies the Azure Active Directory tenant within your Azure subscription.
        """
        valid: NotRequired[pulumi.Input[bool]]
        """
        Flag that indicates whether the Azure encryption key can encrypt and decrypt data.
        """
elif False:
    EncryptionAtRestAzureKeyVaultConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EncryptionAtRestAzureKeyVaultConfigArgs:
    def __init__(__self__, *,
                 azure_environment: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 key_identifier: Optional[pulumi.Input[str]] = None,
                 key_vault_name: Optional[pulumi.Input[str]] = None,
                 require_private_networking: Optional[pulumi.Input[bool]] = None,
                 resource_group_name: Optional[pulumi.Input[str]] = None,
                 secret: Optional[pulumi.Input[str]] = None,
                 subscription_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None,
                 valid: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] azure_environment: Azure environment in which your account credentials reside.
        :param pulumi.Input[str] client_id: Unique 36-hexadecimal character string that identifies an Azure application associated with your Azure Active Directory tenant.
        :param pulumi.Input[bool] enabled: Flag that indicates whether someone enabled encryption at rest for the specified  project. To disable encryption at rest using customer key management and remove the configuration details, pass only this parameter with a value of `false`.
        :param pulumi.Input[str] key_identifier: Web address with a unique key that identifies for your Azure Key Vault.
        :param pulumi.Input[str] key_vault_name: Unique string that identifies the Azure Key Vault that contains your key.
        :param pulumi.Input[bool] require_private_networking: Enable connection to your Azure Key Vault over private networking.
        :param pulumi.Input[str] resource_group_name: Name of the Azure resource group that contains your Azure Key Vault.
        :param pulumi.Input[str] secret: Private data that you need secured and that belongs to the specified Azure Key Vault (AKV) tenant (**azureKeyVault.tenantID**). This data can include any type of sensitive data such as passwords, database connection strings, API keys, and the like. AKV stores this information as encrypted binary data.
        :param pulumi.Input[str] subscription_id: Unique 36-hexadecimal character string that identifies your Azure subscription.
        :param pulumi.Input[str] tenant_id: Unique 36-hexadecimal character string that identifies the Azure Active Directory tenant within your Azure subscription.
        :param pulumi.Input[bool] valid: Flag that indicates whether the Azure encryption key can encrypt and decrypt data.
        """
        if azure_environment is not None:
            pulumi.set(__self__, "azure_environment", azure_environment)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if key_identifier is not None:
            pulumi.set(__self__, "key_identifier", key_identifier)
        if key_vault_name is not None:
            pulumi.set(__self__, "key_vault_name", key_vault_name)
        if require_private_networking is not None:
            pulumi.set(__self__, "require_private_networking", require_private_networking)
        if resource_group_name is not None:
            pulumi.set(__self__, "resource_group_name", resource_group_name)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if valid is not None:
            pulumi.set(__self__, "valid", valid)

    @property
    @pulumi.getter(name="azureEnvironment")
    def azure_environment(self) -> Optional[pulumi.Input[str]]:
        """
        Azure environment in which your account credentials reside.
        """
        return pulumi.get(self, "azure_environment")

    @azure_environment.setter
    def azure_environment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "azure_environment", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique 36-hexadecimal character string that identifies an Azure application associated with your Azure Active Directory tenant.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag that indicates whether someone enabled encryption at rest for the specified  project. To disable encryption at rest using customer key management and remove the configuration details, pass only this parameter with a value of `false`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="keyIdentifier")
    def key_identifier(self) -> Optional[pulumi.Input[str]]:
        """
        Web address with a unique key that identifies for your Azure Key Vault.
        """
        return pulumi.get(self, "key_identifier")

    @key_identifier.setter
    def key_identifier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_identifier", value)

    @property
    @pulumi.getter(name="keyVaultName")
    def key_vault_name(self) -> Optional[pulumi.Input[str]]:
        """
        Unique string that identifies the Azure Key Vault that contains your key.
        """
        return pulumi.get(self, "key_vault_name")

    @key_vault_name.setter
    def key_vault_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_vault_name", value)

    @property
    @pulumi.getter(name="requirePrivateNetworking")
    def require_private_networking(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable connection to your Azure Key Vault over private networking.
        """
        return pulumi.get(self, "require_private_networking")

    @require_private_networking.setter
    def require_private_networking(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_private_networking", value)

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Azure resource group that contains your Azure Key Vault.
        """
        return pulumi.get(self, "resource_group_name")

    @resource_group_name.setter
    def resource_group_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_group_name", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[str]]:
        """
        Private data that you need secured and that belongs to the specified Azure Key Vault (AKV) tenant (**azureKeyVault.tenantID**). This data can include any type of sensitive data such as passwords, database connection strings, API keys, and the like. AKV stores this information as encrypted binary data.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique 36-hexadecimal character string that identifies your Azure subscription.
        """
        return pulumi.get(self, "subscription_id")

    @subscription_id.setter
    def subscription_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subscription_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique 36-hexadecimal character string that identifies the Azure Active Directory tenant within your Azure subscription.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)

    @property
    @pulumi.getter
    def valid(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag that indicates whether the Azure encryption key can encrypt and decrypt data.
        """
        return pulumi.get(self, "valid")

    @valid.setter
    def valid(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "valid", value)


if not MYPY:
    class EncryptionAtRestGoogleCloudKmsConfigArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Flag that indicates whether someone enabled encryption at rest for the specified  project. To disable encryption at rest using customer key management and remove the configuration details, pass only this parameter with a value of `false`.
        """
        key_version_resource_id: NotRequired[pulumi.Input[str]]
        """
        Resource path that displays the key version resource ID for your Google Cloud KMS.
        """
        service_account_key: NotRequired[pulumi.Input[str]]
        """
        JavaScript Object Notation (JSON) object that contains the Google Cloud Key Management Service (KMS). Format the JSON as a string and not as an object.
        """
        valid: NotRequired[pulumi.Input[bool]]
        """
        Flag that indicates whether the Google Cloud Key Management Service (KMS) encryption key can encrypt and decrypt data.
        """
elif False:
    EncryptionAtRestGoogleCloudKmsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EncryptionAtRestGoogleCloudKmsConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 key_version_resource_id: Optional[pulumi.Input[str]] = None,
                 service_account_key: Optional[pulumi.Input[str]] = None,
                 valid: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Flag that indicates whether someone enabled encryption at rest for the specified  project. To disable encryption at rest using customer key management and remove the configuration details, pass only this parameter with a value of `false`.
        :param pulumi.Input[str] key_version_resource_id: Resource path that displays the key version resource ID for your Google Cloud KMS.
        :param pulumi.Input[str] service_account_key: JavaScript Object Notation (JSON) object that contains the Google Cloud Key Management Service (KMS). Format the JSON as a string and not as an object.
        :param pulumi.Input[bool] valid: Flag that indicates whether the Google Cloud Key Management Service (KMS) encryption key can encrypt and decrypt data.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if key_version_resource_id is not None:
            pulumi.set(__self__, "key_version_resource_id", key_version_resource_id)
        if service_account_key is not None:
            pulumi.set(__self__, "service_account_key", service_account_key)
        if valid is not None:
            pulumi.set(__self__, "valid", valid)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag that indicates whether someone enabled encryption at rest for the specified  project. To disable encryption at rest using customer key management and remove the configuration details, pass only this parameter with a value of `false`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="keyVersionResourceId")
    def key_version_resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        Resource path that displays the key version resource ID for your Google Cloud KMS.
        """
        return pulumi.get(self, "key_version_resource_id")

    @key_version_resource_id.setter
    def key_version_resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_version_resource_id", value)

    @property
    @pulumi.getter(name="serviceAccountKey")
    def service_account_key(self) -> Optional[pulumi.Input[str]]:
        """
        JavaScript Object Notation (JSON) object that contains the Google Cloud Key Management Service (KMS). Format the JSON as a string and not as an object.
        """
        return pulumi.get(self, "service_account_key")

    @service_account_key.setter
    def service_account_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_account_key", value)

    @property
    @pulumi.getter
    def valid(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag that indicates whether the Google Cloud Key Management Service (KMS) encryption key can encrypt and decrypt data.
        """
        return pulumi.get(self, "valid")

    @valid.setter
    def valid(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "valid", value)


if not MYPY:
    class EventTriggerEventProcessorsArgsDict(TypedDict):
        aws_eventbridge: NotRequired[pulumi.Input['EventTriggerEventProcessorsAwsEventbridgeArgsDict']]
elif False:
    EventTriggerEventProcessorsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTriggerEventProcessorsArgs:
    def __init__(__self__, *,
                 aws_eventbridge: Optional[pulumi.Input['EventTriggerEventProcessorsAwsEventbridgeArgs']] = None):
        if aws_eventbridge is not None:
            pulumi.set(__self__, "aws_eventbridge", aws_eventbridge)

    @property
    @pulumi.getter(name="awsEventbridge")
    def aws_eventbridge(self) -> Optional[pulumi.Input['EventTriggerEventProcessorsAwsEventbridgeArgs']]:
        return pulumi.get(self, "aws_eventbridge")

    @aws_eventbridge.setter
    def aws_eventbridge(self, value: Optional[pulumi.Input['EventTriggerEventProcessorsAwsEventbridgeArgs']]):
        pulumi.set(self, "aws_eventbridge", value)


if not MYPY:
    class EventTriggerEventProcessorsAwsEventbridgeArgsDict(TypedDict):
        config_account_id: NotRequired[pulumi.Input[str]]
        config_region: NotRequired[pulumi.Input[str]]
elif False:
    EventTriggerEventProcessorsAwsEventbridgeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventTriggerEventProcessorsAwsEventbridgeArgs:
    def __init__(__self__, *,
                 config_account_id: Optional[pulumi.Input[str]] = None,
                 config_region: Optional[pulumi.Input[str]] = None):
        if config_account_id is not None:
            pulumi.set(__self__, "config_account_id", config_account_id)
        if config_region is not None:
            pulumi.set(__self__, "config_region", config_region)

    @property
    @pulumi.getter(name="configAccountId")
    def config_account_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "config_account_id")

    @config_account_id.setter
    def config_account_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_account_id", value)

    @property
    @pulumi.getter(name="configRegion")
    def config_region(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "config_region")

    @config_region.setter
    def config_region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_region", value)


if not MYPY:
    class FederatedDatabaseInstanceCloudProviderConfigArgsDict(TypedDict):
        aws: pulumi.Input['FederatedDatabaseInstanceCloudProviderConfigAwsArgsDict']
        """
        Name of the cloud service that hosts the data lake's data stores.
        """
elif False:
    FederatedDatabaseInstanceCloudProviderConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedDatabaseInstanceCloudProviderConfigArgs:
    def __init__(__self__, *,
                 aws: pulumi.Input['FederatedDatabaseInstanceCloudProviderConfigAwsArgs']):
        """
        :param pulumi.Input['FederatedDatabaseInstanceCloudProviderConfigAwsArgs'] aws: Name of the cloud service that hosts the data lake's data stores.
        """
        pulumi.set(__self__, "aws", aws)

    @property
    @pulumi.getter
    def aws(self) -> pulumi.Input['FederatedDatabaseInstanceCloudProviderConfigAwsArgs']:
        """
        Name of the cloud service that hosts the data lake's data stores.
        """
        return pulumi.get(self, "aws")

    @aws.setter
    def aws(self, value: pulumi.Input['FederatedDatabaseInstanceCloudProviderConfigAwsArgs']):
        pulumi.set(self, "aws", value)


if not MYPY:
    class FederatedDatabaseInstanceCloudProviderConfigAwsArgsDict(TypedDict):
        role_id: pulumi.Input[str]
        test_s3_bucket: pulumi.Input[str]
        external_id: NotRequired[pulumi.Input[str]]
        """
        Unique identifier associated with the IAM Role that the Federated Database Instance assumes when accessing the data stores.
        """
        iam_assumed_role_arn: NotRequired[pulumi.Input[str]]
        """
        Amazon Resource Name (ARN) of the IAM Role that the Federated Database Instance assumes when accessing S3 Bucket data stores. The IAM Role must support the following actions against each S3 bucket:
        * `s3:GetObject`
        * `s3:ListBucket`
        * `s3:GetObjectVersion`
        """
        iam_user_arn: NotRequired[pulumi.Input[str]]
        """
        Amazon Resource Name (ARN) of the user that the Federated Database Instance assumes when accessing S3 Bucket data stores.
        """
elif False:
    FederatedDatabaseInstanceCloudProviderConfigAwsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedDatabaseInstanceCloudProviderConfigAwsArgs:
    def __init__(__self__, *,
                 role_id: pulumi.Input[str],
                 test_s3_bucket: pulumi.Input[str],
                 external_id: Optional[pulumi.Input[str]] = None,
                 iam_assumed_role_arn: Optional[pulumi.Input[str]] = None,
                 iam_user_arn: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] external_id: Unique identifier associated with the IAM Role that the Federated Database Instance assumes when accessing the data stores.
        :param pulumi.Input[str] iam_assumed_role_arn: Amazon Resource Name (ARN) of the IAM Role that the Federated Database Instance assumes when accessing S3 Bucket data stores. The IAM Role must support the following actions against each S3 bucket:
               * `s3:GetObject`
               * `s3:ListBucket`
               * `s3:GetObjectVersion`
        :param pulumi.Input[str] iam_user_arn: Amazon Resource Name (ARN) of the user that the Federated Database Instance assumes when accessing S3 Bucket data stores.
        """
        pulumi.set(__self__, "role_id", role_id)
        pulumi.set(__self__, "test_s3_bucket", test_s3_bucket)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if iam_assumed_role_arn is not None:
            pulumi.set(__self__, "iam_assumed_role_arn", iam_assumed_role_arn)
        if iam_user_arn is not None:
            pulumi.set(__self__, "iam_user_arn", iam_user_arn)

    @property
    @pulumi.getter(name="roleId")
    def role_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "role_id")

    @role_id.setter
    def role_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_id", value)

    @property
    @pulumi.getter(name="testS3Bucket")
    def test_s3_bucket(self) -> pulumi.Input[str]:
        return pulumi.get(self, "test_s3_bucket")

    @test_s3_bucket.setter
    def test_s3_bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "test_s3_bucket", value)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier associated with the IAM Role that the Federated Database Instance assumes when accessing the data stores.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "external_id", value)

    @property
    @pulumi.getter(name="iamAssumedRoleArn")
    def iam_assumed_role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        Amazon Resource Name (ARN) of the IAM Role that the Federated Database Instance assumes when accessing S3 Bucket data stores. The IAM Role must support the following actions against each S3 bucket:
        * `s3:GetObject`
        * `s3:ListBucket`
        * `s3:GetObjectVersion`
        """
        return pulumi.get(self, "iam_assumed_role_arn")

    @iam_assumed_role_arn.setter
    def iam_assumed_role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "iam_assumed_role_arn", value)

    @property
    @pulumi.getter(name="iamUserArn")
    def iam_user_arn(self) -> Optional[pulumi.Input[str]]:
        """
        Amazon Resource Name (ARN) of the user that the Federated Database Instance assumes when accessing S3 Bucket data stores.
        """
        return pulumi.get(self, "iam_user_arn")

    @iam_user_arn.setter
    def iam_user_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "iam_user_arn", value)


if not MYPY:
    class FederatedDatabaseInstanceDataProcessRegionArgsDict(TypedDict):
        cloud_provider: pulumi.Input[str]
        region: pulumi.Input[str]
elif False:
    FederatedDatabaseInstanceDataProcessRegionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedDatabaseInstanceDataProcessRegionArgs:
    def __init__(__self__, *,
                 cloud_provider: pulumi.Input[str],
                 region: pulumi.Input[str]):
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> pulumi.Input[str]:
        return pulumi.get(self, "cloud_provider")

    @cloud_provider.setter
    def cloud_provider(self, value: pulumi.Input[str]):
        pulumi.set(self, "cloud_provider", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)


if not MYPY:
    class FederatedDatabaseInstanceStorageDatabaseArgsDict(TypedDict):
        collections: NotRequired[pulumi.Input[Sequence[pulumi.Input['FederatedDatabaseInstanceStorageDatabaseCollectionArgsDict']]]]
        max_wildcard_collections: NotRequired[pulumi.Input[int]]
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the Atlas Federated Database Instance.
        """
        views: NotRequired[pulumi.Input[Sequence[pulumi.Input['FederatedDatabaseInstanceStorageDatabaseViewArgsDict']]]]
elif False:
    FederatedDatabaseInstanceStorageDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedDatabaseInstanceStorageDatabaseArgs:
    def __init__(__self__, *,
                 collections: Optional[pulumi.Input[Sequence[pulumi.Input['FederatedDatabaseInstanceStorageDatabaseCollectionArgs']]]] = None,
                 max_wildcard_collections: Optional[pulumi.Input[int]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 views: Optional[pulumi.Input[Sequence[pulumi.Input['FederatedDatabaseInstanceStorageDatabaseViewArgs']]]] = None):
        """
        :param pulumi.Input[str] name: Name of the Atlas Federated Database Instance.
        """
        if collections is not None:
            pulumi.set(__self__, "collections", collections)
        if max_wildcard_collections is not None:
            pulumi.set(__self__, "max_wildcard_collections", max_wildcard_collections)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if views is not None:
            pulumi.set(__self__, "views", views)

    @property
    @pulumi.getter
    def collections(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FederatedDatabaseInstanceStorageDatabaseCollectionArgs']]]]:
        return pulumi.get(self, "collections")

    @collections.setter
    def collections(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FederatedDatabaseInstanceStorageDatabaseCollectionArgs']]]]):
        pulumi.set(self, "collections", value)

    @property
    @pulumi.getter(name="maxWildcardCollections")
    def max_wildcard_collections(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_wildcard_collections")

    @max_wildcard_collections.setter
    def max_wildcard_collections(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_wildcard_collections", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Atlas Federated Database Instance.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def views(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FederatedDatabaseInstanceStorageDatabaseViewArgs']]]]:
        return pulumi.get(self, "views")

    @views.setter
    def views(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FederatedDatabaseInstanceStorageDatabaseViewArgs']]]]):
        pulumi.set(self, "views", value)


if not MYPY:
    class FederatedDatabaseInstanceStorageDatabaseCollectionArgsDict(TypedDict):
        data_sources: NotRequired[pulumi.Input[Sequence[pulumi.Input['FederatedDatabaseInstanceStorageDatabaseCollectionDataSourceArgsDict']]]]
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the Atlas Federated Database Instance.
        """
elif False:
    FederatedDatabaseInstanceStorageDatabaseCollectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedDatabaseInstanceStorageDatabaseCollectionArgs:
    def __init__(__self__, *,
                 data_sources: Optional[pulumi.Input[Sequence[pulumi.Input['FederatedDatabaseInstanceStorageDatabaseCollectionDataSourceArgs']]]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the Atlas Federated Database Instance.
        """
        if data_sources is not None:
            pulumi.set(__self__, "data_sources", data_sources)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="dataSources")
    def data_sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FederatedDatabaseInstanceStorageDatabaseCollectionDataSourceArgs']]]]:
        return pulumi.get(self, "data_sources")

    @data_sources.setter
    def data_sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FederatedDatabaseInstanceStorageDatabaseCollectionDataSourceArgs']]]]):
        pulumi.set(self, "data_sources", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Atlas Federated Database Instance.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class FederatedDatabaseInstanceStorageDatabaseCollectionDataSourceArgsDict(TypedDict):
        allow_insecure: NotRequired[pulumi.Input[bool]]
        collection: NotRequired[pulumi.Input[str]]
        collection_regex: NotRequired[pulumi.Input[str]]
        database: NotRequired[pulumi.Input[str]]
        database_regex: NotRequired[pulumi.Input[str]]
        dataset_name: NotRequired[pulumi.Input[str]]
        default_format: NotRequired[pulumi.Input[str]]
        path: NotRequired[pulumi.Input[str]]
        provenance_field_name: NotRequired[pulumi.Input[str]]
        store_name: NotRequired[pulumi.Input[str]]
        urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    FederatedDatabaseInstanceStorageDatabaseCollectionDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedDatabaseInstanceStorageDatabaseCollectionDataSourceArgs:
    def __init__(__self__, *,
                 allow_insecure: Optional[pulumi.Input[bool]] = None,
                 collection: Optional[pulumi.Input[str]] = None,
                 collection_regex: Optional[pulumi.Input[str]] = None,
                 database: Optional[pulumi.Input[str]] = None,
                 database_regex: Optional[pulumi.Input[str]] = None,
                 dataset_name: Optional[pulumi.Input[str]] = None,
                 default_format: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 provenance_field_name: Optional[pulumi.Input[str]] = None,
                 store_name: Optional[pulumi.Input[str]] = None,
                 urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if allow_insecure is not None:
            pulumi.set(__self__, "allow_insecure", allow_insecure)
        if collection is not None:
            pulumi.set(__self__, "collection", collection)
        if collection_regex is not None:
            pulumi.set(__self__, "collection_regex", collection_regex)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if database_regex is not None:
            pulumi.set(__self__, "database_regex", database_regex)
        if dataset_name is not None:
            pulumi.set(__self__, "dataset_name", dataset_name)
        if default_format is not None:
            pulumi.set(__self__, "default_format", default_format)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if provenance_field_name is not None:
            pulumi.set(__self__, "provenance_field_name", provenance_field_name)
        if store_name is not None:
            pulumi.set(__self__, "store_name", store_name)
        if urls is not None:
            pulumi.set(__self__, "urls", urls)

    @property
    @pulumi.getter(name="allowInsecure")
    def allow_insecure(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "allow_insecure")

    @allow_insecure.setter
    def allow_insecure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_insecure", value)

    @property
    @pulumi.getter
    def collection(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "collection")

    @collection.setter
    def collection(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "collection", value)

    @property
    @pulumi.getter(name="collectionRegex")
    def collection_regex(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "collection_regex")

    @collection_regex.setter
    def collection_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "collection_regex", value)

    @property
    @pulumi.getter
    def database(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter(name="databaseRegex")
    def database_regex(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "database_regex")

    @database_regex.setter
    def database_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_regex", value)

    @property
    @pulumi.getter(name="datasetName")
    def dataset_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "dataset_name")

    @dataset_name.setter
    def dataset_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dataset_name", value)

    @property
    @pulumi.getter(name="defaultFormat")
    def default_format(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "default_format")

    @default_format.setter
    def default_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_format", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="provenanceFieldName")
    def provenance_field_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "provenance_field_name")

    @provenance_field_name.setter
    def provenance_field_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "provenance_field_name", value)

    @property
    @pulumi.getter(name="storeName")
    def store_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "store_name")

    @store_name.setter
    def store_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "store_name", value)

    @property
    @pulumi.getter
    def urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "urls")

    @urls.setter
    def urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "urls", value)


if not MYPY:
    class FederatedDatabaseInstanceStorageDatabaseViewArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the Atlas Federated Database Instance.
        """
        pipeline: NotRequired[pulumi.Input[str]]
        source: NotRequired[pulumi.Input[str]]
elif False:
    FederatedDatabaseInstanceStorageDatabaseViewArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedDatabaseInstanceStorageDatabaseViewArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 pipeline: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the Atlas Federated Database Instance.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if pipeline is not None:
            pulumi.set(__self__, "pipeline", pipeline)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Atlas Federated Database Instance.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def pipeline(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pipeline")

    @pipeline.setter
    def pipeline(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pipeline", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class FederatedDatabaseInstanceStorageStoreArgsDict(TypedDict):
        additional_storage_classes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        allow_insecure: NotRequired[pulumi.Input[bool]]
        bucket: NotRequired[pulumi.Input[str]]
        cluster_name: NotRequired[pulumi.Input[str]]
        default_format: NotRequired[pulumi.Input[str]]
        delimiter: NotRequired[pulumi.Input[str]]
        include_tags: NotRequired[pulumi.Input[bool]]
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the Atlas Federated Database Instance.
        """
        prefix: NotRequired[pulumi.Input[str]]
        project_id: NotRequired[pulumi.Input[str]]
        """
        The unique ID for the project to create a Federated Database Instance.
        """
        provider: NotRequired[pulumi.Input[str]]
        public: NotRequired[pulumi.Input[str]]
        read_preference: NotRequired[pulumi.Input['FederatedDatabaseInstanceStorageStoreReadPreferenceArgsDict']]
        region: NotRequired[pulumi.Input[str]]
        urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    FederatedDatabaseInstanceStorageStoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedDatabaseInstanceStorageStoreArgs:
    def __init__(__self__, *,
                 additional_storage_classes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allow_insecure: Optional[pulumi.Input[bool]] = None,
                 bucket: Optional[pulumi.Input[str]] = None,
                 cluster_name: Optional[pulumi.Input[str]] = None,
                 default_format: Optional[pulumi.Input[str]] = None,
                 delimiter: Optional[pulumi.Input[str]] = None,
                 include_tags: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 prefix: Optional[pulumi.Input[str]] = None,
                 project_id: Optional[pulumi.Input[str]] = None,
                 provider: Optional[pulumi.Input[str]] = None,
                 public: Optional[pulumi.Input[str]] = None,
                 read_preference: Optional[pulumi.Input['FederatedDatabaseInstanceStorageStoreReadPreferenceArgs']] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: Name of the Atlas Federated Database Instance.
        :param pulumi.Input[str] project_id: The unique ID for the project to create a Federated Database Instance.
        """
        if additional_storage_classes is not None:
            pulumi.set(__self__, "additional_storage_classes", additional_storage_classes)
        if allow_insecure is not None:
            pulumi.set(__self__, "allow_insecure", allow_insecure)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if default_format is not None:
            pulumi.set(__self__, "default_format", default_format)
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if include_tags is not None:
            pulumi.set(__self__, "include_tags", include_tags)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if public is not None:
            pulumi.set(__self__, "public", public)
        if read_preference is not None:
            pulumi.set(__self__, "read_preference", read_preference)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if urls is not None:
            pulumi.set(__self__, "urls", urls)

    @property
    @pulumi.getter(name="additionalStorageClasses")
    def additional_storage_classes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "additional_storage_classes")

    @additional_storage_classes.setter
    def additional_storage_classes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "additional_storage_classes", value)

    @property
    @pulumi.getter(name="allowInsecure")
    def allow_insecure(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "allow_insecure")

    @allow_insecure.setter
    def allow_insecure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_insecure", value)

    @property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="defaultFormat")
    def default_format(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "default_format")

    @default_format.setter
    def default_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_format", value)

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delimiter", value)

    @property
    @pulumi.getter(name="includeTags")
    def include_tags(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "include_tags")

    @include_tags.setter
    def include_tags(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_tags", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Atlas Federated Database Instance.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique ID for the project to create a Federated Database Instance.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter
    def provider(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "provider", value)

    @property
    @pulumi.getter
    def public(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "public")

    @public.setter
    def public(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "public", value)

    @property
    @pulumi.getter(name="readPreference")
    def read_preference(self) -> Optional[pulumi.Input['FederatedDatabaseInstanceStorageStoreReadPreferenceArgs']]:
        return pulumi.get(self, "read_preference")

    @read_preference.setter
    def read_preference(self, value: Optional[pulumi.Input['FederatedDatabaseInstanceStorageStoreReadPreferenceArgs']]):
        pulumi.set(self, "read_preference", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter
    def urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "urls")

    @urls.setter
    def urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "urls", value)


if not MYPY:
    class FederatedDatabaseInstanceStorageStoreReadPreferenceArgsDict(TypedDict):
        max_staleness_seconds: NotRequired[pulumi.Input[int]]
        mode: NotRequired[pulumi.Input[str]]
        tag_sets: NotRequired[pulumi.Input[Sequence[pulumi.Input['FederatedDatabaseInstanceStorageStoreReadPreferenceTagSetArgsDict']]]]
elif False:
    FederatedDatabaseInstanceStorageStoreReadPreferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedDatabaseInstanceStorageStoreReadPreferenceArgs:
    def __init__(__self__, *,
                 max_staleness_seconds: Optional[pulumi.Input[int]] = None,
                 mode: Optional[pulumi.Input[str]] = None,
                 tag_sets: Optional[pulumi.Input[Sequence[pulumi.Input['FederatedDatabaseInstanceStorageStoreReadPreferenceTagSetArgs']]]] = None):
        if max_staleness_seconds is not None:
            pulumi.set(__self__, "max_staleness_seconds", max_staleness_seconds)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if tag_sets is not None:
            pulumi.set(__self__, "tag_sets", tag_sets)

    @property
    @pulumi.getter(name="maxStalenessSeconds")
    def max_staleness_seconds(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_staleness_seconds")

    @max_staleness_seconds.setter
    def max_staleness_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_staleness_seconds", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="tagSets")
    def tag_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FederatedDatabaseInstanceStorageStoreReadPreferenceTagSetArgs']]]]:
        return pulumi.get(self, "tag_sets")

    @tag_sets.setter
    def tag_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FederatedDatabaseInstanceStorageStoreReadPreferenceTagSetArgs']]]]):
        pulumi.set(self, "tag_sets", value)


if not MYPY:
    class FederatedDatabaseInstanceStorageStoreReadPreferenceTagSetArgsDict(TypedDict):
        tags: pulumi.Input[Sequence[pulumi.Input['FederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTagArgsDict']]]
elif False:
    FederatedDatabaseInstanceStorageStoreReadPreferenceTagSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedDatabaseInstanceStorageStoreReadPreferenceTagSetArgs:
    def __init__(__self__, *,
                 tags: pulumi.Input[Sequence[pulumi.Input['FederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTagArgs']]]):
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def tags(self) -> pulumi.Input[Sequence[pulumi.Input['FederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTagArgs']]]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: pulumi.Input[Sequence[pulumi.Input['FederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTagArgs']]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class FederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTagArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the Atlas Federated Database Instance.
        """
        value: NotRequired[pulumi.Input[str]]
elif False:
    FederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTagArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the Atlas Federated Database Instance.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Atlas Federated Database Instance.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FederatedSettingsOrgConfigUserConflictArgsDict(TypedDict):
        email_address: NotRequired[pulumi.Input[str]]
        """
        Email address of the the user that conflicts with selected domains.
        """
        federation_settings_id: NotRequired[pulumi.Input[str]]
        """
        Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        """
        first_name: NotRequired[pulumi.Input[str]]
        """
        First name of the the user that conflicts with selected domains.
        """
        last_name: NotRequired[pulumi.Input[str]]
        """
        Last name of the the user that conflicts with selected domains.
        """
        user_id: NotRequired[pulumi.Input[str]]
        """
        Name of the Atlas user that conflicts with selected domains.
        """
elif False:
    FederatedSettingsOrgConfigUserConflictArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedSettingsOrgConfigUserConflictArgs:
    def __init__(__self__, *,
                 email_address: Optional[pulumi.Input[str]] = None,
                 federation_settings_id: Optional[pulumi.Input[str]] = None,
                 first_name: Optional[pulumi.Input[str]] = None,
                 last_name: Optional[pulumi.Input[str]] = None,
                 user_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] email_address: Email address of the the user that conflicts with selected domains.
        :param pulumi.Input[str] federation_settings_id: Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        :param pulumi.Input[str] first_name: First name of the the user that conflicts with selected domains.
        :param pulumi.Input[str] last_name: Last name of the the user that conflicts with selected domains.
        :param pulumi.Input[str] user_id: Name of the Atlas user that conflicts with selected domains.
        """
        if email_address is not None:
            pulumi.set(__self__, "email_address", email_address)
        if federation_settings_id is not None:
            pulumi.set(__self__, "federation_settings_id", federation_settings_id)
        if first_name is not None:
            pulumi.set(__self__, "first_name", first_name)
        if last_name is not None:
            pulumi.set(__self__, "last_name", last_name)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> Optional[pulumi.Input[str]]:
        """
        Email address of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "email_address")

    @email_address.setter
    def email_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_address", value)

    @property
    @pulumi.getter(name="federationSettingsId")
    def federation_settings_id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        """
        return pulumi.get(self, "federation_settings_id")

    @federation_settings_id.setter
    def federation_settings_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "federation_settings_id", value)

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> Optional[pulumi.Input[str]]:
        """
        First name of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "first_name")

    @first_name.setter
    def first_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "first_name", value)

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> Optional[pulumi.Input[str]]:
        """
        Last name of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "last_name")

    @last_name.setter
    def last_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_name", value)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Atlas user that conflicts with selected domains.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_id", value)


if not MYPY:
    class FederatedSettingsOrgRoleMappingRoleAssignmentArgsDict(TypedDict):
        group_id: NotRequired[pulumi.Input[str]]
        """
        Unique identifier of the project to which you want the role mapping to apply.
        """
        org_id: NotRequired[pulumi.Input[str]]
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        """
        roles: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies the Roles that are attached to the Role Mapping. Available role IDs can be found on [the User Roles
        Reference](https://www.mongodb.com/docs/atlas/reference/user-roles/).
        """
elif False:
    FederatedSettingsOrgRoleMappingRoleAssignmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedSettingsOrgRoleMappingRoleAssignmentArgs:
    def __init__(__self__, *,
                 group_id: Optional[pulumi.Input[str]] = None,
                 org_id: Optional[pulumi.Input[str]] = None,
                 roles: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] group_id: Unique identifier of the project to which you want the role mapping to apply.
        :param pulumi.Input[str] org_id: Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] roles: Specifies the Roles that are attached to the Role Mapping. Available role IDs can be found on [the User Roles
               Reference](https://www.mongodb.com/docs/atlas/reference/user-roles/).
        """
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if org_id is not None:
            pulumi.set(__self__, "org_id", org_id)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier of the project to which you want the role mapping to apply.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        """
        return pulumi.get(self, "org_id")

    @org_id.setter
    def org_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "org_id", value)

    @property
    @pulumi.getter
    def roles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies the Roles that are attached to the Role Mapping. Available role IDs can be found on [the User Roles
        Reference](https://www.mongodb.com/docs/atlas/reference/user-roles/).
        """
        return pulumi.get(self, "roles")

    @roles.setter
    def roles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "roles", value)


if not MYPY:
    class GlobalClusterConfigCustomZoneMappingArgsDict(TypedDict):
        location: NotRequired[pulumi.Input[str]]
        """
        The ISO location code to which you want to map a zone in your Global Cluster. You can find a list of all supported location codes [here](https://cloud.mongodb.com/static/atlas/country_iso_codes.txt).
        """
        zone: NotRequired[pulumi.Input[str]]
        """
        The name of the zone in your Global Cluster that you want to map to location.
        """
elif False:
    GlobalClusterConfigCustomZoneMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GlobalClusterConfigCustomZoneMappingArgs:
    def __init__(__self__, *,
                 location: Optional[pulumi.Input[str]] = None,
                 zone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] location: The ISO location code to which you want to map a zone in your Global Cluster. You can find a list of all supported location codes [here](https://cloud.mongodb.com/static/atlas/country_iso_codes.txt).
        :param pulumi.Input[str] zone: The name of the zone in your Global Cluster that you want to map to location.
        """
        if location is not None:
            pulumi.set(__self__, "location", location)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[str]]:
        """
        The ISO location code to which you want to map a zone in your Global Cluster. You can find a list of all supported location codes [here](https://cloud.mongodb.com/static/atlas/country_iso_codes.txt).
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def zone(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the zone in your Global Cluster that you want to map to location.
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone", value)


if not MYPY:
    class GlobalClusterConfigManagedNamespaceArgsDict(TypedDict):
        collection: pulumi.Input[str]
        """
        The name of the collection associated with the managed namespace.
        """
        custom_shard_key: pulumi.Input[str]
        """
        The custom shard key for the collection. Global Clusters require a compound shard key consisting of a location field and a user-selected second key, the custom shard key.
        """
        db: pulumi.Input[str]
        """
        The name of the database containing the collection.
        """
        is_custom_shard_key_hashed: NotRequired[pulumi.Input[bool]]
        """
        Specifies whether the custom shard key for the collection is [hashed](https://docs.mongodb.com/manual/reference/method/sh.shardCollection/#hashed-shard-keys). If omitted, defaults to `false`. If `false`, Atlas uses [ranged sharding](https://docs.mongodb.com/manual/core/ranged-sharding/). This is only available for Atlas clusters with MongoDB v4.4 and later.
        """
        is_shard_key_unique: NotRequired[pulumi.Input[bool]]
        """
        Specifies whether the underlying index enforces a unique constraint. If omitted, defaults to false. You cannot specify true when using [hashed shard keys](https://docs.mongodb.com/manual/core/hashed-sharding/#std-label-sharding-hashed).
        """
elif False:
    GlobalClusterConfigManagedNamespaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GlobalClusterConfigManagedNamespaceArgs:
    def __init__(__self__, *,
                 collection: pulumi.Input[str],
                 custom_shard_key: pulumi.Input[str],
                 db: pulumi.Input[str],
                 is_custom_shard_key_hashed: Optional[pulumi.Input[bool]] = None,
                 is_shard_key_unique: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] collection: The name of the collection associated with the managed namespace.
        :param pulumi.Input[str] custom_shard_key: The custom shard key for the collection. Global Clusters require a compound shard key consisting of a location field and a user-selected second key, the custom shard key.
        :param pulumi.Input[str] db: The name of the database containing the collection.
        :param pulumi.Input[bool] is_custom_shard_key_hashed: Specifies whether the custom shard key for the collection is [hashed](https://docs.mongodb.com/manual/reference/method/sh.shardCollection/#hashed-shard-keys). If omitted, defaults to `false`. If `false`, Atlas uses [ranged sharding](https://docs.mongodb.com/manual/core/ranged-sharding/). This is only available for Atlas clusters with MongoDB v4.4 and later.
        :param pulumi.Input[bool] is_shard_key_unique: Specifies whether the underlying index enforces a unique constraint. If omitted, defaults to false. You cannot specify true when using [hashed shard keys](https://docs.mongodb.com/manual/core/hashed-sharding/#std-label-sharding-hashed).
        """
        pulumi.set(__self__, "collection", collection)
        pulumi.set(__self__, "custom_shard_key", custom_shard_key)
        pulumi.set(__self__, "db", db)
        if is_custom_shard_key_hashed is not None:
            pulumi.set(__self__, "is_custom_shard_key_hashed", is_custom_shard_key_hashed)
        if is_shard_key_unique is not None:
            pulumi.set(__self__, "is_shard_key_unique", is_shard_key_unique)

    @property
    @pulumi.getter
    def collection(self) -> pulumi.Input[str]:
        """
        The name of the collection associated with the managed namespace.
        """
        return pulumi.get(self, "collection")

    @collection.setter
    def collection(self, value: pulumi.Input[str]):
        pulumi.set(self, "collection", value)

    @property
    @pulumi.getter(name="customShardKey")
    def custom_shard_key(self) -> pulumi.Input[str]:
        """
        The custom shard key for the collection. Global Clusters require a compound shard key consisting of a location field and a user-selected second key, the custom shard key.
        """
        return pulumi.get(self, "custom_shard_key")

    @custom_shard_key.setter
    def custom_shard_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "custom_shard_key", value)

    @property
    @pulumi.getter
    def db(self) -> pulumi.Input[str]:
        """
        The name of the database containing the collection.
        """
        return pulumi.get(self, "db")

    @db.setter
    def db(self, value: pulumi.Input[str]):
        pulumi.set(self, "db", value)

    @property
    @pulumi.getter(name="isCustomShardKeyHashed")
    def is_custom_shard_key_hashed(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether the custom shard key for the collection is [hashed](https://docs.mongodb.com/manual/reference/method/sh.shardCollection/#hashed-shard-keys). If omitted, defaults to `false`. If `false`, Atlas uses [ranged sharding](https://docs.mongodb.com/manual/core/ranged-sharding/). This is only available for Atlas clusters with MongoDB v4.4 and later.
        """
        return pulumi.get(self, "is_custom_shard_key_hashed")

    @is_custom_shard_key_hashed.setter
    def is_custom_shard_key_hashed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_custom_shard_key_hashed", value)

    @property
    @pulumi.getter(name="isShardKeyUnique")
    def is_shard_key_unique(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether the underlying index enforces a unique constraint. If omitted, defaults to false. You cannot specify true when using [hashed shard keys](https://docs.mongodb.com/manual/core/hashed-sharding/#std-label-sharding-hashed).
        """
        return pulumi.get(self, "is_shard_key_unique")

    @is_shard_key_unique.setter
    def is_shard_key_unique(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_shard_key_unique", value)


if not MYPY:
    class LdapConfigurationUserToDnMappingArgsDict(TypedDict):
        ldap_query: NotRequired[pulumi.Input[str]]
        match: NotRequired[pulumi.Input[str]]
        substitution: NotRequired[pulumi.Input[str]]
elif False:
    LdapConfigurationUserToDnMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LdapConfigurationUserToDnMappingArgs:
    def __init__(__self__, *,
                 ldap_query: Optional[pulumi.Input[str]] = None,
                 match: Optional[pulumi.Input[str]] = None,
                 substitution: Optional[pulumi.Input[str]] = None):
        if ldap_query is not None:
            pulumi.set(__self__, "ldap_query", ldap_query)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if substitution is not None:
            pulumi.set(__self__, "substitution", substitution)

    @property
    @pulumi.getter(name="ldapQuery")
    def ldap_query(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ldap_query")

    @ldap_query.setter
    def ldap_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ldap_query", value)

    @property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter
    def substitution(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "substitution")

    @substitution.setter
    def substitution(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "substitution", value)


if not MYPY:
    class LdapVerifyLinkArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[str]]
        rel: NotRequired[pulumi.Input[str]]
elif False:
    LdapVerifyLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LdapVerifyLinkArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[str]] = None,
                 rel: Optional[pulumi.Input[str]] = None):
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "href", value)

    @property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rel", value)


if not MYPY:
    class LdapVerifyValidationArgsDict(TypedDict):
        status: NotRequired[pulumi.Input[str]]
        """
        The current status of the LDAP over TLS/SSL configuration. One of the following values: `PENDING`, `SUCCESS`, and `FAILED`.
        """
        validation_type: NotRequired[pulumi.Input[str]]
elif False:
    LdapVerifyValidationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LdapVerifyValidationArgs:
    def __init__(__self__, *,
                 status: Optional[pulumi.Input[str]] = None,
                 validation_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] status: The current status of the LDAP over TLS/SSL configuration. One of the following values: `PENDING`, `SUCCESS`, and `FAILED`.
        """
        if status is not None:
            pulumi.set(__self__, "status", status)
        if validation_type is not None:
            pulumi.set(__self__, "validation_type", validation_type)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        The current status of the LDAP over TLS/SSL configuration. One of the following values: `PENDING`, `SUCCESS`, and `FAILED`.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="validationType")
    def validation_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "validation_type")

    @validation_type.setter
    def validation_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "validation_type", value)


if not MYPY:
    class OnlineArchiveCriteriaArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Type of criteria (DATE, CUSTOM)

        The following fields are required for criteria type `DATE`
        """
        date_field: NotRequired[pulumi.Input[str]]
        """
        Indexed database parameter that stores the date that determines when data moves to the online archive. MongoDB Cloud archives the data when the current date exceeds the date in this database parameter plus the number of days specified through the expireAfterDays parameter.
        """
        date_format: NotRequired[pulumi.Input[str]]
        """
        Syntax used to write the date after which data moves to the online archive. Date can be expressed as ISO 8601 or Epoch timestamps. The Epoch timestamp can be expressed as nanoseconds, milliseconds, or seconds. You must set `type` to `DATE` if `collectionType` is `TIMESERIES`. Valid values:  ISODATE (default), EPOCH_SECONDS, EPOCH_MILLIS, EPOCH_NANOSECONDS.
        """
        expire_after_days: NotRequired[pulumi.Input[int]]
        """
        Number of days after the value in the criteria.dateField when MongoDB Cloud archives data in the specified cluster.

        **_NOTE: if `DATE` is selected, the `partition_fields.field_name` must be completed with the `date_field` value_**

        The only field required for criteria type `CUSTOM`
        """
        query: NotRequired[pulumi.Input[str]]
        """
        JSON query to use to select documents for archiving. Atlas uses the specified query with the db.collection.find(query) command. The empty document {} to return all documents is not supported.
        """
elif False:
    OnlineArchiveCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OnlineArchiveCriteriaArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 date_field: Optional[pulumi.Input[str]] = None,
                 date_format: Optional[pulumi.Input[str]] = None,
                 expire_after_days: Optional[pulumi.Input[int]] = None,
                 query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Type of criteria (DATE, CUSTOM)
               
               The following fields are required for criteria type `DATE`
        :param pulumi.Input[str] date_field: Indexed database parameter that stores the date that determines when data moves to the online archive. MongoDB Cloud archives the data when the current date exceeds the date in this database parameter plus the number of days specified through the expireAfterDays parameter.
        :param pulumi.Input[str] date_format: Syntax used to write the date after which data moves to the online archive. Date can be expressed as ISO 8601 or Epoch timestamps. The Epoch timestamp can be expressed as nanoseconds, milliseconds, or seconds. You must set `type` to `DATE` if `collectionType` is `TIMESERIES`. Valid values:  ISODATE (default), EPOCH_SECONDS, EPOCH_MILLIS, EPOCH_NANOSECONDS.
        :param pulumi.Input[int] expire_after_days: Number of days after the value in the criteria.dateField when MongoDB Cloud archives data in the specified cluster.
               
               **_NOTE: if `DATE` is selected, the `partition_fields.field_name` must be completed with the `date_field` value_**
               
               The only field required for criteria type `CUSTOM`
        :param pulumi.Input[str] query: JSON query to use to select documents for archiving. Atlas uses the specified query with the db.collection.find(query) command. The empty document {} to return all documents is not supported.
        """
        pulumi.set(__self__, "type", type)
        if date_field is not None:
            pulumi.set(__self__, "date_field", date_field)
        if date_format is not None:
            pulumi.set(__self__, "date_format", date_format)
        if expire_after_days is not None:
            pulumi.set(__self__, "expire_after_days", expire_after_days)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of criteria (DATE, CUSTOM)

        The following fields are required for criteria type `DATE`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="dateField")
    def date_field(self) -> Optional[pulumi.Input[str]]:
        """
        Indexed database parameter that stores the date that determines when data moves to the online archive. MongoDB Cloud archives the data when the current date exceeds the date in this database parameter plus the number of days specified through the expireAfterDays parameter.
        """
        return pulumi.get(self, "date_field")

    @date_field.setter
    def date_field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_field", value)

    @property
    @pulumi.getter(name="dateFormat")
    def date_format(self) -> Optional[pulumi.Input[str]]:
        """
        Syntax used to write the date after which data moves to the online archive. Date can be expressed as ISO 8601 or Epoch timestamps. The Epoch timestamp can be expressed as nanoseconds, milliseconds, or seconds. You must set `type` to `DATE` if `collectionType` is `TIMESERIES`. Valid values:  ISODATE (default), EPOCH_SECONDS, EPOCH_MILLIS, EPOCH_NANOSECONDS.
        """
        return pulumi.get(self, "date_format")

    @date_format.setter
    def date_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_format", value)

    @property
    @pulumi.getter(name="expireAfterDays")
    def expire_after_days(self) -> Optional[pulumi.Input[int]]:
        """
        Number of days after the value in the criteria.dateField when MongoDB Cloud archives data in the specified cluster.

        **_NOTE: if `DATE` is selected, the `partition_fields.field_name` must be completed with the `date_field` value_**

        The only field required for criteria type `CUSTOM`
        """
        return pulumi.get(self, "expire_after_days")

    @expire_after_days.setter
    def expire_after_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "expire_after_days", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[str]]:
        """
        JSON query to use to select documents for archiving. Atlas uses the specified query with the db.collection.find(query) command. The empty document {} to return all documents is not supported.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query", value)


if not MYPY:
    class OnlineArchiveDataExpirationRuleArgsDict(TypedDict):
        expire_after_days: pulumi.Input[int]
        """
        Number of days used in the date criteria for nominating documents for deletion. Value must be between 7 and 9215.
        """
elif False:
    OnlineArchiveDataExpirationRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OnlineArchiveDataExpirationRuleArgs:
    def __init__(__self__, *,
                 expire_after_days: pulumi.Input[int]):
        """
        :param pulumi.Input[int] expire_after_days: Number of days used in the date criteria for nominating documents for deletion. Value must be between 7 and 9215.
        """
        pulumi.set(__self__, "expire_after_days", expire_after_days)

    @property
    @pulumi.getter(name="expireAfterDays")
    def expire_after_days(self) -> pulumi.Input[int]:
        """
        Number of days used in the date criteria for nominating documents for deletion. Value must be between 7 and 9215.
        """
        return pulumi.get(self, "expire_after_days")

    @expire_after_days.setter
    def expire_after_days(self, value: pulumi.Input[int]):
        pulumi.set(self, "expire_after_days", value)


if not MYPY:
    class OnlineArchiveDataProcessRegionArgsDict(TypedDict):
        cloud_provider: NotRequired[pulumi.Input[str]]
        """
        Human-readable label that identifies the Cloud service provider where you wish to store your archived data. `AZURE` may be selected only if Azure is the Cloud service provider for the cluster and no AWS online archive has been created for the cluster.
        """
        region: NotRequired[pulumi.Input[str]]
        """
        Human-readable label that identifies the geographic location of the region where you wish to store your archived data. For allowed values, see [MongoDB Atlas API documentation](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/v2/#tag/Online-Archive/operation/createOnlineArchive)
        """
elif False:
    OnlineArchiveDataProcessRegionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OnlineArchiveDataProcessRegionArgs:
    def __init__(__self__, *,
                 cloud_provider: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cloud_provider: Human-readable label that identifies the Cloud service provider where you wish to store your archived data. `AZURE` may be selected only if Azure is the Cloud service provider for the cluster and no AWS online archive has been created for the cluster.
        :param pulumi.Input[str] region: Human-readable label that identifies the geographic location of the region where you wish to store your archived data. For allowed values, see [MongoDB Atlas API documentation](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/v2/#tag/Online-Archive/operation/createOnlineArchive)
        """
        if cloud_provider is not None:
            pulumi.set(__self__, "cloud_provider", cloud_provider)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> Optional[pulumi.Input[str]]:
        """
        Human-readable label that identifies the Cloud service provider where you wish to store your archived data. `AZURE` may be selected only if Azure is the Cloud service provider for the cluster and no AWS online archive has been created for the cluster.
        """
        return pulumi.get(self, "cloud_provider")

    @cloud_provider.setter
    def cloud_provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_provider", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        Human-readable label that identifies the geographic location of the region where you wish to store your archived data. For allowed values, see [MongoDB Atlas API documentation](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/v2/#tag/Online-Archive/operation/createOnlineArchive)
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class OnlineArchivePartitionFieldArgsDict(TypedDict):
        field_name: pulumi.Input[str]
        """
        Human-readable label that identifies the parameter that MongoDB Cloud uses to partition data. To specify a nested parameter, use the dot notation.
        """
        order: pulumi.Input[int]
        """
        Sequence in which MongoDB Cloud slices the collection data to create partitions. The resource expresses this sequence starting with zero. The value of the `criteria.dateField` parameter defaults as the first item in the partition sequence.
        """
        field_type: NotRequired[pulumi.Input[str]]
        """
        Data type of the parameter that that MongoDB Cloud uses to partition data. Partition parameters of type UUID must be of binary subtype 4. MongoDB Cloud skips partition parameters of type UUID with subtype 3. Valid values: `date`, `int`, `long`, `objectId`, `string`, `uuid`.
        """
elif False:
    OnlineArchivePartitionFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OnlineArchivePartitionFieldArgs:
    def __init__(__self__, *,
                 field_name: pulumi.Input[str],
                 order: pulumi.Input[int],
                 field_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] field_name: Human-readable label that identifies the parameter that MongoDB Cloud uses to partition data. To specify a nested parameter, use the dot notation.
        :param pulumi.Input[int] order: Sequence in which MongoDB Cloud slices the collection data to create partitions. The resource expresses this sequence starting with zero. The value of the `criteria.dateField` parameter defaults as the first item in the partition sequence.
        :param pulumi.Input[str] field_type: Data type of the parameter that that MongoDB Cloud uses to partition data. Partition parameters of type UUID must be of binary subtype 4. MongoDB Cloud skips partition parameters of type UUID with subtype 3. Valid values: `date`, `int`, `long`, `objectId`, `string`, `uuid`.
        """
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "order", order)
        if field_type is not None:
            pulumi.set(__self__, "field_type", field_type)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> pulumi.Input[str]:
        """
        Human-readable label that identifies the parameter that MongoDB Cloud uses to partition data. To specify a nested parameter, use the dot notation.
        """
        return pulumi.get(self, "field_name")

    @field_name.setter
    def field_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "field_name", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[int]:
        """
        Sequence in which MongoDB Cloud slices the collection data to create partitions. The resource expresses this sequence starting with zero. The value of the `criteria.dateField` parameter defaults as the first item in the partition sequence.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[int]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter(name="fieldType")
    def field_type(self) -> Optional[pulumi.Input[str]]:
        """
        Data type of the parameter that that MongoDB Cloud uses to partition data. Partition parameters of type UUID must be of binary subtype 4. MongoDB Cloud skips partition parameters of type UUID with subtype 3. Valid values: `date`, `int`, `long`, `objectId`, `string`, `uuid`.
        """
        return pulumi.get(self, "field_type")

    @field_type.setter
    def field_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_type", value)


if not MYPY:
    class OnlineArchiveScheduleArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Type of schedule (``DAILY`, `MONTHLY`, `WEEKLY`).
        """
        day_of_month: NotRequired[pulumi.Input[int]]
        """
        Day of the month when the scheduled archive starts. This field should be provided only when schedule `type` is `MONTHLY`.
        """
        day_of_week: NotRequired[pulumi.Input[int]]
        """
        Day of the week when the scheduled archive starts. The week starts with Monday (1) and ends with Sunday (7). This field should be provided only when schedule `type` is `WEEKLY`.
        """
        end_hour: NotRequired[pulumi.Input[int]]
        """
        Hour of the day when the scheduled window to run one online archive ends.
        """
        end_minute: NotRequired[pulumi.Input[int]]
        """
        Minute of the hour when the scheduled window to run one online archive ends.
        """
        start_hour: NotRequired[pulumi.Input[int]]
        """
        Hour of the day when the when the scheduled window to run one online archive starts.
        """
        start_minute: NotRequired[pulumi.Input[int]]
        """
        Minute of the hour when the scheduled window to run one online archive starts.
        """
elif False:
    OnlineArchiveScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OnlineArchiveScheduleArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 day_of_month: Optional[pulumi.Input[int]] = None,
                 day_of_week: Optional[pulumi.Input[int]] = None,
                 end_hour: Optional[pulumi.Input[int]] = None,
                 end_minute: Optional[pulumi.Input[int]] = None,
                 start_hour: Optional[pulumi.Input[int]] = None,
                 start_minute: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] type: Type of schedule (``DAILY`, `MONTHLY`, `WEEKLY`).
        :param pulumi.Input[int] day_of_month: Day of the month when the scheduled archive starts. This field should be provided only when schedule `type` is `MONTHLY`.
        :param pulumi.Input[int] day_of_week: Day of the week when the scheduled archive starts. The week starts with Monday (1) and ends with Sunday (7). This field should be provided only when schedule `type` is `WEEKLY`.
        :param pulumi.Input[int] end_hour: Hour of the day when the scheduled window to run one online archive ends.
        :param pulumi.Input[int] end_minute: Minute of the hour when the scheduled window to run one online archive ends.
        :param pulumi.Input[int] start_hour: Hour of the day when the when the scheduled window to run one online archive starts.
        :param pulumi.Input[int] start_minute: Minute of the hour when the scheduled window to run one online archive starts.
        """
        pulumi.set(__self__, "type", type)
        if day_of_month is not None:
            pulumi.set(__self__, "day_of_month", day_of_month)
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if end_hour is not None:
            pulumi.set(__self__, "end_hour", end_hour)
        if end_minute is not None:
            pulumi.set(__self__, "end_minute", end_minute)
        if start_hour is not None:
            pulumi.set(__self__, "start_hour", start_hour)
        if start_minute is not None:
            pulumi.set(__self__, "start_minute", start_minute)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of schedule (``DAILY`, `MONTHLY`, `WEEKLY`).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> Optional[pulumi.Input[int]]:
        """
        Day of the month when the scheduled archive starts. This field should be provided only when schedule `type` is `MONTHLY`.
        """
        return pulumi.get(self, "day_of_month")

    @day_of_month.setter
    def day_of_month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day_of_month", value)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[pulumi.Input[int]]:
        """
        Day of the week when the scheduled archive starts. The week starts with Monday (1) and ends with Sunday (7). This field should be provided only when schedule `type` is `WEEKLY`.
        """
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day_of_week", value)

    @property
    @pulumi.getter(name="endHour")
    def end_hour(self) -> Optional[pulumi.Input[int]]:
        """
        Hour of the day when the scheduled window to run one online archive ends.
        """
        return pulumi.get(self, "end_hour")

    @end_hour.setter
    def end_hour(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "end_hour", value)

    @property
    @pulumi.getter(name="endMinute")
    def end_minute(self) -> Optional[pulumi.Input[int]]:
        """
        Minute of the hour when the scheduled window to run one online archive ends.
        """
        return pulumi.get(self, "end_minute")

    @end_minute.setter
    def end_minute(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "end_minute", value)

    @property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> Optional[pulumi.Input[int]]:
        """
        Hour of the day when the when the scheduled window to run one online archive starts.
        """
        return pulumi.get(self, "start_hour")

    @start_hour.setter
    def start_hour(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "start_hour", value)

    @property
    @pulumi.getter(name="startMinute")
    def start_minute(self) -> Optional[pulumi.Input[int]]:
        """
        Minute of the hour when the scheduled window to run one online archive starts.
        """
        return pulumi.get(self, "start_minute")

    @start_minute.setter
    def start_minute(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "start_minute", value)


if not MYPY:
    class PrivateLinkEndpointServiceEndpointArgsDict(TypedDict):
        endpoint_name: NotRequired[pulumi.Input[str]]
        """
        Forwarding rule that corresponds to the endpoint you created in GCP.
        """
        ip_address: NotRequired[pulumi.Input[str]]
        """
        Private IP address of the endpoint you created in GCP.
        """
        status: NotRequired[pulumi.Input[str]]
        """
        Status of the endpoint. Atlas returns one of the [values shown above](https://docs.atlas.mongodb.com/reference/api/private-endpoints-endpoint-create-one/#std-label-ref-status-field).
        """
elif False:
    PrivateLinkEndpointServiceEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivateLinkEndpointServiceEndpointArgs:
    def __init__(__self__, *,
                 endpoint_name: Optional[pulumi.Input[str]] = None,
                 ip_address: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] endpoint_name: Forwarding rule that corresponds to the endpoint you created in GCP.
        :param pulumi.Input[str] ip_address: Private IP address of the endpoint you created in GCP.
        :param pulumi.Input[str] status: Status of the endpoint. Atlas returns one of the [values shown above](https://docs.atlas.mongodb.com/reference/api/private-endpoints-endpoint-create-one/#std-label-ref-status-field).
        """
        if endpoint_name is not None:
            pulumi.set(__self__, "endpoint_name", endpoint_name)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="endpointName")
    def endpoint_name(self) -> Optional[pulumi.Input[str]]:
        """
        Forwarding rule that corresponds to the endpoint you created in GCP.
        """
        return pulumi.get(self, "endpoint_name")

    @endpoint_name.setter
    def endpoint_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint_name", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        Private IP address of the endpoint you created in GCP.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        Status of the endpoint. Atlas returns one of the [values shown above](https://docs.atlas.mongodb.com/reference/api/private-endpoints-endpoint-create-one/#std-label-ref-status-field).
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class ProjectApiKeyProjectAssignmentArgsDict(TypedDict):
        project_id: pulumi.Input[str]
        """
        Project ID to assign to Access Key
        """
        role_names: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        List of Project roles that the Programmatic API key needs to have. Ensure you provide: at least one role and ensure all roles are valid for the Project. You must specify an array even if you are only associating a single role with the Programmatic API key. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#project-roles) describes the valid roles that can be assigned.
        """
elif False:
    ProjectApiKeyProjectAssignmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectApiKeyProjectAssignmentArgs:
    def __init__(__self__, *,
                 project_id: pulumi.Input[str],
                 role_names: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] project_id: Project ID to assign to Access Key
        :param pulumi.Input[Sequence[pulumi.Input[str]]] role_names: List of Project roles that the Programmatic API key needs to have. Ensure you provide: at least one role and ensure all roles are valid for the Project. You must specify an array even if you are only associating a single role with the Programmatic API key. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#project-roles) describes the valid roles that can be assigned.
        """
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "role_names", role_names)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[str]:
        """
        Project ID to assign to Access Key
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter(name="roleNames")
    def role_names(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of Project roles that the Programmatic API key needs to have. Ensure you provide: at least one role and ensure all roles are valid for the Project. You must specify an array even if you are only associating a single role with the Programmatic API key. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#project-roles) describes the valid roles that can be assigned.
        """
        return pulumi.get(self, "role_names")

    @role_names.setter
    def role_names(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "role_names", value)


if not MYPY:
    class ProjectIpAccessListTimeoutsArgsDict(TypedDict):
        delete: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        read: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
elif False:
    ProjectIpAccessListTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectIpAccessListTimeoutsArgs:
    def __init__(__self__, *,
                 delete: Optional[pulumi.Input[str]] = None,
                 read: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "read", value)


if not MYPY:
    class ProjectIpAddressesArgsDict(TypedDict):
        services: NotRequired[pulumi.Input['ProjectIpAddressesServicesArgsDict']]
elif False:
    ProjectIpAddressesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectIpAddressesArgs:
    def __init__(__self__, *,
                 services: Optional[pulumi.Input['ProjectIpAddressesServicesArgs']] = None):
        if services is not None:
            pulumi.set(__self__, "services", services)

    @property
    @pulumi.getter
    def services(self) -> Optional[pulumi.Input['ProjectIpAddressesServicesArgs']]:
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: Optional[pulumi.Input['ProjectIpAddressesServicesArgs']]):
        pulumi.set(self, "services", value)


if not MYPY:
    class ProjectIpAddressesServicesArgsDict(TypedDict):
        clusters: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectIpAddressesServicesClusterArgsDict']]]]
elif False:
    ProjectIpAddressesServicesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectIpAddressesServicesArgs:
    def __init__(__self__, *,
                 clusters: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectIpAddressesServicesClusterArgs']]]] = None):
        if clusters is not None:
            pulumi.set(__self__, "clusters", clusters)

    @property
    @pulumi.getter
    def clusters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectIpAddressesServicesClusterArgs']]]]:
        return pulumi.get(self, "clusters")

    @clusters.setter
    def clusters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectIpAddressesServicesClusterArgs']]]]):
        pulumi.set(self, "clusters", value)


if not MYPY:
    class ProjectIpAddressesServicesClusterArgsDict(TypedDict):
        cluster_name: NotRequired[pulumi.Input[str]]
        inbounds: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        outbounds: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    ProjectIpAddressesServicesClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectIpAddressesServicesClusterArgs:
    def __init__(__self__, *,
                 cluster_name: Optional[pulumi.Input[str]] = None,
                 inbounds: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 outbounds: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if inbounds is not None:
            pulumi.set(__self__, "inbounds", inbounds)
        if outbounds is not None:
            pulumi.set(__self__, "outbounds", outbounds)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter
    def inbounds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "inbounds")

    @inbounds.setter
    def inbounds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "inbounds", value)

    @property
    @pulumi.getter
    def outbounds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "outbounds")

    @outbounds.setter
    def outbounds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "outbounds", value)


if not MYPY:
    class ProjectLimitArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Human-readable label that identifies this project limit. See [Project Limit Documentation](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Projects/operation/setProjectLimit) under `limitName` parameter to find all the limits that can be defined.
        """
        value: pulumi.Input[int]
        """
        Amount to set the limit to. Use the [Project Limit Documentation](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Projects/operation/setProjectLimit) under `limitName` parameter to verify the override limits.
        """
        current_usage: NotRequired[pulumi.Input[int]]
        default_limit: NotRequired[pulumi.Input[int]]
        maximum_limit: NotRequired[pulumi.Input[int]]
elif False:
    ProjectLimitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectLimitArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[int],
                 current_usage: Optional[pulumi.Input[int]] = None,
                 default_limit: Optional[pulumi.Input[int]] = None,
                 maximum_limit: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] name: Human-readable label that identifies this project limit. See [Project Limit Documentation](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Projects/operation/setProjectLimit) under `limitName` parameter to find all the limits that can be defined.
        :param pulumi.Input[int] value: Amount to set the limit to. Use the [Project Limit Documentation](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Projects/operation/setProjectLimit) under `limitName` parameter to verify the override limits.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)
        if current_usage is not None:
            pulumi.set(__self__, "current_usage", current_usage)
        if default_limit is not None:
            pulumi.set(__self__, "default_limit", default_limit)
        if maximum_limit is not None:
            pulumi.set(__self__, "maximum_limit", maximum_limit)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Human-readable label that identifies this project limit. See [Project Limit Documentation](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Projects/operation/setProjectLimit) under `limitName` parameter to find all the limits that can be defined.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[int]:
        """
        Amount to set the limit to. Use the [Project Limit Documentation](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Projects/operation/setProjectLimit) under `limitName` parameter to verify the override limits.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[int]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="currentUsage")
    def current_usage(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "current_usage")

    @current_usage.setter
    def current_usage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "current_usage", value)

    @property
    @pulumi.getter(name="defaultLimit")
    def default_limit(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "default_limit")

    @default_limit.setter
    def default_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "default_limit", value)

    @property
    @pulumi.getter(name="maximumLimit")
    def maximum_limit(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "maximum_limit")

    @maximum_limit.setter
    def maximum_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "maximum_limit", value)


if not MYPY:
    class ProjectTeamArgsDict(TypedDict):
        role_names: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Each string in the array represents a project role you want to assign to the team. Every user associated with the team inherits these roles. You must specify an array even if you are only associating a single role with the team. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#organization-roles) describes the roles a user can have.

        > **NOTE:** Project created by API Keys must belong to an existing organization.
        """
        team_id: pulumi.Input[str]
        """
        The unique identifier of the team you want to associate with the project. The team and project must share the same parent organization.
        """
elif False:
    ProjectTeamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectTeamArgs:
    def __init__(__self__, *,
                 role_names: pulumi.Input[Sequence[pulumi.Input[str]]],
                 team_id: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] role_names: Each string in the array represents a project role you want to assign to the team. Every user associated with the team inherits these roles. You must specify an array even if you are only associating a single role with the team. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#organization-roles) describes the roles a user can have.
               
               > **NOTE:** Project created by API Keys must belong to an existing organization.
        :param pulumi.Input[str] team_id: The unique identifier of the team you want to associate with the project. The team and project must share the same parent organization.
        """
        pulumi.set(__self__, "role_names", role_names)
        pulumi.set(__self__, "team_id", team_id)

    @property
    @pulumi.getter(name="roleNames")
    def role_names(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Each string in the array represents a project role you want to assign to the team. Every user associated with the team inherits these roles. You must specify an array even if you are only associating a single role with the team. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#organization-roles) describes the roles a user can have.

        > **NOTE:** Project created by API Keys must belong to an existing organization.
        """
        return pulumi.get(self, "role_names")

    @role_names.setter
    def role_names(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "role_names", value)

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> pulumi.Input[str]:
        """
        The unique identifier of the team you want to associate with the project. The team and project must share the same parent organization.
        """
        return pulumi.get(self, "team_id")

    @team_id.setter
    def team_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "team_id", value)


if not MYPY:
    class ProviderAssumeRoleArgsDict(TypedDict):
        duration: NotRequired[pulumi.Input[str]]
        """
        The duration, between 15 minutes and 12 hours, of the role session. Valid time units are ns, us (or µs), ms, s, h, or m.
        """
        external_id: NotRequired[pulumi.Input[str]]
        """
        A unique identifier that might be required when you assume a role in another account.
        """
        policy: NotRequired[pulumi.Input[str]]
        """
        IAM Policy JSON describing further restricting permissions for the IAM Role being assumed.
        """
        policy_arns: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Amazon Resource Names (ARNs) of IAM Policies describing further restricting permissions for the IAM Role being assumed.
        """
        role_arn: NotRequired[pulumi.Input[str]]
        """
        Amazon Resource Name (ARN) of an IAM Role to assume prior to making API calls.
        """
        session_name: NotRequired[pulumi.Input[str]]
        """
        An identifier for the assumed role session.
        """
        source_identity: NotRequired[pulumi.Input[str]]
        """
        Source identity specified by the principal assuming the role.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Assume role session tags.
        """
        transitive_tag_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Assume role session tag keys to pass to any subsequent sessions.
        """
elif False:
    ProviderAssumeRoleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProviderAssumeRoleArgs:
    def __init__(__self__, *,
                 duration: Optional[pulumi.Input[str]] = None,
                 external_id: Optional[pulumi.Input[str]] = None,
                 policy: Optional[pulumi.Input[str]] = None,
                 policy_arns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 role_arn: Optional[pulumi.Input[str]] = None,
                 session_name: Optional[pulumi.Input[str]] = None,
                 source_identity: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 transitive_tag_keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] duration: The duration, between 15 minutes and 12 hours, of the role session. Valid time units are ns, us (or µs), ms, s, h, or m.
        :param pulumi.Input[str] external_id: A unique identifier that might be required when you assume a role in another account.
        :param pulumi.Input[str] policy: IAM Policy JSON describing further restricting permissions for the IAM Role being assumed.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] policy_arns: Amazon Resource Names (ARNs) of IAM Policies describing further restricting permissions for the IAM Role being assumed.
        :param pulumi.Input[str] role_arn: Amazon Resource Name (ARN) of an IAM Role to assume prior to making API calls.
        :param pulumi.Input[str] session_name: An identifier for the assumed role session.
        :param pulumi.Input[str] source_identity: Source identity specified by the principal assuming the role.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] tags: Assume role session tags.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] transitive_tag_keys: Assume role session tag keys to pass to any subsequent sessions.
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if policy_arns is not None:
            pulumi.set(__self__, "policy_arns", policy_arns)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if session_name is not None:
            pulumi.set(__self__, "session_name", session_name)
        if source_identity is not None:
            pulumi.set(__self__, "source_identity", source_identity)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if transitive_tag_keys is not None:
            pulumi.set(__self__, "transitive_tag_keys", transitive_tag_keys)

    @property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[str]]:
        """
        The duration, between 15 minutes and 12 hours, of the role session. Valid time units are ns, us (or µs), ms, s, h, or m.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[str]]:
        """
        A unique identifier that might be required when you assume a role in another account.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "external_id", value)

    @property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input[str]]:
        """
        IAM Policy JSON describing further restricting permissions for the IAM Role being assumed.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "policy", value)

    @property
    @pulumi.getter(name="policyArns")
    def policy_arns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Amazon Resource Names (ARNs) of IAM Policies describing further restricting permissions for the IAM Role being assumed.
        """
        return pulumi.get(self, "policy_arns")

    @policy_arns.setter
    def policy_arns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "policy_arns", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        Amazon Resource Name (ARN) of an IAM Role to assume prior to making API calls.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="sessionName")
    def session_name(self) -> Optional[pulumi.Input[str]]:
        """
        An identifier for the assumed role session.
        """
        return pulumi.get(self, "session_name")

    @session_name.setter
    def session_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "session_name", value)

    @property
    @pulumi.getter(name="sourceIdentity")
    def source_identity(self) -> Optional[pulumi.Input[str]]:
        """
        Source identity specified by the principal assuming the role.
        """
        return pulumi.get(self, "source_identity")

    @source_identity.setter
    def source_identity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_identity", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Assume role session tags.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter(name="transitiveTagKeys")
    def transitive_tag_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Assume role session tag keys to pass to any subsequent sessions.
        """
        return pulumi.get(self, "transitive_tag_keys")

    @transitive_tag_keys.setter
    def transitive_tag_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "transitive_tag_keys", value)


if not MYPY:
    class PushBasedLogExportTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    PushBasedLogExportTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PushBasedLogExportTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[str]] = None,
                 delete: Optional[pulumi.Input[str]] = None,
                 update: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class SearchDeploymentSpecArgsDict(TypedDict):
        instance_size: pulumi.Input[str]
        """
        Hardware specification for the search node instance sizes. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Atlas-Search/operation/createAtlasSearchDeployment) describes the valid values. More details can also be found in the [Search Node Documentation](https://www.mongodb.com/docs/atlas/cluster-config/multi-cloud-distribution/#search-tier).
        """
        node_count: pulumi.Input[int]
        """
        Number of search nodes in the cluster.
        """
elif False:
    SearchDeploymentSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SearchDeploymentSpecArgs:
    def __init__(__self__, *,
                 instance_size: pulumi.Input[str],
                 node_count: pulumi.Input[int]):
        """
        :param pulumi.Input[str] instance_size: Hardware specification for the search node instance sizes. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Atlas-Search/operation/createAtlasSearchDeployment) describes the valid values. More details can also be found in the [Search Node Documentation](https://www.mongodb.com/docs/atlas/cluster-config/multi-cloud-distribution/#search-tier).
        :param pulumi.Input[int] node_count: Number of search nodes in the cluster.
        """
        pulumi.set(__self__, "instance_size", instance_size)
        pulumi.set(__self__, "node_count", node_count)

    @property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> pulumi.Input[str]:
        """
        Hardware specification for the search node instance sizes. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Atlas-Search/operation/createAtlasSearchDeployment) describes the valid values. More details can also be found in the [Search Node Documentation](https://www.mongodb.com/docs/atlas/cluster-config/multi-cloud-distribution/#search-tier).
        """
        return pulumi.get(self, "instance_size")

    @instance_size.setter
    def instance_size(self, value: pulumi.Input[str]):
        pulumi.set(self, "instance_size", value)

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> pulumi.Input[int]:
        """
        Number of search nodes in the cluster.
        """
        return pulumi.get(self, "node_count")

    @node_count.setter
    def node_count(self, value: pulumi.Input[int]):
        pulumi.set(self, "node_count", value)


if not MYPY:
    class SearchDeploymentTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    SearchDeploymentTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SearchDeploymentTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[str]] = None,
                 delete: Optional[pulumi.Input[str]] = None,
                 update: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "create", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class SearchIndexSynonymArgsDict(TypedDict):
        analyzer: pulumi.Input[str]
        """
        [Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index. Defaults to [lucene.standard](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/standard/#std-label-ref-standard-analyzer)
        """
        name: pulumi.Input[str]
        """
        The name of the search index you want to create.
        """
        source_collection: pulumi.Input[str]
        """
        (Required) Name of the source MongoDB collection for the synonyms. Documents in this collection must be in the format described in the [Synonyms Source Collection Documents](https://docs.atlas.mongodb.com/reference/atlas-search/synonyms/#std-label-synonyms-coll-spec).
        """
elif False:
    SearchIndexSynonymArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SearchIndexSynonymArgs:
    def __init__(__self__, *,
                 analyzer: pulumi.Input[str],
                 name: pulumi.Input[str],
                 source_collection: pulumi.Input[str]):
        """
        :param pulumi.Input[str] analyzer: [Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index. Defaults to [lucene.standard](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/standard/#std-label-ref-standard-analyzer)
        :param pulumi.Input[str] name: The name of the search index you want to create.
        :param pulumi.Input[str] source_collection: (Required) Name of the source MongoDB collection for the synonyms. Documents in this collection must be in the format described in the [Synonyms Source Collection Documents](https://docs.atlas.mongodb.com/reference/atlas-search/synonyms/#std-label-synonyms-coll-spec).
        """
        pulumi.set(__self__, "analyzer", analyzer)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "source_collection", source_collection)

    @property
    @pulumi.getter
    def analyzer(self) -> pulumi.Input[str]:
        """
        [Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index. Defaults to [lucene.standard](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/standard/#std-label-ref-standard-analyzer)
        """
        return pulumi.get(self, "analyzer")

    @analyzer.setter
    def analyzer(self, value: pulumi.Input[str]):
        pulumi.set(self, "analyzer", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the search index you want to create.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sourceCollection")
    def source_collection(self) -> pulumi.Input[str]:
        """
        (Required) Name of the source MongoDB collection for the synonyms. Documents in this collection must be in the format described in the [Synonyms Source Collection Documents](https://docs.atlas.mongodb.com/reference/atlas-search/synonyms/#std-label-synonyms-coll-spec).
        """
        return pulumi.get(self, "source_collection")

    @source_collection.setter
    def source_collection(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_collection", value)


if not MYPY:
    class ServerlessInstanceLinkArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[str]]
        rel: NotRequired[pulumi.Input[str]]
elif False:
    ServerlessInstanceLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessInstanceLinkArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[str]] = None,
                 rel: Optional[pulumi.Input[str]] = None):
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "href", value)

    @property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rel", value)


if not MYPY:
    class ServerlessInstanceTagArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Constant that defines the set of the tag.
        """
        value: pulumi.Input[str]
        """
        Variable that belongs to the set of the tag.

        To learn more, see [Resource Tags](https://dochub.mongodb.org/core/add-cluster-tag-atlas).
        """
elif False:
    ServerlessInstanceTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessInstanceTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Constant that defines the set of the tag.
        :param pulumi.Input[str] value: Variable that belongs to the set of the tag.
               
               To learn more, see [Resource Tags](https://dochub.mongodb.org/core/add-cluster-tag-atlas).
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Constant that defines the set of the tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Variable that belongs to the set of the tag.

        To learn more, see [Resource Tags](https://dochub.mongodb.org/core/add-cluster-tag-atlas).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class StreamConnectionAuthenticationArgsDict(TypedDict):
        mechanism: NotRequired[pulumi.Input[str]]
        """
        Style of authentication. Can be one of `PLAIN`, `SCRAM-256`, or `SCRAM-512`.
        """
        password: NotRequired[pulumi.Input[str]]
        """
        Password of the account to connect to the Kafka cluster.
        """
        username: NotRequired[pulumi.Input[str]]
        """
        Username of the account to connect to the Kafka cluster.
        """
elif False:
    StreamConnectionAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamConnectionAuthenticationArgs:
    def __init__(__self__, *,
                 mechanism: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] mechanism: Style of authentication. Can be one of `PLAIN`, `SCRAM-256`, or `SCRAM-512`.
        :param pulumi.Input[str] password: Password of the account to connect to the Kafka cluster.
        :param pulumi.Input[str] username: Username of the account to connect to the Kafka cluster.
        """
        if mechanism is not None:
            pulumi.set(__self__, "mechanism", mechanism)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def mechanism(self) -> Optional[pulumi.Input[str]]:
        """
        Style of authentication. Can be one of `PLAIN`, `SCRAM-256`, or `SCRAM-512`.
        """
        return pulumi.get(self, "mechanism")

    @mechanism.setter
    def mechanism(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mechanism", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Password of the account to connect to the Kafka cluster.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        Username of the account to connect to the Kafka cluster.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class StreamConnectionDbRoleToExecuteArgsDict(TypedDict):
        role: pulumi.Input[str]
        """
        The name of the role to use. Value can be  `atlasAdmin`, `readWriteAnyDatabase`, or `readAnyDatabase` if `type` is set to `BUILT_IN`, or the name of a user-defined role if `type` is set to `CUSTOM`.
        """
        type: pulumi.Input[str]
        """
        Type of connection. Can be either `Cluster`, `Kafka` or `Sample`.
        """
elif False:
    StreamConnectionDbRoleToExecuteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamConnectionDbRoleToExecuteArgs:
    def __init__(__self__, *,
                 role: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] role: The name of the role to use. Value can be  `atlasAdmin`, `readWriteAnyDatabase`, or `readAnyDatabase` if `type` is set to `BUILT_IN`, or the name of a user-defined role if `type` is set to `CUSTOM`.
        :param pulumi.Input[str] type: Type of connection. Can be either `Cluster`, `Kafka` or `Sample`.
        """
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def role(self) -> pulumi.Input[str]:
        """
        The name of the role to use. Value can be  `atlasAdmin`, `readWriteAnyDatabase`, or `readAnyDatabase` if `type` is set to `BUILT_IN`, or the name of a user-defined role if `type` is set to `CUSTOM`.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: pulumi.Input[str]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of connection. Can be either `Cluster`, `Kafka` or `Sample`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class StreamConnectionSecurityArgsDict(TypedDict):
        broker_public_certificate: NotRequired[pulumi.Input[str]]
        """
        A trusted, public x509 certificate for connecting to Kafka over SSL. String value of the certificate must be defined in the attribute.
        """
        protocol: NotRequired[pulumi.Input[str]]
        """
        Describes the transport type. Can be either `PLAINTEXT` or `SSL`.
        """
elif False:
    StreamConnectionSecurityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamConnectionSecurityArgs:
    def __init__(__self__, *,
                 broker_public_certificate: Optional[pulumi.Input[str]] = None,
                 protocol: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] broker_public_certificate: A trusted, public x509 certificate for connecting to Kafka over SSL. String value of the certificate must be defined in the attribute.
        :param pulumi.Input[str] protocol: Describes the transport type. Can be either `PLAINTEXT` or `SSL`.
        """
        if broker_public_certificate is not None:
            pulumi.set(__self__, "broker_public_certificate", broker_public_certificate)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter(name="brokerPublicCertificate")
    def broker_public_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        A trusted, public x509 certificate for connecting to Kafka over SSL. String value of the certificate must be defined in the attribute.
        """
        return pulumi.get(self, "broker_public_certificate")

    @broker_public_certificate.setter
    def broker_public_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "broker_public_certificate", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        Describes the transport type. Can be either `PLAINTEXT` or `SSL`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class StreamInstanceDataProcessRegionArgsDict(TypedDict):
        cloud_provider: pulumi.Input[str]
        """
        Label that identifies the cloud service provider where MongoDB Cloud performs stream processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.
        """
        region: pulumi.Input[str]
        """
        Name of the cloud provider region hosting Atlas Stream Processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.
        """
elif False:
    StreamInstanceDataProcessRegionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamInstanceDataProcessRegionArgs:
    def __init__(__self__, *,
                 cloud_provider: pulumi.Input[str],
                 region: pulumi.Input[str]):
        """
        :param pulumi.Input[str] cloud_provider: Label that identifies the cloud service provider where MongoDB Cloud performs stream processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.
        :param pulumi.Input[str] region: Name of the cloud provider region hosting Atlas Stream Processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.
        """
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> pulumi.Input[str]:
        """
        Label that identifies the cloud service provider where MongoDB Cloud performs stream processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.
        """
        return pulumi.get(self, "cloud_provider")

    @cloud_provider.setter
    def cloud_provider(self, value: pulumi.Input[str]):
        pulumi.set(self, "cloud_provider", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        Name of the cloud provider region hosting Atlas Stream Processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)


if not MYPY:
    class StreamInstanceStreamConfigArgsDict(TypedDict):
        tier: NotRequired[pulumi.Input[str]]
        """
        Selected tier for the Stream Instance. Configures Memory / VCPU allowances. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.
        """
elif False:
    StreamInstanceStreamConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamInstanceStreamConfigArgs:
    def __init__(__self__, *,
                 tier: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] tier: Selected tier for the Stream Instance. Configures Memory / VCPU allowances. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.
        """
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter
    def tier(self) -> Optional[pulumi.Input[str]]:
        """
        Selected tier for the Stream Instance. Configures Memory / VCPU allowances. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.
        """
        return pulumi.get(self, "tier")

    @tier.setter
    def tier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tier", value)


if not MYPY:
    class StreamProcessorOptionsArgsDict(TypedDict):
        dlq: pulumi.Input['StreamProcessorOptionsDlqArgsDict']
        """
        Dead letter queue for the stream processor. Refer to the [MongoDB Atlas Docs](https://www.mongodb.com/docs/atlas/reference/glossary/#std-term-dead-letter-queue) for more information.
        """
elif False:
    StreamProcessorOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamProcessorOptionsArgs:
    def __init__(__self__, *,
                 dlq: pulumi.Input['StreamProcessorOptionsDlqArgs']):
        """
        :param pulumi.Input['StreamProcessorOptionsDlqArgs'] dlq: Dead letter queue for the stream processor. Refer to the [MongoDB Atlas Docs](https://www.mongodb.com/docs/atlas/reference/glossary/#std-term-dead-letter-queue) for more information.
        """
        pulumi.set(__self__, "dlq", dlq)

    @property
    @pulumi.getter
    def dlq(self) -> pulumi.Input['StreamProcessorOptionsDlqArgs']:
        """
        Dead letter queue for the stream processor. Refer to the [MongoDB Atlas Docs](https://www.mongodb.com/docs/atlas/reference/glossary/#std-term-dead-letter-queue) for more information.
        """
        return pulumi.get(self, "dlq")

    @dlq.setter
    def dlq(self, value: pulumi.Input['StreamProcessorOptionsDlqArgs']):
        pulumi.set(self, "dlq", value)


if not MYPY:
    class StreamProcessorOptionsDlqArgsDict(TypedDict):
        coll: pulumi.Input[str]
        """
        Name of the collection to use for the DLQ.
        """
        connection_name: pulumi.Input[str]
        """
        Name of the connection to write DLQ messages to. Must be an Atlas connection.
        """
        db: pulumi.Input[str]
        """
        Name of the database to use for the DLQ.
        """
elif False:
    StreamProcessorOptionsDlqArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamProcessorOptionsDlqArgs:
    def __init__(__self__, *,
                 coll: pulumi.Input[str],
                 connection_name: pulumi.Input[str],
                 db: pulumi.Input[str]):
        """
        :param pulumi.Input[str] coll: Name of the collection to use for the DLQ.
        :param pulumi.Input[str] connection_name: Name of the connection to write DLQ messages to. Must be an Atlas connection.
        :param pulumi.Input[str] db: Name of the database to use for the DLQ.
        """
        pulumi.set(__self__, "coll", coll)
        pulumi.set(__self__, "connection_name", connection_name)
        pulumi.set(__self__, "db", db)

    @property
    @pulumi.getter
    def coll(self) -> pulumi.Input[str]:
        """
        Name of the collection to use for the DLQ.
        """
        return pulumi.get(self, "coll")

    @coll.setter
    def coll(self, value: pulumi.Input[str]):
        pulumi.set(self, "coll", value)

    @property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> pulumi.Input[str]:
        """
        Name of the connection to write DLQ messages to. Must be an Atlas connection.
        """
        return pulumi.get(self, "connection_name")

    @connection_name.setter
    def connection_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "connection_name", value)

    @property
    @pulumi.getter
    def db(self) -> pulumi.Input[str]:
        """
        Name of the database to use for the DLQ.
        """
        return pulumi.get(self, "db")

    @db.setter
    def db(self, value: pulumi.Input[str]):
        pulumi.set(self, "db", value)


if not MYPY:
    class X509AuthenticationDatabaseUserCertificateArgsDict(TypedDict):
        created_at: NotRequired[pulumi.Input[str]]
        group_id: NotRequired[pulumi.Input[str]]
        id: NotRequired[pulumi.Input[int]]
        not_after: NotRequired[pulumi.Input[str]]
        subject: NotRequired[pulumi.Input[str]]
elif False:
    X509AuthenticationDatabaseUserCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class X509AuthenticationDatabaseUserCertificateArgs:
    def __init__(__self__, *,
                 created_at: Optional[pulumi.Input[str]] = None,
                 group_id: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[int]] = None,
                 not_after: Optional[pulumi.Input[str]] = None,
                 subject: Optional[pulumi.Input[str]] = None):
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if not_after is not None:
            pulumi.set(__self__, "not_after", not_after)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="notAfter")
    def not_after(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "not_after")

    @not_after.setter
    def not_after(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "not_after", value)

    @property
    @pulumi.getter
    def subject(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject", value)


if not MYPY:
    class GetAlertConfigurationOutputArgsDict(TypedDict):
        type: str
        value: str
        """
        Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:
        - `PRIMARY`
        - `SECONDARY`
        - `STANDALONE`
        - `CONFIG`
        - `MONGOS`
        """
        label: NotRequired[str]
elif False:
    GetAlertConfigurationOutputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAlertConfigurationOutputArgs:
    def __init__(__self__, *,
                 type: str,
                 value: str,
                 label: Optional[str] = None):
        """
        :param str value: Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:
               - `PRIMARY`
               - `SECONDARY`
               - `STANDALONE`
               - `CONFIG`
               - `MONGOS`
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)
        if label is not None:
            pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: str):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:
        - `PRIMARY`
        - `SECONDARY`
        - `STANDALONE`
        - `CONFIG`
        - `MONGOS`
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[str]):
        pulumi.set(self, "label", value)


if not MYPY:
    class GetAlertConfigurationsListOptionArgsDict(TypedDict):
        include_count: NotRequired[bool]
        items_per_page: NotRequired[int]
        page_num: NotRequired[int]
elif False:
    GetAlertConfigurationsListOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAlertConfigurationsListOptionArgs:
    def __init__(__self__, *,
                 include_count: Optional[bool] = None,
                 items_per_page: Optional[int] = None,
                 page_num: Optional[int] = None):
        if include_count is not None:
            pulumi.set(__self__, "include_count", include_count)
        if items_per_page is not None:
            pulumi.set(__self__, "items_per_page", items_per_page)
        if page_num is not None:
            pulumi.set(__self__, "page_num", page_num)

    @property
    @pulumi.getter(name="includeCount")
    def include_count(self) -> Optional[bool]:
        return pulumi.get(self, "include_count")

    @include_count.setter
    def include_count(self, value: Optional[bool]):
        pulumi.set(self, "include_count", value)

    @property
    @pulumi.getter(name="itemsPerPage")
    def items_per_page(self) -> Optional[int]:
        return pulumi.get(self, "items_per_page")

    @items_per_page.setter
    def items_per_page(self, value: Optional[int]):
        pulumi.set(self, "items_per_page", value)

    @property
    @pulumi.getter(name="pageNum")
    def page_num(self) -> Optional[int]:
        return pulumi.get(self, "page_num")

    @page_num.setter
    def page_num(self, value: Optional[int]):
        pulumi.set(self, "page_num", value)


if not MYPY:
    class GetCloudProviderAccessSetupAzureConfigArgsDict(TypedDict):
        atlas_azure_app_id: str
        """
        Azure Active Directory Application ID of Atlas.
        """
        service_principal_id: str
        """
        UUID string that identifies the Azure Service Principal.
        """
        tenant_id: str
        """
        UUID String that identifies the Azure Active Directory Tenant ID.
        """
elif False:
    GetCloudProviderAccessSetupAzureConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCloudProviderAccessSetupAzureConfigArgs:
    def __init__(__self__, *,
                 atlas_azure_app_id: str,
                 service_principal_id: str,
                 tenant_id: str):
        """
        :param str atlas_azure_app_id: Azure Active Directory Application ID of Atlas.
        :param str service_principal_id: UUID string that identifies the Azure Service Principal.
        :param str tenant_id: UUID String that identifies the Azure Active Directory Tenant ID.
        """
        pulumi.set(__self__, "atlas_azure_app_id", atlas_azure_app_id)
        pulumi.set(__self__, "service_principal_id", service_principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="atlasAzureAppId")
    def atlas_azure_app_id(self) -> str:
        """
        Azure Active Directory Application ID of Atlas.
        """
        return pulumi.get(self, "atlas_azure_app_id")

    @atlas_azure_app_id.setter
    def atlas_azure_app_id(self, value: str):
        pulumi.set(self, "atlas_azure_app_id", value)

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> str:
        """
        UUID string that identifies the Azure Service Principal.
        """
        return pulumi.get(self, "service_principal_id")

    @service_principal_id.setter
    def service_principal_id(self, value: str):
        pulumi.set(self, "service_principal_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        UUID String that identifies the Azure Active Directory Tenant ID.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: str):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class GetCustomDbRoleInheritedRoleArgsDict(TypedDict):
        database_name: str
        """
        (Required) Database on which the inherited role is granted.
        """
        role_name: str
        """
        Name of the custom role.
        """
elif False:
    GetCustomDbRoleInheritedRoleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCustomDbRoleInheritedRoleArgs:
    def __init__(__self__, *,
                 database_name: str,
                 role_name: str):
        """
        :param str database_name: (Required) Database on which the inherited role is granted.
        :param str role_name: Name of the custom role.
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "role_name", role_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        (Required) Database on which the inherited role is granted.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: str):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        """
        Name of the custom role.
        """
        return pulumi.get(self, "role_name")

    @role_name.setter
    def role_name(self, value: str):
        pulumi.set(self, "role_name", value)


if not MYPY:
    class GetFederatedDatabaseInstanceCloudProviderConfigArgsDict(TypedDict):
        aws: 'GetFederatedDatabaseInstanceCloudProviderConfigAwsArgsDict'
elif False:
    GetFederatedDatabaseInstanceCloudProviderConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFederatedDatabaseInstanceCloudProviderConfigArgs:
    def __init__(__self__, *,
                 aws: 'GetFederatedDatabaseInstanceCloudProviderConfigAwsArgs'):
        pulumi.set(__self__, "aws", aws)

    @property
    @pulumi.getter
    def aws(self) -> 'GetFederatedDatabaseInstanceCloudProviderConfigAwsArgs':
        return pulumi.get(self, "aws")

    @aws.setter
    def aws(self, value: 'GetFederatedDatabaseInstanceCloudProviderConfigAwsArgs'):
        pulumi.set(self, "aws", value)


if not MYPY:
    class GetFederatedDatabaseInstanceCloudProviderConfigAwsArgsDict(TypedDict):
        external_id: str
        """
        Unique identifier associated with the IAM Role that the Federated Database Instance assumes when accessing the data stores.
        """
        iam_assumed_role_arn: str
        """
        Amazon Resource Name (ARN) of the IAM Role that the Federated Database Instance assumes when accessing S3 Bucket data stores. The IAM Role must support the following actions against each S3 bucket:
        * `s3:GetObject`
        * `s3:ListBucket`
        * `s3:GetObjectVersion`
        """
        iam_user_arn: str
        """
        Amazon Resource Name (ARN) of the user that the Federated Database Instance assumes when accessing S3 Bucket data stores.
        """
        role_id: str
        """
        Unique identifier of the role that the data lake can use to access the data stores.
        """
        test_s3_bucket: str
elif False:
    GetFederatedDatabaseInstanceCloudProviderConfigAwsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFederatedDatabaseInstanceCloudProviderConfigAwsArgs:
    def __init__(__self__, *,
                 external_id: str,
                 iam_assumed_role_arn: str,
                 iam_user_arn: str,
                 role_id: str,
                 test_s3_bucket: str):
        """
        :param str external_id: Unique identifier associated with the IAM Role that the Federated Database Instance assumes when accessing the data stores.
        :param str iam_assumed_role_arn: Amazon Resource Name (ARN) of the IAM Role that the Federated Database Instance assumes when accessing S3 Bucket data stores. The IAM Role must support the following actions against each S3 bucket:
               * `s3:GetObject`
               * `s3:ListBucket`
               * `s3:GetObjectVersion`
        :param str iam_user_arn: Amazon Resource Name (ARN) of the user that the Federated Database Instance assumes when accessing S3 Bucket data stores.
        :param str role_id: Unique identifier of the role that the data lake can use to access the data stores.
        """
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "iam_assumed_role_arn", iam_assumed_role_arn)
        pulumi.set(__self__, "iam_user_arn", iam_user_arn)
        pulumi.set(__self__, "role_id", role_id)
        pulumi.set(__self__, "test_s3_bucket", test_s3_bucket)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> str:
        """
        Unique identifier associated with the IAM Role that the Federated Database Instance assumes when accessing the data stores.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: str):
        pulumi.set(self, "external_id", value)

    @property
    @pulumi.getter(name="iamAssumedRoleArn")
    def iam_assumed_role_arn(self) -> str:
        """
        Amazon Resource Name (ARN) of the IAM Role that the Federated Database Instance assumes when accessing S3 Bucket data stores. The IAM Role must support the following actions against each S3 bucket:
        * `s3:GetObject`
        * `s3:ListBucket`
        * `s3:GetObjectVersion`
        """
        return pulumi.get(self, "iam_assumed_role_arn")

    @iam_assumed_role_arn.setter
    def iam_assumed_role_arn(self, value: str):
        pulumi.set(self, "iam_assumed_role_arn", value)

    @property
    @pulumi.getter(name="iamUserArn")
    def iam_user_arn(self) -> str:
        """
        Amazon Resource Name (ARN) of the user that the Federated Database Instance assumes when accessing S3 Bucket data stores.
        """
        return pulumi.get(self, "iam_user_arn")

    @iam_user_arn.setter
    def iam_user_arn(self, value: str):
        pulumi.set(self, "iam_user_arn", value)

    @property
    @pulumi.getter(name="roleId")
    def role_id(self) -> str:
        """
        Unique identifier of the role that the data lake can use to access the data stores.
        """
        return pulumi.get(self, "role_id")

    @role_id.setter
    def role_id(self, value: str):
        pulumi.set(self, "role_id", value)

    @property
    @pulumi.getter(name="testS3Bucket")
    def test_s3_bucket(self) -> str:
        return pulumi.get(self, "test_s3_bucket")

    @test_s3_bucket.setter
    def test_s3_bucket(self, value: str):
        pulumi.set(self, "test_s3_bucket", value)


if not MYPY:
    class GetGlobalClusterConfigManagedNamespaceArgsDict(TypedDict):
        collection: str
        """
        (Required) The name of the collection associated with the managed namespace.
        """
        custom_shard_key: str
        """
        (Required)	The custom shard key for the collection. Global Clusters require a compound shard key consisting of a location field and a user-selected second key, the custom shard key.
        """
        db: str
        """
        (Required) The name of the database containing the collection.
        """
        is_custom_shard_key_hashed: bool
        """
        Specifies whether the custom shard key for the collection is [hashed](https://docs.mongodb.com/manual/reference/method/sh.shardCollection/#hashed-shard-keys). If omitted, defaults to `false`. If `false`, Atlas uses [ranged sharding](https://docs.mongodb.com/manual/core/ranged-sharding/). This is only available for Atlas clusters with MongoDB v4.4 and later.
        """
        is_shard_key_unique: bool
        """
        Specifies whether the underlying index enforces a unique constraint. If omitted, defaults to false. You cannot specify true when using [hashed shard keys](https://docs.mongodb.com/manual/core/hashed-sharding/#std-label-sharding-hashed).
        """
elif False:
    GetGlobalClusterConfigManagedNamespaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGlobalClusterConfigManagedNamespaceArgs:
    def __init__(__self__, *,
                 collection: str,
                 custom_shard_key: str,
                 db: str,
                 is_custom_shard_key_hashed: bool,
                 is_shard_key_unique: bool):
        """
        :param str collection: (Required) The name of the collection associated with the managed namespace.
        :param str custom_shard_key: (Required)	The custom shard key for the collection. Global Clusters require a compound shard key consisting of a location field and a user-selected second key, the custom shard key.
        :param str db: (Required) The name of the database containing the collection.
        :param bool is_custom_shard_key_hashed: Specifies whether the custom shard key for the collection is [hashed](https://docs.mongodb.com/manual/reference/method/sh.shardCollection/#hashed-shard-keys). If omitted, defaults to `false`. If `false`, Atlas uses [ranged sharding](https://docs.mongodb.com/manual/core/ranged-sharding/). This is only available for Atlas clusters with MongoDB v4.4 and later.
        :param bool is_shard_key_unique: Specifies whether the underlying index enforces a unique constraint. If omitted, defaults to false. You cannot specify true when using [hashed shard keys](https://docs.mongodb.com/manual/core/hashed-sharding/#std-label-sharding-hashed).
        """
        pulumi.set(__self__, "collection", collection)
        pulumi.set(__self__, "custom_shard_key", custom_shard_key)
        pulumi.set(__self__, "db", db)
        pulumi.set(__self__, "is_custom_shard_key_hashed", is_custom_shard_key_hashed)
        pulumi.set(__self__, "is_shard_key_unique", is_shard_key_unique)

    @property
    @pulumi.getter
    def collection(self) -> str:
        """
        (Required) The name of the collection associated with the managed namespace.
        """
        return pulumi.get(self, "collection")

    @collection.setter
    def collection(self, value: str):
        pulumi.set(self, "collection", value)

    @property
    @pulumi.getter(name="customShardKey")
    def custom_shard_key(self) -> str:
        """
        (Required)	The custom shard key for the collection. Global Clusters require a compound shard key consisting of a location field and a user-selected second key, the custom shard key.
        """
        return pulumi.get(self, "custom_shard_key")

    @custom_shard_key.setter
    def custom_shard_key(self, value: str):
        pulumi.set(self, "custom_shard_key", value)

    @property
    @pulumi.getter
    def db(self) -> str:
        """
        (Required) The name of the database containing the collection.
        """
        return pulumi.get(self, "db")

    @db.setter
    def db(self, value: str):
        pulumi.set(self, "db", value)

    @property
    @pulumi.getter(name="isCustomShardKeyHashed")
    def is_custom_shard_key_hashed(self) -> bool:
        """
        Specifies whether the custom shard key for the collection is [hashed](https://docs.mongodb.com/manual/reference/method/sh.shardCollection/#hashed-shard-keys). If omitted, defaults to `false`. If `false`, Atlas uses [ranged sharding](https://docs.mongodb.com/manual/core/ranged-sharding/). This is only available for Atlas clusters with MongoDB v4.4 and later.
        """
        return pulumi.get(self, "is_custom_shard_key_hashed")

    @is_custom_shard_key_hashed.setter
    def is_custom_shard_key_hashed(self, value: bool):
        pulumi.set(self, "is_custom_shard_key_hashed", value)

    @property
    @pulumi.getter(name="isShardKeyUnique")
    def is_shard_key_unique(self) -> bool:
        """
        Specifies whether the underlying index enforces a unique constraint. If omitted, defaults to false. You cannot specify true when using [hashed shard keys](https://docs.mongodb.com/manual/core/hashed-sharding/#std-label-sharding-hashed).
        """
        return pulumi.get(self, "is_shard_key_unique")

    @is_shard_key_unique.setter
    def is_shard_key_unique(self, value: bool):
        pulumi.set(self, "is_shard_key_unique", value)


if not MYPY:
    class GetServerlessInstanceLinkArgsDict(TypedDict):
        href: str
        rel: str
elif False:
    GetServerlessInstanceLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetServerlessInstanceLinkArgs:
    def __init__(__self__, *,
                 href: str,
                 rel: str):
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> str:
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: str):
        pulumi.set(self, "href", value)

    @property
    @pulumi.getter
    def rel(self) -> str:
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: str):
        pulumi.set(self, "rel", value)


