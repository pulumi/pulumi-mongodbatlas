// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.mongodbatlas;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Integer;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class FederatedQueryLimitArgs extends com.pulumi.resources.ResourceArgs {

    public static final FederatedQueryLimitArgs Empty = new FederatedQueryLimitArgs();

    /**
     * Default value of the limit.
     * 
     */
    @Import(name="defaultLimit")
    private @Nullable Output<Integer> defaultLimit;

    /**
     * @return Default value of the limit.
     * 
     */
    public Optional<Output<Integer>> defaultLimit() {
        return Optional.ofNullable(this.defaultLimit);
    }

    /**
     * String enum that indicates whether the identity provider is active or not. Accepted values are:
     * * `bytesProcessed.query`: Limit on the number of bytes processed during a single data federation query.
     * * `bytesProcessed.daily`: Limit on the number of bytes processed for the data federation instance for the current day.
     * * `bytesProcessed.weekly`: Limit on the number of bytes processed for the data federation instance for the current week.
     * * `bytesProcessed.monthly`: Limit on the number of bytes processed for the data federation instance for the current month.
     * 
     */
    @Import(name="limitName", required=true)
    private Output<String> limitName;

    /**
     * @return String enum that indicates whether the identity provider is active or not. Accepted values are:
     * * `bytesProcessed.query`: Limit on the number of bytes processed during a single data federation query.
     * * `bytesProcessed.daily`: Limit on the number of bytes processed for the data federation instance for the current day.
     * * `bytesProcessed.weekly`: Limit on the number of bytes processed for the data federation instance for the current week.
     * * `bytesProcessed.monthly`: Limit on the number of bytes processed for the data federation instance for the current month.
     * 
     */
    public Output<String> limitName() {
        return this.limitName;
    }

    @Import(name="maximumLimit")
    private @Nullable Output<Integer> maximumLimit;

    public Optional<Output<Integer>> maximumLimit() {
        return Optional.ofNullable(this.maximumLimit);
    }

    /**
     * String enum that identifies action to take when the usage limit is exceeded. If limit span is set to QUERY, this is ignored because MongoDB Cloud stops the query when it exceeds the usage limit. Accepted values are &#34;BLOCK&#34; OR &#34;BLOCK_AND_KILL&#34;
     * 
     */
    @Import(name="overrunPolicy", required=true)
    private Output<String> overrunPolicy;

    /**
     * @return String enum that identifies action to take when the usage limit is exceeded. If limit span is set to QUERY, this is ignored because MongoDB Cloud stops the query when it exceeds the usage limit. Accepted values are &#34;BLOCK&#34; OR &#34;BLOCK_AND_KILL&#34;
     * 
     */
    public Output<String> overrunPolicy() {
        return this.overrunPolicy;
    }

    /**
     * The unique ID for the project to create a Federated Database Instance.
     * 
     */
    @Import(name="projectId", required=true)
    private Output<String> projectId;

    /**
     * @return The unique ID for the project to create a Federated Database Instance.
     * 
     */
    public Output<String> projectId() {
        return this.projectId;
    }

    /**
     * Name of the Atlas Federated Database Instance.
     * 
     */
    @Import(name="tenantName", required=true)
    private Output<String> tenantName;

    /**
     * @return Name of the Atlas Federated Database Instance.
     * 
     */
    public Output<String> tenantName() {
        return this.tenantName;
    }

    /**
     * Amount to set the limit to.
     * 
     */
    @Import(name="value", required=true)
    private Output<Integer> value;

    /**
     * @return Amount to set the limit to.
     * 
     */
    public Output<Integer> value() {
        return this.value;
    }

    private FederatedQueryLimitArgs() {}

    private FederatedQueryLimitArgs(FederatedQueryLimitArgs $) {
        this.defaultLimit = $.defaultLimit;
        this.limitName = $.limitName;
        this.maximumLimit = $.maximumLimit;
        this.overrunPolicy = $.overrunPolicy;
        this.projectId = $.projectId;
        this.tenantName = $.tenantName;
        this.value = $.value;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(FederatedQueryLimitArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private FederatedQueryLimitArgs $;

        public Builder() {
            $ = new FederatedQueryLimitArgs();
        }

        public Builder(FederatedQueryLimitArgs defaults) {
            $ = new FederatedQueryLimitArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param defaultLimit Default value of the limit.
         * 
         * @return builder
         * 
         */
        public Builder defaultLimit(@Nullable Output<Integer> defaultLimit) {
            $.defaultLimit = defaultLimit;
            return this;
        }

        /**
         * @param defaultLimit Default value of the limit.
         * 
         * @return builder
         * 
         */
        public Builder defaultLimit(Integer defaultLimit) {
            return defaultLimit(Output.of(defaultLimit));
        }

        /**
         * @param limitName String enum that indicates whether the identity provider is active or not. Accepted values are:
         * * `bytesProcessed.query`: Limit on the number of bytes processed during a single data federation query.
         * * `bytesProcessed.daily`: Limit on the number of bytes processed for the data federation instance for the current day.
         * * `bytesProcessed.weekly`: Limit on the number of bytes processed for the data federation instance for the current week.
         * * `bytesProcessed.monthly`: Limit on the number of bytes processed for the data federation instance for the current month.
         * 
         * @return builder
         * 
         */
        public Builder limitName(Output<String> limitName) {
            $.limitName = limitName;
            return this;
        }

        /**
         * @param limitName String enum that indicates whether the identity provider is active or not. Accepted values are:
         * * `bytesProcessed.query`: Limit on the number of bytes processed during a single data federation query.
         * * `bytesProcessed.daily`: Limit on the number of bytes processed for the data federation instance for the current day.
         * * `bytesProcessed.weekly`: Limit on the number of bytes processed for the data federation instance for the current week.
         * * `bytesProcessed.monthly`: Limit on the number of bytes processed for the data federation instance for the current month.
         * 
         * @return builder
         * 
         */
        public Builder limitName(String limitName) {
            return limitName(Output.of(limitName));
        }

        public Builder maximumLimit(@Nullable Output<Integer> maximumLimit) {
            $.maximumLimit = maximumLimit;
            return this;
        }

        public Builder maximumLimit(Integer maximumLimit) {
            return maximumLimit(Output.of(maximumLimit));
        }

        /**
         * @param overrunPolicy String enum that identifies action to take when the usage limit is exceeded. If limit span is set to QUERY, this is ignored because MongoDB Cloud stops the query when it exceeds the usage limit. Accepted values are &#34;BLOCK&#34; OR &#34;BLOCK_AND_KILL&#34;
         * 
         * @return builder
         * 
         */
        public Builder overrunPolicy(Output<String> overrunPolicy) {
            $.overrunPolicy = overrunPolicy;
            return this;
        }

        /**
         * @param overrunPolicy String enum that identifies action to take when the usage limit is exceeded. If limit span is set to QUERY, this is ignored because MongoDB Cloud stops the query when it exceeds the usage limit. Accepted values are &#34;BLOCK&#34; OR &#34;BLOCK_AND_KILL&#34;
         * 
         * @return builder
         * 
         */
        public Builder overrunPolicy(String overrunPolicy) {
            return overrunPolicy(Output.of(overrunPolicy));
        }

        /**
         * @param projectId The unique ID for the project to create a Federated Database Instance.
         * 
         * @return builder
         * 
         */
        public Builder projectId(Output<String> projectId) {
            $.projectId = projectId;
            return this;
        }

        /**
         * @param projectId The unique ID for the project to create a Federated Database Instance.
         * 
         * @return builder
         * 
         */
        public Builder projectId(String projectId) {
            return projectId(Output.of(projectId));
        }

        /**
         * @param tenantName Name of the Atlas Federated Database Instance.
         * 
         * @return builder
         * 
         */
        public Builder tenantName(Output<String> tenantName) {
            $.tenantName = tenantName;
            return this;
        }

        /**
         * @param tenantName Name of the Atlas Federated Database Instance.
         * 
         * @return builder
         * 
         */
        public Builder tenantName(String tenantName) {
            return tenantName(Output.of(tenantName));
        }

        /**
         * @param value Amount to set the limit to.
         * 
         * @return builder
         * 
         */
        public Builder value(Output<Integer> value) {
            $.value = value;
            return this;
        }

        /**
         * @param value Amount to set the limit to.
         * 
         * @return builder
         * 
         */
        public Builder value(Integer value) {
            return value(Output.of(value));
        }

        public FederatedQueryLimitArgs build() {
            if ($.limitName == null) {
                throw new MissingRequiredPropertyException("FederatedQueryLimitArgs", "limitName");
            }
            if ($.overrunPolicy == null) {
                throw new MissingRequiredPropertyException("FederatedQueryLimitArgs", "overrunPolicy");
            }
            if ($.projectId == null) {
                throw new MissingRequiredPropertyException("FederatedQueryLimitArgs", "projectId");
            }
            if ($.tenantName == null) {
                throw new MissingRequiredPropertyException("FederatedQueryLimitArgs", "tenantName");
            }
            if ($.value == null) {
                throw new MissingRequiredPropertyException("FederatedQueryLimitArgs", "value");
            }
            return $;
        }
    }

}
