// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.mongodbatlas;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.mongodbatlas.inputs.OnlineArchiveCriteriaArgs;
import com.pulumi.mongodbatlas.inputs.OnlineArchivePartitionFieldArgs;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class OnlineArchiveArgs extends com.pulumi.resources.ResourceArgs {

    public static final OnlineArchiveArgs Empty = new OnlineArchiveArgs();

    /**
     * Name of the cluster that contains the collection.
     * 
     */
    @Import(name="clusterName", required=true)
    private Output<String> clusterName;

    /**
     * @return Name of the cluster that contains the collection.
     * 
     */
    public Output<String> clusterName() {
        return this.clusterName;
    }

    /**
     * Name of the collection.
     * 
     */
    @Import(name="collName", required=true)
    private Output<String> collName;

    /**
     * @return Name of the collection.
     * 
     */
    public Output<String> collName() {
        return this.collName;
    }

    /**
     * Classification of MongoDB database collection that you want to return, &#34;TIMESERIES&#34; or &#34;STANDARD&#34;. Default is &#34;STANDARD&#34;.
     * 
     */
    @Import(name="collectionType")
    private @Nullable Output<String> collectionType;

    /**
     * @return Classification of MongoDB database collection that you want to return, &#34;TIMESERIES&#34; or &#34;STANDARD&#34;. Default is &#34;STANDARD&#34;.
     * 
     */
    public Optional<Output<String>> collectionType() {
        return Optional.ofNullable(this.collectionType);
    }

    /**
     * Criteria to use for archiving data.
     * 
     */
    @Import(name="criteria", required=true)
    private Output<OnlineArchiveCriteriaArgs> criteria;

    /**
     * @return Criteria to use for archiving data.
     * 
     */
    public Output<OnlineArchiveCriteriaArgs> criteria() {
        return this.criteria;
    }

    /**
     * Name of the database that contains the collection.
     * 
     */
    @Import(name="dbName", required=true)
    private Output<String> dbName;

    /**
     * @return Name of the database that contains the collection.
     * 
     */
    public Output<String> dbName() {
        return this.dbName;
    }

    /**
     * Fields to use to partition data. You can specify up to two frequently queried fields to use for partitioning data. Note that queries that don’t contain the specified fields will require a full collection scan of all archived documents, which will take longer and increase your costs. To learn more about how partition improves query performance, see [Data Structure in S3](https://docs.mongodb.com/datalake/admin/optimize-query-performance/#data-structure-in-s3). The value of a partition field can be up to a maximum of 700 characters. Documents with values exceeding 700 characters are not archived.
     * 
     */
    @Import(name="partitionFields")
    private @Nullable Output<List<OnlineArchivePartitionFieldArgs>> partitionFields;

    /**
     * @return Fields to use to partition data. You can specify up to two frequently queried fields to use for partitioning data. Note that queries that don’t contain the specified fields will require a full collection scan of all archived documents, which will take longer and increase your costs. To learn more about how partition improves query performance, see [Data Structure in S3](https://docs.mongodb.com/datalake/admin/optimize-query-performance/#data-structure-in-s3). The value of a partition field can be up to a maximum of 700 characters. Documents with values exceeding 700 characters are not archived.
     * 
     */
    public Optional<Output<List<OnlineArchivePartitionFieldArgs>>> partitionFields() {
        return Optional.ofNullable(this.partitionFields);
    }

    /**
     * State of the online archive. This is required for pausing an active or resume a paused online archive. The resume request will fail if the collection has another active online archive.
     * 
     */
    @Import(name="paused")
    private @Nullable Output<Boolean> paused;

    /**
     * @return State of the online archive. This is required for pausing an active or resume a paused online archive. The resume request will fail if the collection has another active online archive.
     * 
     */
    public Optional<Output<Boolean>> paused() {
        return Optional.ofNullable(this.paused);
    }

    /**
     * The unique ID for the project
     * 
     */
    @Import(name="projectId", required=true)
    private Output<String> projectId;

    /**
     * @return The unique ID for the project
     * 
     */
    public Output<String> projectId() {
        return this.projectId;
    }

    @Import(name="syncCreation")
    private @Nullable Output<Boolean> syncCreation;

    public Optional<Output<Boolean>> syncCreation() {
        return Optional.ofNullable(this.syncCreation);
    }

    private OnlineArchiveArgs() {}

    private OnlineArchiveArgs(OnlineArchiveArgs $) {
        this.clusterName = $.clusterName;
        this.collName = $.collName;
        this.collectionType = $.collectionType;
        this.criteria = $.criteria;
        this.dbName = $.dbName;
        this.partitionFields = $.partitionFields;
        this.paused = $.paused;
        this.projectId = $.projectId;
        this.syncCreation = $.syncCreation;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(OnlineArchiveArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private OnlineArchiveArgs $;

        public Builder() {
            $ = new OnlineArchiveArgs();
        }

        public Builder(OnlineArchiveArgs defaults) {
            $ = new OnlineArchiveArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param clusterName Name of the cluster that contains the collection.
         * 
         * @return builder
         * 
         */
        public Builder clusterName(Output<String> clusterName) {
            $.clusterName = clusterName;
            return this;
        }

        /**
         * @param clusterName Name of the cluster that contains the collection.
         * 
         * @return builder
         * 
         */
        public Builder clusterName(String clusterName) {
            return clusterName(Output.of(clusterName));
        }

        /**
         * @param collName Name of the collection.
         * 
         * @return builder
         * 
         */
        public Builder collName(Output<String> collName) {
            $.collName = collName;
            return this;
        }

        /**
         * @param collName Name of the collection.
         * 
         * @return builder
         * 
         */
        public Builder collName(String collName) {
            return collName(Output.of(collName));
        }

        /**
         * @param collectionType Classification of MongoDB database collection that you want to return, &#34;TIMESERIES&#34; or &#34;STANDARD&#34;. Default is &#34;STANDARD&#34;.
         * 
         * @return builder
         * 
         */
        public Builder collectionType(@Nullable Output<String> collectionType) {
            $.collectionType = collectionType;
            return this;
        }

        /**
         * @param collectionType Classification of MongoDB database collection that you want to return, &#34;TIMESERIES&#34; or &#34;STANDARD&#34;. Default is &#34;STANDARD&#34;.
         * 
         * @return builder
         * 
         */
        public Builder collectionType(String collectionType) {
            return collectionType(Output.of(collectionType));
        }

        /**
         * @param criteria Criteria to use for archiving data.
         * 
         * @return builder
         * 
         */
        public Builder criteria(Output<OnlineArchiveCriteriaArgs> criteria) {
            $.criteria = criteria;
            return this;
        }

        /**
         * @param criteria Criteria to use for archiving data.
         * 
         * @return builder
         * 
         */
        public Builder criteria(OnlineArchiveCriteriaArgs criteria) {
            return criteria(Output.of(criteria));
        }

        /**
         * @param dbName Name of the database that contains the collection.
         * 
         * @return builder
         * 
         */
        public Builder dbName(Output<String> dbName) {
            $.dbName = dbName;
            return this;
        }

        /**
         * @param dbName Name of the database that contains the collection.
         * 
         * @return builder
         * 
         */
        public Builder dbName(String dbName) {
            return dbName(Output.of(dbName));
        }

        /**
         * @param partitionFields Fields to use to partition data. You can specify up to two frequently queried fields to use for partitioning data. Note that queries that don’t contain the specified fields will require a full collection scan of all archived documents, which will take longer and increase your costs. To learn more about how partition improves query performance, see [Data Structure in S3](https://docs.mongodb.com/datalake/admin/optimize-query-performance/#data-structure-in-s3). The value of a partition field can be up to a maximum of 700 characters. Documents with values exceeding 700 characters are not archived.
         * 
         * @return builder
         * 
         */
        public Builder partitionFields(@Nullable Output<List<OnlineArchivePartitionFieldArgs>> partitionFields) {
            $.partitionFields = partitionFields;
            return this;
        }

        /**
         * @param partitionFields Fields to use to partition data. You can specify up to two frequently queried fields to use for partitioning data. Note that queries that don’t contain the specified fields will require a full collection scan of all archived documents, which will take longer and increase your costs. To learn more about how partition improves query performance, see [Data Structure in S3](https://docs.mongodb.com/datalake/admin/optimize-query-performance/#data-structure-in-s3). The value of a partition field can be up to a maximum of 700 characters. Documents with values exceeding 700 characters are not archived.
         * 
         * @return builder
         * 
         */
        public Builder partitionFields(List<OnlineArchivePartitionFieldArgs> partitionFields) {
            return partitionFields(Output.of(partitionFields));
        }

        /**
         * @param partitionFields Fields to use to partition data. You can specify up to two frequently queried fields to use for partitioning data. Note that queries that don’t contain the specified fields will require a full collection scan of all archived documents, which will take longer and increase your costs. To learn more about how partition improves query performance, see [Data Structure in S3](https://docs.mongodb.com/datalake/admin/optimize-query-performance/#data-structure-in-s3). The value of a partition field can be up to a maximum of 700 characters. Documents with values exceeding 700 characters are not archived.
         * 
         * @return builder
         * 
         */
        public Builder partitionFields(OnlineArchivePartitionFieldArgs... partitionFields) {
            return partitionFields(List.of(partitionFields));
        }

        /**
         * @param paused State of the online archive. This is required for pausing an active or resume a paused online archive. The resume request will fail if the collection has another active online archive.
         * 
         * @return builder
         * 
         */
        public Builder paused(@Nullable Output<Boolean> paused) {
            $.paused = paused;
            return this;
        }

        /**
         * @param paused State of the online archive. This is required for pausing an active or resume a paused online archive. The resume request will fail if the collection has another active online archive.
         * 
         * @return builder
         * 
         */
        public Builder paused(Boolean paused) {
            return paused(Output.of(paused));
        }

        /**
         * @param projectId The unique ID for the project
         * 
         * @return builder
         * 
         */
        public Builder projectId(Output<String> projectId) {
            $.projectId = projectId;
            return this;
        }

        /**
         * @param projectId The unique ID for the project
         * 
         * @return builder
         * 
         */
        public Builder projectId(String projectId) {
            return projectId(Output.of(projectId));
        }

        public Builder syncCreation(@Nullable Output<Boolean> syncCreation) {
            $.syncCreation = syncCreation;
            return this;
        }

        public Builder syncCreation(Boolean syncCreation) {
            return syncCreation(Output.of(syncCreation));
        }

        public OnlineArchiveArgs build() {
            $.clusterName = Objects.requireNonNull($.clusterName, "expected parameter 'clusterName' to be non-null");
            $.collName = Objects.requireNonNull($.collName, "expected parameter 'collName' to be non-null");
            $.criteria = Objects.requireNonNull($.criteria, "expected parameter 'criteria' to be non-null");
            $.dbName = Objects.requireNonNull($.dbName, "expected parameter 'dbName' to be non-null");
            $.projectId = Objects.requireNonNull($.projectId, "expected parameter 'projectId' to be non-null");
            return $;
        }
    }

}
