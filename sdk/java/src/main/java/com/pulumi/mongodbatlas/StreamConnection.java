// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.mongodbatlas;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.mongodbatlas.StreamConnectionArgs;
import com.pulumi.mongodbatlas.Utilities;
import com.pulumi.mongodbatlas.inputs.StreamConnectionState;
import com.pulumi.mongodbatlas.outputs.StreamConnectionAuthentication;
import com.pulumi.mongodbatlas.outputs.StreamConnectionAws;
import com.pulumi.mongodbatlas.outputs.StreamConnectionDbRoleToExecute;
import com.pulumi.mongodbatlas.outputs.StreamConnectionNetworking;
import com.pulumi.mongodbatlas.outputs.StreamConnectionSchemaRegistryAuthentication;
import com.pulumi.mongodbatlas.outputs.StreamConnectionSecurity;
import com.pulumi.mongodbatlas.outputs.StreamConnectionTimeouts;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * `mongodbatlas.StreamConnection` provides a Stream Connection resource. The resource lets you create, edit, and delete stream instance connections.
 * 
 * &gt; **IMPORTANT:** All arguments including the Kafka authentication password will be stored in the raw state as plaintext. Read more about sensitive data in state.
 * 
 * ## Example Usage
 * 
 * ### Example Cluster Connection
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.mongodbatlas.StreamConnection;
 * import com.pulumi.mongodbatlas.StreamConnectionArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var test = new StreamConnection("test", StreamConnectionArgs.builder()
 *             .projectId(projectId)
 *             .workspaceName("WorkspaceName")
 *             .connectionName("ConnectionName")
 *             .type("Cluster")
 *             .clusterName("Cluster0")
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ### Further Examples
 * - Atlas Stream Connection
 * 
 * ### Example Cross Project Cluster Connection
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.mongodbatlas.StreamConnection;
 * import com.pulumi.mongodbatlas.StreamConnectionArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var test = new StreamConnection("test", StreamConnectionArgs.builder()
 *             .projectId(projectId)
 *             .workspaceName("WorskpaceName")
 *             .connectionName("ConnectionName")
 *             .type("Cluster")
 *             .clusterName("OtherCluster")
 *             .clusterProjectId(otherProjectId)
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ### Example Kafka SASL Plaintext Connection
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.mongodbatlas.StreamConnection;
 * import com.pulumi.mongodbatlas.StreamConnectionArgs;
 * import com.pulumi.mongodbatlas.inputs.StreamConnectionAuthenticationArgs;
 * import com.pulumi.mongodbatlas.inputs.StreamConnectionSecurityArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var test = new StreamConnection("test", StreamConnectionArgs.builder()
 *             .projectId(projectId)
 *             .workspaceName("NewWorkspace")
 *             .connectionName("KafkaConnection")
 *             .type("Kafka")
 *             .authentication(StreamConnectionAuthenticationArgs.builder()
 *                 .mechanism("SCRAM-256")
 *                 .username("user")
 *                 .password("somepassword")
 *                 .build())
 *             .security(StreamConnectionSecurityArgs.builder()
 *                 .protocol("SASL_PLAINTEXT")
 *                 .build())
 *             .config(Map.of("auto.offset.reset", "latest"))
 *             .bootstrapServers("localhost:9091,localhost:9092")
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ### Example Kafka SASL OAuthbearer Connection
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.mongodbatlas.StreamConnection;
 * import com.pulumi.mongodbatlas.StreamConnectionArgs;
 * import com.pulumi.mongodbatlas.inputs.StreamConnectionAuthenticationArgs;
 * import com.pulumi.mongodbatlas.inputs.StreamConnectionSecurityArgs;
 * import com.pulumi.mongodbatlas.inputs.StreamConnectionNetworkingArgs;
 * import com.pulumi.mongodbatlas.inputs.StreamConnectionNetworkingAccessArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var example_kafka_oauthbearer = new StreamConnection("example-kafka-oauthbearer", StreamConnectionArgs.builder()
 *             .projectId(projectId)
 *             .workspaceName(example.workspaceName())
 *             .connectionName("KafkaOAuthbearerConnection")
 *             .type("Kafka")
 *             .authentication(StreamConnectionAuthenticationArgs.builder()
 *                 .mechanism("OAUTHBEARER")
 *                 .method("OIDC")
 *                 .tokenEndpointUrl("https://example.com/oauth/token")
 *                 .clientId("auth0Client")
 *                 .clientSecret(kafkaClientSecret)
 *                 .scope("read:messages write:messages")
 *                 .saslOauthbearerExtensions("logicalCluster=lkc-kmom,identityPoolId=pool-lAr")
 *                 .build())
 *             .bootstrapServers("localhost:9092,localhost:9092")
 *             .config(Map.of("auto.offset.reset", "earliest"))
 *             .security(StreamConnectionSecurityArgs.builder()
 *                 .protocol("SASL_PLAINTEXT")
 *                 .build())
 *             .networking(StreamConnectionNetworkingArgs.builder()
 *                 .access(StreamConnectionNetworkingAccessArgs.builder()
 *                     .type("PUBLIC")
 *                     .build())
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ### Example Kafka SASL SSL Connection
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.mongodbatlas.StreamConnection;
 * import com.pulumi.mongodbatlas.StreamConnectionArgs;
 * import com.pulumi.mongodbatlas.inputs.StreamConnectionAuthenticationArgs;
 * import com.pulumi.mongodbatlas.inputs.StreamConnectionSecurityArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var test = new StreamConnection("test", StreamConnectionArgs.builder()
 *             .projectId(projectId)
 *             .workspaceName("NewWorkspace")
 *             .connectionName("KafkaConnection")
 *             .type("Kafka")
 *             .authentication(StreamConnectionAuthenticationArgs.builder()
 *                 .mechanism("PLAIN")
 *                 .username("user")
 *                 .password("somepassword")
 *                 .build())
 *             .security(StreamConnectionSecurityArgs.builder()
 *                 .protocol("SASL_SSL")
 *                 .brokerPublicCertificate("-----BEGIN CERTIFICATE-----<CONTENT>-----END CERTIFICATE-----")
 *                 .build())
 *             .config(Map.of("auto.offset.reset", "latest"))
 *             .bootstrapServers("localhost:9091,localhost:9092")
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ### Example AWSLambda Connection
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.mongodbatlas.StreamConnection;
 * import com.pulumi.mongodbatlas.StreamConnectionArgs;
 * import com.pulumi.mongodbatlas.inputs.StreamConnectionAwsArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var test = new StreamConnection("test", StreamConnectionArgs.builder()
 *             .projectId(projectId)
 *             .workspaceName("NewWorkspace")
 *             .connectionName("AWSLambdaConnection")
 *             .type("AWSLambda")
 *             .aws(StreamConnectionAwsArgs.builder()
 *                 .roleArn("arn:aws:iam::<AWS_ACCOUNT_ID>:role/lambdaRole")
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ### Example Https Connection
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.mongodbatlas.StreamConnection;
 * import com.pulumi.mongodbatlas.StreamConnectionArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var example_https = new StreamConnection("example-https", StreamConnectionArgs.builder()
 *             .projectId(projectId)
 *             .workspaceName(example.workspaceName())
 *             .connectionName("https_connection_tf_new")
 *             .type("Https")
 *             .url("https://example.com")
 *             .headers(Map.ofEntries(
 *                 Map.entry("key1", "value1"),
 *                 Map.entry("key2", "value2")
 *             ))
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ### Example Schema Registry Connection with USER_INFO Authentication
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.mongodbatlas.StreamConnection;
 * import com.pulumi.mongodbatlas.StreamConnectionArgs;
 * import com.pulumi.mongodbatlas.inputs.StreamConnectionSchemaRegistryAuthenticationArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var example_schema_registry = new StreamConnection("example-schema-registry", StreamConnectionArgs.builder()
 *             .projectId(projectId)
 *             .workspaceName(example.workspaceName())
 *             .connectionName("SchemaRegistryConnection")
 *             .type("SchemaRegistry")
 *             .schemaRegistryProvider("CONFLUENT")
 *             .schemaRegistryUrls("https://schema-registry.example.com:8081")
 *             .schemaRegistryAuthentication(StreamConnectionSchemaRegistryAuthenticationArgs.builder()
 *                 .type("USER_INFO")
 *                 .username("registry-user")
 *                 .password(schemaRegistryPassword)
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ### Example Schema Registry Connection with SASL_INHERIT Authentication
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.mongodbatlas.StreamConnection;
 * import com.pulumi.mongodbatlas.StreamConnectionArgs;
 * import com.pulumi.mongodbatlas.inputs.StreamConnectionSchemaRegistryAuthenticationArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var example_schema_registry_sasl = new StreamConnection("example-schema-registry-sasl", StreamConnectionArgs.builder()
 *             .projectId(projectId)
 *             .workspaceName(example.workspaceName())
 *             .connectionName("SchemaRegistryConnectionSASL")
 *             .type("SchemaRegistry")
 *             .schemaRegistryProvider("CONFLUENT")
 *             .schemaRegistryUrls("https://schema-registry.example.com:8081")
 *             .schemaRegistryAuthentication(StreamConnectionSchemaRegistryAuthenticationArgs.builder()
 *                 .type("SASL_INHERIT")
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ### Example Usage with Stream Processor
 * 
 * When using a stream connection with a stream processor, the connection must be fully provisioned before the processor can be created. The provider automatically waits for connections to be ready after creation or updates. The example below shows a typical pattern:
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.mongodbatlas.StreamWorkspace;
 * import com.pulumi.mongodbatlas.StreamWorkspaceArgs;
 * import com.pulumi.mongodbatlas.inputs.StreamWorkspaceDataProcessRegionArgs;
 * import com.pulumi.mongodbatlas.StreamConnection;
 * import com.pulumi.mongodbatlas.StreamConnectionArgs;
 * import com.pulumi.mongodbatlas.inputs.StreamConnectionDbRoleToExecuteArgs;
 * import com.pulumi.mongodbatlas.StreamProcessor;
 * import com.pulumi.mongodbatlas.StreamProcessorArgs;
 * import static com.pulumi.codegen.internal.Serialization.*;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var example = new StreamWorkspace("example", StreamWorkspaceArgs.builder()
 *             .projectId(projectId)
 *             .workspaceName("ExampleWorkspace")
 *             .dataProcessRegion(StreamWorkspaceDataProcessRegionArgs.builder()
 *                 .region("VIRGINIA_USA")
 *                 .cloudProvider("AWS")
 *                 .build())
 *             .build());
 * 
 *         // Source connection (Sample data)
 *         var source = new StreamConnection("source", StreamConnectionArgs.builder()
 *             .projectId(projectId)
 *             .workspaceName(example.workspaceName())
 *             .connectionName("sample_stream_solar")
 *             .type("Sample")
 *             .build());
 * 
 *         // Sink connection (Atlas Cluster)
 *         var sink = new StreamConnection("sink", StreamConnectionArgs.builder()
 *             .projectId(projectId)
 *             .workspaceName(example.workspaceName())
 *             .connectionName("ClusterConnection")
 *             .type("Cluster")
 *             .clusterName(exampleMongodbatlasCluster.name())
 *             .dbRoleToExecute(StreamConnectionDbRoleToExecuteArgs.builder()
 *                 .role("atlasAdmin")
 *                 .type("BUILT_IN")
 *                 .build())
 *             .build());
 * 
 *         // Stream processor that depends on both connections
 *         var exampleStreamProcessor = new StreamProcessor("exampleStreamProcessor", StreamProcessorArgs.builder()
 *             .projectId(projectId)
 *             .workspaceName(example.workspaceName())
 *             .processorName("ExampleProcessor")
 *             .pipeline(Output.tuple(source.connectionName(), sink.connectionName()).applyValue(values -> {
 *                 var sourceConnectionName = values.t1;
 *                 var sinkConnectionName = values.t2;
 *                 return serializeJson(
 *                     jsonArray(
 *                         jsonObject(
 *                             jsonProperty("$source", jsonObject(
 *                                 jsonProperty("connectionName", sourceConnectionName)
 *                             ))
 *                         ), 
 *                         jsonObject(
 *                             jsonProperty("$emit", jsonObject(
 *                                 jsonProperty("connectionName", sinkConnectionName)
 *                             ))
 *                         )
 *                     ));
 *             }))
 *             .state("STARTED")
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * &gt; **NOTE:** The stream processor resource automatically depends on the stream connections through the `connectionName` references in the pipeline. This ensures proper creation order. The provider waits for each connection to be fully provisioned before returning from create or update operations.
 * 
 * ## Import
 * 
 * You can import a stream connection resource using the workspace name, project ID, and connection name. The format must be `WORKSPACE_NAME-PROJECT_ID-CONNECTION_NAME`. For example:
 * 
 * ```sh
 * $ pulumi import mongodbatlas:index/streamConnection:StreamConnection test &#34;DefaultInstance-12251446ae5f3f6ec7968b13-NewConnection&#34;
 * ```
 * 
 * To learn more, see: [MongoDB Atlas API - Stream Connection](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamConnection) Documentation.
 * The Terraform Provider Examples Section also contains details on the overall support for Atlas Streams Processing in Terraform.
 * 
 */
@ResourceType(type="mongodbatlas:index/streamConnection:StreamConnection")
public class StreamConnection extends com.pulumi.resources.CustomResource {
    @Export(name="authentication", refs={StreamConnectionAuthentication.class}, tree="[0]")
    private Output</* @Nullable */ StreamConnectionAuthentication> authentication;

    public Output<Optional<StreamConnectionAuthentication>> authentication() {
        return Codegen.optional(this.authentication);
    }
    @Export(name="aws", refs={StreamConnectionAws.class}, tree="[0]")
    private Output</* @Nullable */ StreamConnectionAws> aws;

    public Output<Optional<StreamConnectionAws>> aws() {
        return Codegen.optional(this.aws);
    }
    @Export(name="bootstrapServers", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> bootstrapServers;

    public Output<Optional<String>> bootstrapServers() {
        return Codegen.optional(this.bootstrapServers);
    }
    @Export(name="clusterName", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> clusterName;

    public Output<Optional<String>> clusterName() {
        return Codegen.optional(this.clusterName);
    }
    @Export(name="clusterProjectId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> clusterProjectId;

    public Output<Optional<String>> clusterProjectId() {
        return Codegen.optional(this.clusterProjectId);
    }
    @Export(name="config", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output</* @Nullable */ Map<String,String>> config;

    public Output<Optional<Map<String,String>>> config() {
        return Codegen.optional(this.config);
    }
    /**
     * Label that identifies the stream connection. In the case of the Sample type, this is the name of the sample source.
     * 
     */
    @Export(name="connectionName", refs={String.class}, tree="[0]")
    private Output<String> connectionName;

    /**
     * @return Label that identifies the stream connection. In the case of the Sample type, this is the name of the sample source.
     * 
     */
    public Output<String> connectionName() {
        return this.connectionName;
    }
    @Export(name="dbRoleToExecute", refs={StreamConnectionDbRoleToExecute.class}, tree="[0]")
    private Output</* @Nullable */ StreamConnectionDbRoleToExecute> dbRoleToExecute;

    public Output<Optional<StreamConnectionDbRoleToExecute>> dbRoleToExecute() {
        return Codegen.optional(this.dbRoleToExecute);
    }
    @Export(name="headers", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output</* @Nullable */ Map<String,String>> headers;

    public Output<Optional<Map<String,String>>> headers() {
        return Codegen.optional(this.headers);
    }
    /**
     * Label that identifies the stream processing workspace. Use `workspaceName` instead; this attribute will be removed in a future major version.
     * 
     * @deprecated
     * This parameter is deprecated. Please transition to workspace_name.
     * 
     */
    @Deprecated /* This parameter is deprecated. Please transition to workspace_name. */
    @Export(name="instanceName", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> instanceName;

    /**
     * @return Label that identifies the stream processing workspace. Use `workspaceName` instead; this attribute will be removed in a future major version.
     * 
     */
    public Output<Optional<String>> instanceName() {
        return Codegen.optional(this.instanceName);
    }
    @Export(name="networking", refs={StreamConnectionNetworking.class}, tree="[0]")
    private Output<StreamConnectionNetworking> networking;

    public Output<StreamConnectionNetworking> networking() {
        return this.networking;
    }
    /**
     * Unique 24-hexadecimal digit string that identifies your project.
     * 
     */
    @Export(name="projectId", refs={String.class}, tree="[0]")
    private Output<String> projectId;

    /**
     * @return Unique 24-hexadecimal digit string that identifies your project.
     * 
     */
    public Output<String> projectId() {
        return this.projectId;
    }
    @Export(name="schemaRegistryAuthentication", refs={StreamConnectionSchemaRegistryAuthentication.class}, tree="[0]")
    private Output</* @Nullable */ StreamConnectionSchemaRegistryAuthentication> schemaRegistryAuthentication;

    public Output<Optional<StreamConnectionSchemaRegistryAuthentication>> schemaRegistryAuthentication() {
        return Codegen.optional(this.schemaRegistryAuthentication);
    }
    @Export(name="schemaRegistryProvider", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> schemaRegistryProvider;

    public Output<Optional<String>> schemaRegistryProvider() {
        return Codegen.optional(this.schemaRegistryProvider);
    }
    @Export(name="schemaRegistryUrls", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> schemaRegistryUrls;

    public Output<Optional<List<String>>> schemaRegistryUrls() {
        return Codegen.optional(this.schemaRegistryUrls);
    }
    @Export(name="security", refs={StreamConnectionSecurity.class}, tree="[0]")
    private Output</* @Nullable */ StreamConnectionSecurity> security;

    public Output<Optional<StreamConnectionSecurity>> security() {
        return Codegen.optional(this.security);
    }
    @Export(name="timeouts", refs={StreamConnectionTimeouts.class}, tree="[0]")
    private Output</* @Nullable */ StreamConnectionTimeouts> timeouts;

    public Output<Optional<StreamConnectionTimeouts>> timeouts() {
        return Codegen.optional(this.timeouts);
    }
    /**
     * Type of connection. Can be `AWSLambda`, `Cluster`, `Https`, `Kafka`, `Sample`, or `SchemaRegistry`.
     * 
     */
    @Export(name="type", refs={String.class}, tree="[0]")
    private Output<String> type;

    /**
     * @return Type of connection. Can be `AWSLambda`, `Cluster`, `Https`, `Kafka`, `Sample`, or `SchemaRegistry`.
     * 
     */
    public Output<String> type() {
        return this.type;
    }
    @Export(name="url", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> url;

    public Output<Optional<String>> url() {
        return Codegen.optional(this.url);
    }
    /**
     * Label that identifies the stream processing workspace.
     * 
     */
    @Export(name="workspaceName", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> workspaceName;

    /**
     * @return Label that identifies the stream processing workspace.
     * 
     */
    public Output<Optional<String>> workspaceName() {
        return Codegen.optional(this.workspaceName);
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public StreamConnection(java.lang.String name) {
        this(name, StreamConnectionArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public StreamConnection(java.lang.String name, StreamConnectionArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public StreamConnection(java.lang.String name, StreamConnectionArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("mongodbatlas:index/streamConnection:StreamConnection", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private StreamConnection(java.lang.String name, Output<java.lang.String> id, @Nullable StreamConnectionState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("mongodbatlas:index/streamConnection:StreamConnection", name, state, makeResourceOptions(options, id), false);
    }

    private static StreamConnectionArgs makeArgs(StreamConnectionArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? StreamConnectionArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static StreamConnection get(java.lang.String name, Output<java.lang.String> id, @Nullable StreamConnectionState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new StreamConnection(name, id, state, options);
    }
}
