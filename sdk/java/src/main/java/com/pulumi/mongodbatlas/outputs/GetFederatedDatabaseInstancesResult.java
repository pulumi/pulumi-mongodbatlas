// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.mongodbatlas.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.mongodbatlas.outputs.GetFederatedDatabaseInstancesResultCloudProviderConfig;
import com.pulumi.mongodbatlas.outputs.GetFederatedDatabaseInstancesResultDataProcessRegion;
import com.pulumi.mongodbatlas.outputs.GetFederatedDatabaseInstancesResultStorageDatabase;
import com.pulumi.mongodbatlas.outputs.GetFederatedDatabaseInstancesResultStorageStore;
import java.lang.String;
import java.util.List;
import java.util.Objects;

@CustomType
public final class GetFederatedDatabaseInstancesResult {
    private GetFederatedDatabaseInstancesResultCloudProviderConfig cloudProviderConfig;
    private List<GetFederatedDatabaseInstancesResultDataProcessRegion> dataProcessRegions;
    /**
     * @return The list of hostnames assigned to the Federated Database Instance. Each string in the array is a hostname assigned to the Federated Database Instance.
     * 
     */
    private List<String> hostnames;
    private String name;
    /**
     * @return The unique ID for the project to create a Federated Database Instance.
     * 
     */
    private String projectId;
    /**
     * @return Current state of the Federated Database Instance:
     * * `ACTIVE` - The Federated Database Instance is active and verified. You can query the data stores associated with the Federated Database Instance.
     * * `DELETED` - The Federated Database Instance was deleted.
     * 
     */
    private String state;
    /**
     * @return Configuration details for mapping each data store to queryable databases and collections. For complete documentation on this object and its nested fields, see [databases](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#std-label-datalake-databases-reference). An empty object indicates that the Federated Database Instance has no mapping configuration for any data store.
     * * `storage_databases.#.name` - Name of the database to which the Federated Database Instance maps the data contained in the data store.
     * * `storage_databases.#.collections` -     Array of objects where each object represents a collection and data sources that map to a [stores](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#mongodb-datalakeconf-datalakeconf.stores) data store.
     * * `storage_databases.#.collections.#.name` - Name of the collection.
     * * `storage_databases.#.collections.#.data_sources` -     Array of objects where each object represents a stores data store to map with the collection.
     * * `storage_databases.#.collections.#.data_sources.#.store_name` -     Name of a data store to map to the `&lt;collection&gt;`. Must match the name of an object in the stores array.
     * * `storage_databases.#.collections.#.data_sources.#.dataset_name` -     Human-readable label that identifies the dataset that Atlas generates for an ingestion pipeline run or Online Archive.
     * * `storage_databases.#.collections.#.data_sources.#.default_format` - Default format that Federated Database assumes if it encounters a file without an extension while searching the storeName.
     * * `storage_databases.#.collections.#.data_sources.#.path` - File path that controls how MongoDB Cloud searches for and parses files in the storeName before mapping them to a collection. Specify / to capture all files and folders from the prefix path.
     * * `storage_databases.#.collections.#.data_sources.#.database` - Human-readable label that identifies the database, which contains the collection in the cluster.
     * * `storage_databases.#.collections.#.data_sources.#.allow_insecure` - Flag that validates the scheme in the specified URLs. If true, allows insecure HTTP scheme, doesn&#39;t verify the server&#39;s certificate chain and hostname, and accepts any certificate with any hostname presented by the server. If false, allows secure HTTPS scheme only.
     * * `storage_databases.#.collections.#.data_sources.#.database_regex` - Regex pattern to use for creating the wildcard database.
     * * `storage_databases.#.collections.#.data_sources.#.collection` - Human-readable label that identifies the collection in the database.
     * * `storage_databases.#.collections.#.data_sources.#.collection_regex` - Regex pattern to use for creating the wildcard (*) collection.
     * * `storage_databases.#.collections.#.data_sources.#.provenance_field_name` - Name for the field that includes the provenance of the documents in the results.
     * * `storage_databases.#.collections.#.data_sources.#.storeName` - Human-readable label that identifies the data store that MongoDB Cloud maps to the collection.
     * * `storage_databases.#.collections.#.data_sources.#.urls` - URLs of the publicly accessible data files. You can&#39;t specify URLs that require authentication.
     * * `storage_databases.#.views` -     Array of objects where each object represents an [aggregation pipeline](https://docs.mongodb.com/manual/core/aggregation-pipeline/#id1) on a collection. To learn more about views, see [Views](https://docs.mongodb.com/manual/core/views/).
     * * `storage_databases.#.views.#.name` - Name of the view.
     * * `storage_databases.#.views.#.source` -  Name of the source collection for the view.
     * * `storage_databases.#.views.#.pipeline`- Aggregation pipeline stage(s) to apply to the source collection.
     * 
     */
    private List<GetFederatedDatabaseInstancesResultStorageDatabase> storageDatabases;
    /**
     * @return Each object in the array represents a data store. Federated Database uses the storage.databases configuration details to map data in each data store to queryable databases and collections. For complete documentation on this object and its nested fields, see [stores](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#std-label-datalake-stores-reference). An empty object indicates that the Federated Database Instance has no configured data stores.
     * * `storage_stores.#.name` - Name of the data store.
     * * `storage_stores.#.provider` - Defines where the data is stored.
     * * `storage_stores.#.region` - Name of the AWS region in which the S3 bucket is hosted.
     * * `storage_stores.#.bucket` - Name of the AWS S3 bucket.
     * * `storage_stores.#.prefix` - Prefix the Federated Database Instance applies when searching for files in the S3 bucket.
     * * `storage_stores.#.delimiter` - The delimiter that separates `storage_databases.#.collections.#.data_sources.#.path` segments in the data store.
     * * `storage_stores.#.include_tags` - Determines whether or not to use S3 tags on the files in the given path as additional partition attributes.
     * * `storage_stores.#.cluster_name` - Human-readable label of the MongoDB Cloud cluster on which the store is based.
     * * `storage_stores.#.allow_insecure` - Flag that validates the scheme in the specified URLs.
     * * `storage_stores.#.public` - Flag that indicates whether the bucket is public.
     * * `storage_stores.#.default_format` - Default format that Data Lake assumes if it encounters a file without an extension while searching the storeName.
     * * `storage_stores.#.urls` - Comma-separated list of publicly accessible HTTP URLs where data is stored.
     * * `storage_stores.#.read_preference` - MongoDB Cloud cluster read preference, which describes how to route read requests to the cluster.
     * * `storage_stores.#.read_preference.maxStalenessSeconds` - Maximum replication lag, or staleness, for reads from secondaries.
     * * `storage_stores.#.read_preference.mode` - Read preference mode that specifies to which replica set member to route the read requests.
     * * `storage_stores.#.read_preference.tag_sets` - List that contains tag sets or tag specification documents.
     * * `storage_stores.#.read_preference.tags` - List of all tags within a tag set
     * * `storage_stores.#.read_preference.tags.name` - Human-readable label of the tag.
     * * `storage_stores.#.read_preference.tags.value` - Value of the tag.
     * 
     */
    private List<GetFederatedDatabaseInstancesResultStorageStore> storageStores;

    private GetFederatedDatabaseInstancesResult() {}
    public GetFederatedDatabaseInstancesResultCloudProviderConfig cloudProviderConfig() {
        return this.cloudProviderConfig;
    }
    public List<GetFederatedDatabaseInstancesResultDataProcessRegion> dataProcessRegions() {
        return this.dataProcessRegions;
    }
    /**
     * @return The list of hostnames assigned to the Federated Database Instance. Each string in the array is a hostname assigned to the Federated Database Instance.
     * 
     */
    public List<String> hostnames() {
        return this.hostnames;
    }
    public String name() {
        return this.name;
    }
    /**
     * @return The unique ID for the project to create a Federated Database Instance.
     * 
     */
    public String projectId() {
        return this.projectId;
    }
    /**
     * @return Current state of the Federated Database Instance:
     * * `ACTIVE` - The Federated Database Instance is active and verified. You can query the data stores associated with the Federated Database Instance.
     * * `DELETED` - The Federated Database Instance was deleted.
     * 
     */
    public String state() {
        return this.state;
    }
    /**
     * @return Configuration details for mapping each data store to queryable databases and collections. For complete documentation on this object and its nested fields, see [databases](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#std-label-datalake-databases-reference). An empty object indicates that the Federated Database Instance has no mapping configuration for any data store.
     * * `storage_databases.#.name` - Name of the database to which the Federated Database Instance maps the data contained in the data store.
     * * `storage_databases.#.collections` -     Array of objects where each object represents a collection and data sources that map to a [stores](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#mongodb-datalakeconf-datalakeconf.stores) data store.
     * * `storage_databases.#.collections.#.name` - Name of the collection.
     * * `storage_databases.#.collections.#.data_sources` -     Array of objects where each object represents a stores data store to map with the collection.
     * * `storage_databases.#.collections.#.data_sources.#.store_name` -     Name of a data store to map to the `&lt;collection&gt;`. Must match the name of an object in the stores array.
     * * `storage_databases.#.collections.#.data_sources.#.dataset_name` -     Human-readable label that identifies the dataset that Atlas generates for an ingestion pipeline run or Online Archive.
     * * `storage_databases.#.collections.#.data_sources.#.default_format` - Default format that Federated Database assumes if it encounters a file without an extension while searching the storeName.
     * * `storage_databases.#.collections.#.data_sources.#.path` - File path that controls how MongoDB Cloud searches for and parses files in the storeName before mapping them to a collection. Specify / to capture all files and folders from the prefix path.
     * * `storage_databases.#.collections.#.data_sources.#.database` - Human-readable label that identifies the database, which contains the collection in the cluster.
     * * `storage_databases.#.collections.#.data_sources.#.allow_insecure` - Flag that validates the scheme in the specified URLs. If true, allows insecure HTTP scheme, doesn&#39;t verify the server&#39;s certificate chain and hostname, and accepts any certificate with any hostname presented by the server. If false, allows secure HTTPS scheme only.
     * * `storage_databases.#.collections.#.data_sources.#.database_regex` - Regex pattern to use for creating the wildcard database.
     * * `storage_databases.#.collections.#.data_sources.#.collection` - Human-readable label that identifies the collection in the database.
     * * `storage_databases.#.collections.#.data_sources.#.collection_regex` - Regex pattern to use for creating the wildcard (*) collection.
     * * `storage_databases.#.collections.#.data_sources.#.provenance_field_name` - Name for the field that includes the provenance of the documents in the results.
     * * `storage_databases.#.collections.#.data_sources.#.storeName` - Human-readable label that identifies the data store that MongoDB Cloud maps to the collection.
     * * `storage_databases.#.collections.#.data_sources.#.urls` - URLs of the publicly accessible data files. You can&#39;t specify URLs that require authentication.
     * * `storage_databases.#.views` -     Array of objects where each object represents an [aggregation pipeline](https://docs.mongodb.com/manual/core/aggregation-pipeline/#id1) on a collection. To learn more about views, see [Views](https://docs.mongodb.com/manual/core/views/).
     * * `storage_databases.#.views.#.name` - Name of the view.
     * * `storage_databases.#.views.#.source` -  Name of the source collection for the view.
     * * `storage_databases.#.views.#.pipeline`- Aggregation pipeline stage(s) to apply to the source collection.
     * 
     */
    public List<GetFederatedDatabaseInstancesResultStorageDatabase> storageDatabases() {
        return this.storageDatabases;
    }
    /**
     * @return Each object in the array represents a data store. Federated Database uses the storage.databases configuration details to map data in each data store to queryable databases and collections. For complete documentation on this object and its nested fields, see [stores](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#std-label-datalake-stores-reference). An empty object indicates that the Federated Database Instance has no configured data stores.
     * * `storage_stores.#.name` - Name of the data store.
     * * `storage_stores.#.provider` - Defines where the data is stored.
     * * `storage_stores.#.region` - Name of the AWS region in which the S3 bucket is hosted.
     * * `storage_stores.#.bucket` - Name of the AWS S3 bucket.
     * * `storage_stores.#.prefix` - Prefix the Federated Database Instance applies when searching for files in the S3 bucket.
     * * `storage_stores.#.delimiter` - The delimiter that separates `storage_databases.#.collections.#.data_sources.#.path` segments in the data store.
     * * `storage_stores.#.include_tags` - Determines whether or not to use S3 tags on the files in the given path as additional partition attributes.
     * * `storage_stores.#.cluster_name` - Human-readable label of the MongoDB Cloud cluster on which the store is based.
     * * `storage_stores.#.allow_insecure` - Flag that validates the scheme in the specified URLs.
     * * `storage_stores.#.public` - Flag that indicates whether the bucket is public.
     * * `storage_stores.#.default_format` - Default format that Data Lake assumes if it encounters a file without an extension while searching the storeName.
     * * `storage_stores.#.urls` - Comma-separated list of publicly accessible HTTP URLs where data is stored.
     * * `storage_stores.#.read_preference` - MongoDB Cloud cluster read preference, which describes how to route read requests to the cluster.
     * * `storage_stores.#.read_preference.maxStalenessSeconds` - Maximum replication lag, or staleness, for reads from secondaries.
     * * `storage_stores.#.read_preference.mode` - Read preference mode that specifies to which replica set member to route the read requests.
     * * `storage_stores.#.read_preference.tag_sets` - List that contains tag sets or tag specification documents.
     * * `storage_stores.#.read_preference.tags` - List of all tags within a tag set
     * * `storage_stores.#.read_preference.tags.name` - Human-readable label of the tag.
     * * `storage_stores.#.read_preference.tags.value` - Value of the tag.
     * 
     */
    public List<GetFederatedDatabaseInstancesResultStorageStore> storageStores() {
        return this.storageStores;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetFederatedDatabaseInstancesResult defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private GetFederatedDatabaseInstancesResultCloudProviderConfig cloudProviderConfig;
        private List<GetFederatedDatabaseInstancesResultDataProcessRegion> dataProcessRegions;
        private List<String> hostnames;
        private String name;
        private String projectId;
        private String state;
        private List<GetFederatedDatabaseInstancesResultStorageDatabase> storageDatabases;
        private List<GetFederatedDatabaseInstancesResultStorageStore> storageStores;
        public Builder() {}
        public Builder(GetFederatedDatabaseInstancesResult defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.cloudProviderConfig = defaults.cloudProviderConfig;
    	      this.dataProcessRegions = defaults.dataProcessRegions;
    	      this.hostnames = defaults.hostnames;
    	      this.name = defaults.name;
    	      this.projectId = defaults.projectId;
    	      this.state = defaults.state;
    	      this.storageDatabases = defaults.storageDatabases;
    	      this.storageStores = defaults.storageStores;
        }

        @CustomType.Setter
        public Builder cloudProviderConfig(GetFederatedDatabaseInstancesResultCloudProviderConfig cloudProviderConfig) {
            if (cloudProviderConfig == null) {
              throw new MissingRequiredPropertyException("GetFederatedDatabaseInstancesResult", "cloudProviderConfig");
            }
            this.cloudProviderConfig = cloudProviderConfig;
            return this;
        }
        @CustomType.Setter
        public Builder dataProcessRegions(List<GetFederatedDatabaseInstancesResultDataProcessRegion> dataProcessRegions) {
            if (dataProcessRegions == null) {
              throw new MissingRequiredPropertyException("GetFederatedDatabaseInstancesResult", "dataProcessRegions");
            }
            this.dataProcessRegions = dataProcessRegions;
            return this;
        }
        public Builder dataProcessRegions(GetFederatedDatabaseInstancesResultDataProcessRegion... dataProcessRegions) {
            return dataProcessRegions(List.of(dataProcessRegions));
        }
        @CustomType.Setter
        public Builder hostnames(List<String> hostnames) {
            if (hostnames == null) {
              throw new MissingRequiredPropertyException("GetFederatedDatabaseInstancesResult", "hostnames");
            }
            this.hostnames = hostnames;
            return this;
        }
        public Builder hostnames(String... hostnames) {
            return hostnames(List.of(hostnames));
        }
        @CustomType.Setter
        public Builder name(String name) {
            if (name == null) {
              throw new MissingRequiredPropertyException("GetFederatedDatabaseInstancesResult", "name");
            }
            this.name = name;
            return this;
        }
        @CustomType.Setter
        public Builder projectId(String projectId) {
            if (projectId == null) {
              throw new MissingRequiredPropertyException("GetFederatedDatabaseInstancesResult", "projectId");
            }
            this.projectId = projectId;
            return this;
        }
        @CustomType.Setter
        public Builder state(String state) {
            if (state == null) {
              throw new MissingRequiredPropertyException("GetFederatedDatabaseInstancesResult", "state");
            }
            this.state = state;
            return this;
        }
        @CustomType.Setter
        public Builder storageDatabases(List<GetFederatedDatabaseInstancesResultStorageDatabase> storageDatabases) {
            if (storageDatabases == null) {
              throw new MissingRequiredPropertyException("GetFederatedDatabaseInstancesResult", "storageDatabases");
            }
            this.storageDatabases = storageDatabases;
            return this;
        }
        public Builder storageDatabases(GetFederatedDatabaseInstancesResultStorageDatabase... storageDatabases) {
            return storageDatabases(List.of(storageDatabases));
        }
        @CustomType.Setter
        public Builder storageStores(List<GetFederatedDatabaseInstancesResultStorageStore> storageStores) {
            if (storageStores == null) {
              throw new MissingRequiredPropertyException("GetFederatedDatabaseInstancesResult", "storageStores");
            }
            this.storageStores = storageStores;
            return this;
        }
        public Builder storageStores(GetFederatedDatabaseInstancesResultStorageStore... storageStores) {
            return storageStores(List.of(storageStores));
        }
        public GetFederatedDatabaseInstancesResult build() {
            final var _resultValue = new GetFederatedDatabaseInstancesResult();
            _resultValue.cloudProviderConfig = cloudProviderConfig;
            _resultValue.dataProcessRegions = dataProcessRegions;
            _resultValue.hostnames = hostnames;
            _resultValue.name = name;
            _resultValue.projectId = projectId;
            _resultValue.state = state;
            _resultValue.storageDatabases = storageDatabases;
            _resultValue.storageStores = storageStores;
            return _resultValue;
        }
    }
}
