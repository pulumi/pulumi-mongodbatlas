// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.mongodbatlas.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.mongodbatlas.inputs.OnlineArchiveCriteriaArgs;
import com.pulumi.mongodbatlas.inputs.OnlineArchivePartitionFieldArgs;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class OnlineArchiveState extends com.pulumi.resources.ResourceArgs {

    public static final OnlineArchiveState Empty = new OnlineArchiveState();

    /**
     * ID of the online archive.
     * 
     */
    @Import(name="archiveId")
    private @Nullable Output<String> archiveId;

    /**
     * @return ID of the online archive.
     * 
     */
    public Optional<Output<String>> archiveId() {
        return Optional.ofNullable(this.archiveId);
    }

    /**
     * Name of the cluster that contains the collection.
     * 
     */
    @Import(name="clusterName")
    private @Nullable Output<String> clusterName;

    /**
     * @return Name of the cluster that contains the collection.
     * 
     */
    public Optional<Output<String>> clusterName() {
        return Optional.ofNullable(this.clusterName);
    }

    /**
     * Name of the collection.
     * 
     */
    @Import(name="collName")
    private @Nullable Output<String> collName;

    /**
     * @return Name of the collection.
     * 
     */
    public Optional<Output<String>> collName() {
        return Optional.ofNullable(this.collName);
    }

    /**
     * Criteria to use for archiving data.
     * 
     */
    @Import(name="criteria")
    private @Nullable Output<OnlineArchiveCriteriaArgs> criteria;

    /**
     * @return Criteria to use for archiving data.
     * 
     */
    public Optional<Output<OnlineArchiveCriteriaArgs>> criteria() {
        return Optional.ofNullable(this.criteria);
    }

    /**
     * Name of the database that contains the collection.
     * 
     */
    @Import(name="dbName")
    private @Nullable Output<String> dbName;

    /**
     * @return Name of the database that contains the collection.
     * 
     */
    public Optional<Output<String>> dbName() {
        return Optional.ofNullable(this.dbName);
    }

    /**
     * Fields to use to partition data. You can specify up to two frequently queried fields to use for partitioning data. Note that queries that don’t contain the specified fields will require a full collection scan of all archived documents, which will take longer and increase your costs. To learn more about how partition improves query performance, see [Data Structure in S3](https://docs.mongodb.com/datalake/admin/optimize-query-performance/#data-structure-in-s3). The value of a partition field can be up to a maximum of 700 characters. Documents with values exceeding 700 characters are not archived.
     * 
     */
    @Import(name="partitionFields")
    private @Nullable Output<List<OnlineArchivePartitionFieldArgs>> partitionFields;

    /**
     * @return Fields to use to partition data. You can specify up to two frequently queried fields to use for partitioning data. Note that queries that don’t contain the specified fields will require a full collection scan of all archived documents, which will take longer and increase your costs. To learn more about how partition improves query performance, see [Data Structure in S3](https://docs.mongodb.com/datalake/admin/optimize-query-performance/#data-structure-in-s3). The value of a partition field can be up to a maximum of 700 characters. Documents with values exceeding 700 characters are not archived.
     * 
     */
    public Optional<Output<List<OnlineArchivePartitionFieldArgs>>> partitionFields() {
        return Optional.ofNullable(this.partitionFields);
    }

    /**
     * State of the online archive. This is required for pausing an active or resume a paused online archive. The resume request will fail if the collection has another active online archive.
     * 
     */
    @Import(name="paused")
    private @Nullable Output<Boolean> paused;

    /**
     * @return State of the online archive. This is required for pausing an active or resume a paused online archive. The resume request will fail if the collection has another active online archive.
     * 
     */
    public Optional<Output<Boolean>> paused() {
        return Optional.ofNullable(this.paused);
    }

    /**
     * The unique ID for the project
     * 
     */
    @Import(name="projectId")
    private @Nullable Output<String> projectId;

    /**
     * @return The unique ID for the project
     * 
     */
    public Optional<Output<String>> projectId() {
        return Optional.ofNullable(this.projectId);
    }

    /**
     * Status of the online archive. Valid values are: Pending, Archiving, Idle, Pausing, Paused, Orphaned and Deleted
     * 
     */
    @Import(name="state")
    private @Nullable Output<String> state;

    /**
     * @return Status of the online archive. Valid values are: Pending, Archiving, Idle, Pausing, Paused, Orphaned and Deleted
     * 
     */
    public Optional<Output<String>> state() {
        return Optional.ofNullable(this.state);
    }

    @Import(name="syncCreation")
    private @Nullable Output<Boolean> syncCreation;

    public Optional<Output<Boolean>> syncCreation() {
        return Optional.ofNullable(this.syncCreation);
    }

    private OnlineArchiveState() {}

    private OnlineArchiveState(OnlineArchiveState $) {
        this.archiveId = $.archiveId;
        this.clusterName = $.clusterName;
        this.collName = $.collName;
        this.criteria = $.criteria;
        this.dbName = $.dbName;
        this.partitionFields = $.partitionFields;
        this.paused = $.paused;
        this.projectId = $.projectId;
        this.state = $.state;
        this.syncCreation = $.syncCreation;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(OnlineArchiveState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private OnlineArchiveState $;

        public Builder() {
            $ = new OnlineArchiveState();
        }

        public Builder(OnlineArchiveState defaults) {
            $ = new OnlineArchiveState(Objects.requireNonNull(defaults));
        }

        /**
         * @param archiveId ID of the online archive.
         * 
         * @return builder
         * 
         */
        public Builder archiveId(@Nullable Output<String> archiveId) {
            $.archiveId = archiveId;
            return this;
        }

        /**
         * @param archiveId ID of the online archive.
         * 
         * @return builder
         * 
         */
        public Builder archiveId(String archiveId) {
            return archiveId(Output.of(archiveId));
        }

        /**
         * @param clusterName Name of the cluster that contains the collection.
         * 
         * @return builder
         * 
         */
        public Builder clusterName(@Nullable Output<String> clusterName) {
            $.clusterName = clusterName;
            return this;
        }

        /**
         * @param clusterName Name of the cluster that contains the collection.
         * 
         * @return builder
         * 
         */
        public Builder clusterName(String clusterName) {
            return clusterName(Output.of(clusterName));
        }

        /**
         * @param collName Name of the collection.
         * 
         * @return builder
         * 
         */
        public Builder collName(@Nullable Output<String> collName) {
            $.collName = collName;
            return this;
        }

        /**
         * @param collName Name of the collection.
         * 
         * @return builder
         * 
         */
        public Builder collName(String collName) {
            return collName(Output.of(collName));
        }

        /**
         * @param criteria Criteria to use for archiving data.
         * 
         * @return builder
         * 
         */
        public Builder criteria(@Nullable Output<OnlineArchiveCriteriaArgs> criteria) {
            $.criteria = criteria;
            return this;
        }

        /**
         * @param criteria Criteria to use for archiving data.
         * 
         * @return builder
         * 
         */
        public Builder criteria(OnlineArchiveCriteriaArgs criteria) {
            return criteria(Output.of(criteria));
        }

        /**
         * @param dbName Name of the database that contains the collection.
         * 
         * @return builder
         * 
         */
        public Builder dbName(@Nullable Output<String> dbName) {
            $.dbName = dbName;
            return this;
        }

        /**
         * @param dbName Name of the database that contains the collection.
         * 
         * @return builder
         * 
         */
        public Builder dbName(String dbName) {
            return dbName(Output.of(dbName));
        }

        /**
         * @param partitionFields Fields to use to partition data. You can specify up to two frequently queried fields to use for partitioning data. Note that queries that don’t contain the specified fields will require a full collection scan of all archived documents, which will take longer and increase your costs. To learn more about how partition improves query performance, see [Data Structure in S3](https://docs.mongodb.com/datalake/admin/optimize-query-performance/#data-structure-in-s3). The value of a partition field can be up to a maximum of 700 characters. Documents with values exceeding 700 characters are not archived.
         * 
         * @return builder
         * 
         */
        public Builder partitionFields(@Nullable Output<List<OnlineArchivePartitionFieldArgs>> partitionFields) {
            $.partitionFields = partitionFields;
            return this;
        }

        /**
         * @param partitionFields Fields to use to partition data. You can specify up to two frequently queried fields to use for partitioning data. Note that queries that don’t contain the specified fields will require a full collection scan of all archived documents, which will take longer and increase your costs. To learn more about how partition improves query performance, see [Data Structure in S3](https://docs.mongodb.com/datalake/admin/optimize-query-performance/#data-structure-in-s3). The value of a partition field can be up to a maximum of 700 characters. Documents with values exceeding 700 characters are not archived.
         * 
         * @return builder
         * 
         */
        public Builder partitionFields(List<OnlineArchivePartitionFieldArgs> partitionFields) {
            return partitionFields(Output.of(partitionFields));
        }

        /**
         * @param partitionFields Fields to use to partition data. You can specify up to two frequently queried fields to use for partitioning data. Note that queries that don’t contain the specified fields will require a full collection scan of all archived documents, which will take longer and increase your costs. To learn more about how partition improves query performance, see [Data Structure in S3](https://docs.mongodb.com/datalake/admin/optimize-query-performance/#data-structure-in-s3). The value of a partition field can be up to a maximum of 700 characters. Documents with values exceeding 700 characters are not archived.
         * 
         * @return builder
         * 
         */
        public Builder partitionFields(OnlineArchivePartitionFieldArgs... partitionFields) {
            return partitionFields(List.of(partitionFields));
        }

        /**
         * @param paused State of the online archive. This is required for pausing an active or resume a paused online archive. The resume request will fail if the collection has another active online archive.
         * 
         * @return builder
         * 
         */
        public Builder paused(@Nullable Output<Boolean> paused) {
            $.paused = paused;
            return this;
        }

        /**
         * @param paused State of the online archive. This is required for pausing an active or resume a paused online archive. The resume request will fail if the collection has another active online archive.
         * 
         * @return builder
         * 
         */
        public Builder paused(Boolean paused) {
            return paused(Output.of(paused));
        }

        /**
         * @param projectId The unique ID for the project
         * 
         * @return builder
         * 
         */
        public Builder projectId(@Nullable Output<String> projectId) {
            $.projectId = projectId;
            return this;
        }

        /**
         * @param projectId The unique ID for the project
         * 
         * @return builder
         * 
         */
        public Builder projectId(String projectId) {
            return projectId(Output.of(projectId));
        }

        /**
         * @param state Status of the online archive. Valid values are: Pending, Archiving, Idle, Pausing, Paused, Orphaned and Deleted
         * 
         * @return builder
         * 
         */
        public Builder state(@Nullable Output<String> state) {
            $.state = state;
            return this;
        }

        /**
         * @param state Status of the online archive. Valid values are: Pending, Archiving, Idle, Pausing, Paused, Orphaned and Deleted
         * 
         * @return builder
         * 
         */
        public Builder state(String state) {
            return state(Output.of(state));
        }

        public Builder syncCreation(@Nullable Output<Boolean> syncCreation) {
            $.syncCreation = syncCreation;
            return this;
        }

        public Builder syncCreation(Boolean syncCreation) {
            return syncCreation(Output.of(syncCreation));
        }

        public OnlineArchiveState build() {
            return $;
        }
    }

}
