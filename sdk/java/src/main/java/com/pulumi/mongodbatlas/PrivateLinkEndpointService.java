// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.mongodbatlas;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.mongodbatlas.PrivateLinkEndpointServiceArgs;
import com.pulumi.mongodbatlas.Utilities;
import com.pulumi.mongodbatlas.inputs.PrivateLinkEndpointServiceState;
import com.pulumi.mongodbatlas.outputs.PrivateLinkEndpointServiceEndpoint;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * `mongodbatlas.PrivateLinkEndpointService` provides a Private Endpoint Interface Link resource. This represents a Private Endpoint Interface Link, which adds one [Interface Endpoint](https://www.mongodb.com/docs/atlas/security-private-endpoint/#private-endpoint-concepts) to a private endpoint connection in an Atlas project.
 * 
 * &gt; **IMPORTANT:** This resource links your cloud provider&#39;s Private Endpoint to the MongoDB Atlas Private Endpoint Service. It does not create the service itself (this is done by `mongodbatlas.PrivateLinkEndpoint`). You first create the service in Atlas with `mongodbatlas.PrivateLinkEndpoint`, then the endpoint is created in your cloud provider, and you link them together with the `mongodbatlas.PrivateLinkEndpointService` resource.
 * 
 * The private link Terraform module makes use of this resource and simplifies its use.
 * 
 * &gt; **NOTE:** You must have Organization Owner or Project Owner role. Create and delete operations wait for all clusters on the project to IDLE to ensure the latest connection strings can be retrieved (default timeout: 2hrs).
 * 
 * &gt; **IMPORTANT:** For GCP, MongoDB encourages customers to use the port-mapped architecture by setting `portMappingEnabled = true` on the `mongodbatlas.PrivateLinkEndpoint` resource. This architecture uses a single set of resources to support up to 150 nodes. The legacy architecture requires dedicated resources for each Atlas node, which can lead to IP address exhaustion. For migration guidance, see the GCP Private Service Connect to Port-Mapped Architecture.
 * 
 * ## Example with AWS
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.mongodbatlas.PrivateLinkEndpoint;
 * import com.pulumi.mongodbatlas.PrivateLinkEndpointArgs;
 * import com.pulumi.aws.VpcEndpoint;
 * import com.pulumi.aws.VpcEndpointArgs;
 * import com.pulumi.mongodbatlas.PrivateLinkEndpointService;
 * import com.pulumi.mongodbatlas.PrivateLinkEndpointServiceArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var this_ = new PrivateLinkEndpoint("this", PrivateLinkEndpointArgs.builder()
 *             .projectId("<PROJECT_ID>")
 *             .providerName("AWS")
 *             .region("US_EAST_1")
 *             .build());
 * 
 *         var ptfeService = new VpcEndpoint("ptfeService", VpcEndpointArgs.builder()
 *             .vpcId("vpc-7fc0a543")
 *             .serviceName(this_.endpointServiceName())
 *             .vpcEndpointType("Interface")
 *             .subnetIds(List.of("subnet-de0406d2"))
 *             .securityGroupIds(List.of("sg-3f238186"))
 *             .build());
 * 
 *         var thisPrivateLinkEndpointService = new PrivateLinkEndpointService("thisPrivateLinkEndpointService", PrivateLinkEndpointServiceArgs.builder()
 *             .projectId(this_.projectId())
 *             .privateLinkId(this_.privateLinkId())
 *             .endpointServiceId(ptfeService.id())
 *             .providerName("AWS")
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ## Example with Azure
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.mongodbatlas.PrivateLinkEndpoint;
 * import com.pulumi.mongodbatlas.PrivateLinkEndpointArgs;
 * import com.pulumi.azurerm.PrivateEndpoint;
 * import com.pulumi.azurerm.PrivateEndpointArgs;
 * import com.pulumi.mongodbatlas.PrivateLinkEndpointService;
 * import com.pulumi.mongodbatlas.PrivateLinkEndpointServiceArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var this_ = new PrivateLinkEndpoint("this", PrivateLinkEndpointArgs.builder()
 *             .projectId(projectId)
 *             .providerName("AZURE")
 *             .region("eastus2")
 *             .build());
 * 
 *         var thisPrivateEndpoint = new PrivateEndpoint("thisPrivateEndpoint", PrivateEndpointArgs.builder()
 *             .name("endpoint-this")
 *             .location(thisAzurermResourceGroup.location())
 *             .resourceGroupName(resourceGroupName)
 *             .subnetId(thisAzurermSubnet.id())
 *             .privateServiceConnection(List.of(Map.ofEntries(
 *                 Map.entry("name", this_.privateLinkServiceName()),
 *                 Map.entry("privateConnectionResourceId", this_.privateLinkServiceResourceId()),
 *                 Map.entry("isManualConnection", true),
 *                 Map.entry("requestMessage", "Azure Private Link this")
 *             )))
 *             .build());
 * 
 *         var thisPrivateLinkEndpointService = new PrivateLinkEndpointService("thisPrivateLinkEndpointService", PrivateLinkEndpointServiceArgs.builder()
 *             .projectId(this_.projectId())
 *             .privateLinkId(this_.privateLinkId())
 *             .endpointServiceId(thisPrivateEndpoint.id())
 *             .privateEndpointIpAddress(thisPrivateEndpoint.privateServiceConnection()[0].privateIpAddress())
 *             .providerName("AZURE")
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ## Example with GCP (Legacy Architecture)
 * 
 * ## Example with GCP (Port-Mapped Architecture)
 * 
 * The port-mapped architecture uses port mapping to reduce resource provisioning. In the GCP legacy private endpoint architecture, service attachments were mapped 1:1 with Atlas nodes (one service attachment per node). In the port-mapped architecture, regardless of cloud provider, one service attachment can be mapped to up to 150 nodes via ports designated per node, enabling direct targeting of specific nodes using only one customer IP address. Enable it by setting `portMappingEnabled = true` on the `mongodbatlas.PrivateLinkEndpoint` resource.
 * 
 * **Important:** For the port-mapped architecture, use `endpointServiceId` (the forwarding rule name) and `privateEndpointIpAddress` (the IP address). The `endpoints` list is no longer used for the port-mapped architecture.
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.mongodbatlas.PrivateLinkEndpoint;
 * import com.pulumi.mongodbatlas.PrivateLinkEndpointArgs;
 * import com.pulumi.google.ComputeNetwork;
 * import com.pulumi.google.ComputeNetworkArgs;
 * import com.pulumi.google.ComputeSubnetwork;
 * import com.pulumi.google.ComputeSubnetworkArgs;
 * import com.pulumi.google.ComputeAddress;
 * import com.pulumi.google.ComputeAddressArgs;
 * import com.pulumi.google.ComputeForwardingRule;
 * import com.pulumi.google.ComputeForwardingRuleArgs;
 * import com.pulumi.mongodbatlas.PrivateLinkEndpointService;
 * import com.pulumi.mongodbatlas.PrivateLinkEndpointServiceArgs;
 * import com.pulumi.resources.CustomResourceOptions;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var this_ = new PrivateLinkEndpoint("this", PrivateLinkEndpointArgs.builder()
 *             .projectId(projectId)
 *             .providerName("GCP")
 *             .region(gcpRegion)
 *             .portMappingEnabled(true)
 *             .build());
 * 
 *         // Create a Google Network
 *         var default_ = new ComputeNetwork("default", ComputeNetworkArgs.builder()
 *             .project(gcpProjectId)
 *             .name("my-network")
 *             .autoCreateSubnetworks(false)
 *             .build());
 * 
 *         // Create a Google Sub Network
 *         var defaultComputeSubnetwork = new ComputeSubnetwork("defaultComputeSubnetwork", ComputeSubnetworkArgs.builder()
 *             .project(default_.project())
 *             .name("my-subnet")
 *             .ipCidrRange("10.0.0.0/16")
 *             .region(gcpRegion)
 *             .network(default_.id())
 *             .build());
 * 
 *         // Create Google Address (1 address for port-mapped architecture)
 *         var defaultComputeAddress = new ComputeAddress("defaultComputeAddress", ComputeAddressArgs.builder()
 *             .project(defaultComputeSubnetwork.project())
 *             .name("tf-this-psc-endpoint")
 *             .subnetwork(defaultComputeSubnetwork.id())
 *             .addressType("INTERNAL")
 *             .address("10.0.42.1")
 *             .region(defaultComputeSubnetwork.region())
 *             .build(), CustomResourceOptions.builder()
 *                 .dependsOn(List.of(this_))
 *                 .build());
 * 
 *         // Create Forwarding Rule (1 rule for port-mapped architecture)
 *         var defaultComputeForwardingRule = new ComputeForwardingRule("defaultComputeForwardingRule", ComputeForwardingRuleArgs.builder()
 *             .target(this_.serviceAttachmentNames()[0])
 *             .project(defaultComputeAddress.project())
 *             .region(defaultComputeAddress.region())
 *             .name(defaultComputeAddress.name())
 *             .ipAddress(defaultComputeAddress.id())
 *             .network(default_.id())
 *             .loadBalancingScheme("")
 *             .build());
 * 
 *         var thisPrivateLinkEndpointService = new PrivateLinkEndpointService("thisPrivateLinkEndpointService", PrivateLinkEndpointServiceArgs.builder()
 *             .projectId(this_.projectId())
 *             .privateLinkId(this_.privateLinkId())
 *             .providerName("GCP")
 *             .endpointServiceId(defaultComputeForwardingRule.name())
 *             .privateEndpointIpAddress(defaultComputeAddress.address())
 *             .gcpProjectId(gcpProjectId)
 *             .build(), CustomResourceOptions.builder()
 *                 .dependsOn(defaultComputeForwardingRule)
 *                 .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ### Further Examples
 * - AWS PrivateLink Endpoint and Service
 * - Azure Private Link Endpoint and Service
 * - GCP Private Service Connect Endpoint and Service (Port-Mapped Architecture)
 * 
 * ## Import
 * 
 * Private Endpoint Link Connection can be imported using project ID, private link ID, endpoint service ID, and provider name, in the format `{project_id}--{private_link_id}--{endpoint_service_id}--{provider_name}`, e.g.
 * 
 * ```sh
 * $ pulumi import mongodbatlas:index/privateLinkEndpointService:PrivateLinkEndpointService this 1112222b3bf99403840e8934--3242342343112--vpce-4242342343--AWS
 * ```
 * 
 * For more information, see:
 * - [MongoDB API Private Endpoint Link Connection](https://www.mongodb.com/docs/api/doc/atlas-admin-api-v2/operation/operation-creategroupprivateendpointendpointserviceendpoint) for detailed arguments and attributes.
 * - [Set Up a Private Endpoint](https://www.mongodb.com/docs/atlas/security-private-endpoint/) for general guidance on private endpoints in MongoDB Atlas.
 * 
 */
@ResourceType(type="mongodbatlas:index/privateLinkEndpointService:PrivateLinkEndpointService")
public class PrivateLinkEndpointService extends com.pulumi.resources.CustomResource {
    /**
     * Status of the interface endpoint for AWS.
     * Returns one of the following values:
     * * `NONE` - Atlas created the network load balancer and VPC endpoint service, but AWS hasn&#39;t yet created the VPC endpoint.
     * * `PENDING_ACCEPTANCE` - AWS has received the connection request from your VPC endpoint to the Atlas VPC endpoint service.
     * * `PENDING` - AWS is establishing the connection between your VPC endpoint and the Atlas VPC endpoint service.
     * * `AVAILABLE` - Atlas VPC resources are connected to the VPC endpoint in your VPC. You can connect to Atlas clusters in this region using AWS PrivateLink.
     * * `REJECTED` - AWS failed to establish a connection between Atlas VPC resources to the VPC endpoint in your VPC.
     * * `DELETING` - Atlas is removing the interface endpoint from the private endpoint connection.
     * 
     */
    @Export(name="awsConnectionStatus", refs={String.class}, tree="[0]")
    private Output<String> awsConnectionStatus;

    /**
     * @return Status of the interface endpoint for AWS.
     * Returns one of the following values:
     * * `NONE` - Atlas created the network load balancer and VPC endpoint service, but AWS hasn&#39;t yet created the VPC endpoint.
     * * `PENDING_ACCEPTANCE` - AWS has received the connection request from your VPC endpoint to the Atlas VPC endpoint service.
     * * `PENDING` - AWS is establishing the connection between your VPC endpoint and the Atlas VPC endpoint service.
     * * `AVAILABLE` - Atlas VPC resources are connected to the VPC endpoint in your VPC. You can connect to Atlas clusters in this region using AWS PrivateLink.
     * * `REJECTED` - AWS failed to establish a connection between Atlas VPC resources to the VPC endpoint in your VPC.
     * * `DELETING` - Atlas is removing the interface endpoint from the private endpoint connection.
     * 
     */
    public Output<String> awsConnectionStatus() {
        return this.awsConnectionStatus;
    }
    /**
     * Status of the interface endpoint for AZURE.
     * Returns one of the following values:
     * * `INITIATING` - Atlas has not yet accepted the connection to your private endpoint.
     * * `AVAILABLE` - Atlas approved the connection to your private endpoint.
     * * `FAILED` - Atlas failed to accept the connection your private endpoint.
     * * `DELETING` - Atlas is removing the connection to your private endpoint from the Private Link service.
     * 
     */
    @Export(name="azureStatus", refs={String.class}, tree="[0]")
    private Output<String> azureStatus;

    /**
     * @return Status of the interface endpoint for AZURE.
     * Returns one of the following values:
     * * `INITIATING` - Atlas has not yet accepted the connection to your private endpoint.
     * * `AVAILABLE` - Atlas approved the connection to your private endpoint.
     * * `FAILED` - Atlas failed to accept the connection your private endpoint.
     * * `DELETING` - Atlas is removing the connection to your private endpoint from the Private Link service.
     * 
     */
    public Output<String> azureStatus() {
        return this.azureStatus;
    }
    /**
     * Indicates whether to delete the resource being created if a timeout is reached when waiting for completion. When set to `true` and timeout occurs, it triggers the deletion and returns immediately without waiting for deletion to complete. When set to `false`, the timeout will not trigger resource deletion. If you suspect a transient error when the value is `true`, wait before retrying to allow resource deletion to finish. Default is `true`.
     * 
     */
    @Export(name="deleteOnCreateTimeout", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> deleteOnCreateTimeout;

    /**
     * @return Indicates whether to delete the resource being created if a timeout is reached when waiting for completion. When set to `true` and timeout occurs, it triggers the deletion and returns immediately without waiting for deletion to complete. When set to `false`, the timeout will not trigger resource deletion. If you suspect a transient error when the value is `true`, wait before retrying to allow resource deletion to finish. Default is `true`.
     * 
     */
    public Output<Optional<Boolean>> deleteOnCreateTimeout() {
        return Codegen.optional(this.deleteOnCreateTimeout);
    }
    /**
     * Indicates if Atlas received a request to remove the interface endpoint from the private endpoint connection.
     * 
     */
    @Export(name="deleteRequested", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> deleteRequested;

    /**
     * @return Indicates if Atlas received a request to remove the interface endpoint from the private endpoint connection.
     * 
     */
    public Output<Boolean> deleteRequested() {
        return this.deleteRequested;
    }
    @Export(name="endpointGroupName", refs={String.class}, tree="[0]")
    private Output<String> endpointGroupName;

    public Output<String> endpointGroupName() {
        return this.endpointGroupName;
    }
    /**
     * Unique identifier of the interface endpoint you created in your VPC. For `AWS` and `AZURE`, this is the interface endpoint identifier. For `GCP` port-mapped architecture, this is the forwarding rule name. For `GCP` legacy private endpoint architecture, this is the endpoint group name.
     * 
     */
    @Export(name="endpointServiceId", refs={String.class}, tree="[0]")
    private Output<String> endpointServiceId;

    /**
     * @return Unique identifier of the interface endpoint you created in your VPC. For `AWS` and `AZURE`, this is the interface endpoint identifier. For `GCP` port-mapped architecture, this is the forwarding rule name. For `GCP` legacy private endpoint architecture, this is the endpoint group name.
     * 
     */
    public Output<String> endpointServiceId() {
        return this.endpointServiceId;
    }
    /**
     * Collection of individual private endpoints that comprise your endpoint group. Only for GCP legacy private endpoint architecture. **Note:** For the port-mapped architecture, this field is no longer used - use `endpointServiceId` and `privateEndpointIpAddress` instead.
     * 
     */
    @Export(name="endpoints", refs={List.class,PrivateLinkEndpointServiceEndpoint.class}, tree="[0,1]")
    private Output<List<PrivateLinkEndpointServiceEndpoint>> endpoints;

    /**
     * @return Collection of individual private endpoints that comprise your endpoint group. Only for GCP legacy private endpoint architecture. **Note:** For the port-mapped architecture, this field is no longer used - use `endpointServiceId` and `privateEndpointIpAddress` instead.
     * 
     */
    public Output<List<PrivateLinkEndpointServiceEndpoint>> endpoints() {
        return this.endpoints;
    }
    /**
     * Error message pertaining to the interface endpoint. Returns null if there are no errors.
     * 
     */
    @Export(name="errorMessage", refs={String.class}, tree="[0]")
    private Output<String> errorMessage;

    /**
     * @return Error message pertaining to the interface endpoint. Returns null if there are no errors.
     * 
     */
    public Output<String> errorMessage() {
        return this.errorMessage;
    }
    /**
     * Status of the individual endpoint. Only populated for port-mapped architecture. Returns one of the following values: `INITIATING`, `AVAILABLE`, `FAILED`, `DELETING`.
     * 
     */
    @Export(name="gcpEndpointStatus", refs={String.class}, tree="[0]")
    private Output<String> gcpEndpointStatus;

    /**
     * @return Status of the individual endpoint. Only populated for port-mapped architecture. Returns one of the following values: `INITIATING`, `AVAILABLE`, `FAILED`, `DELETING`.
     * 
     */
    public Output<String> gcpEndpointStatus() {
        return this.gcpEndpointStatus;
    }
    /**
     * Unique identifier of the GCP project in which you created your endpoints. **Required for `GCP`** (both legacy and port-mapped architectures). Only for `GCP`.
     * 
     */
    @Export(name="gcpProjectId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> gcpProjectId;

    /**
     * @return Unique identifier of the GCP project in which you created your endpoints. **Required for `GCP`** (both legacy and port-mapped architectures). Only for `GCP`.
     * 
     */
    public Output<Optional<String>> gcpProjectId() {
        return Codegen.optional(this.gcpProjectId);
    }
    /**
     * Status of the interface endpoint.
     * Returns one of the following values:
     * * `INITIATING` - Atlas has not yet accepted the connection to your private endpoint.
     * * `AVAILABLE` - Atlas approved the connection to your private endpoint.
     * * `FAILED` - Atlas failed to accept the connection your private endpoint.
     * * `DELETING` - Atlas is removing the connection to your private endpoint from the Private Link service.
     * 
     */
    @Export(name="gcpStatus", refs={String.class}, tree="[0]")
    private Output<String> gcpStatus;

    /**
     * @return Status of the interface endpoint.
     * Returns one of the following values:
     * * `INITIATING` - Atlas has not yet accepted the connection to your private endpoint.
     * * `AVAILABLE` - Atlas approved the connection to your private endpoint.
     * * `FAILED` - Atlas failed to accept the connection your private endpoint.
     * * `DELETING` - Atlas is removing the connection to your private endpoint from the Private Link service.
     * 
     */
    public Output<String> gcpStatus() {
        return this.gcpStatus;
    }
    /**
     * Unique identifier of the interface endpoint.
     * 
     */
    @Export(name="interfaceEndpointId", refs={String.class}, tree="[0]")
    private Output<String> interfaceEndpointId;

    /**
     * @return Unique identifier of the interface endpoint.
     * 
     */
    public Output<String> interfaceEndpointId() {
        return this.interfaceEndpointId;
    }
    /**
     * Flag that indicates whether the underlying `privatelinkEndpoint` resource uses GCP port-mapping. This is a read-only attribute that reflects the architecture type. When `true`, the endpoint service uses the port-mapped architecture. When `false`, it uses the GCP legacy private endpoint architecture. Only applicable for GCP provider.
     * 
     */
    @Export(name="portMappingEnabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> portMappingEnabled;

    /**
     * @return Flag that indicates whether the underlying `privatelinkEndpoint` resource uses GCP port-mapping. This is a read-only attribute that reflects the architecture type. When `true`, the endpoint service uses the port-mapped architecture. When `false`, it uses the GCP legacy private endpoint architecture. Only applicable for GCP provider.
     * 
     */
    public Output<Boolean> portMappingEnabled() {
        return this.portMappingEnabled;
    }
    /**
     * Name of the connection for this private endpoint that Atlas generates.
     * 
     */
    @Export(name="privateEndpointConnectionName", refs={String.class}, tree="[0]")
    private Output<String> privateEndpointConnectionName;

    /**
     * @return Name of the connection for this private endpoint that Atlas generates.
     * 
     */
    public Output<String> privateEndpointConnectionName() {
        return this.privateEndpointConnectionName;
    }
    /**
     * Private IP address of the private endpoint network interface. **Required for `AZURE and GCP Port-Mapped`.** For port-mapped architecture, this is required and is the IP address of the forwarding rule. For GCP legacy private endpoint architecture, this is not used.
     * 
     */
    @Export(name="privateEndpointIpAddress", refs={String.class}, tree="[0]")
    private Output<String> privateEndpointIpAddress;

    /**
     * @return Private IP address of the private endpoint network interface. **Required for `AZURE and GCP Port-Mapped`.** For port-mapped architecture, this is required and is the IP address of the forwarding rule. For GCP legacy private endpoint architecture, this is not used.
     * 
     */
    public Output<String> privateEndpointIpAddress() {
        return this.privateEndpointIpAddress;
    }
    /**
     * Unique identifier of the private endpoint.
     * 
     */
    @Export(name="privateEndpointResourceId", refs={String.class}, tree="[0]")
    private Output<String> privateEndpointResourceId;

    /**
     * @return Unique identifier of the private endpoint.
     * 
     */
    public Output<String> privateEndpointResourceId() {
        return this.privateEndpointResourceId;
    }
    /**
     * Unique identifier of the `AWS`, `AZURE` or `GCP` PrivateLink connection which is created by `mongodbatlas.PrivateLinkEndpoint` resource.
     * 
     */
    @Export(name="privateLinkId", refs={String.class}, tree="[0]")
    private Output<String> privateLinkId;

    /**
     * @return Unique identifier of the `AWS`, `AZURE` or `GCP` PrivateLink connection which is created by `mongodbatlas.PrivateLinkEndpoint` resource.
     * 
     */
    public Output<String> privateLinkId() {
        return this.privateLinkId;
    }
    /**
     * Unique identifier for the project, also known as `groupId` in the official documentation.
     * 
     */
    @Export(name="projectId", refs={String.class}, tree="[0]")
    private Output<String> projectId;

    /**
     * @return Unique identifier for the project, also known as `groupId` in the official documentation.
     * 
     */
    public Output<String> projectId() {
        return this.projectId;
    }
    /**
     * Cloud provider for which you want to create a private endpoint. Atlas accepts `AWS`, `AZURE` or `GCP`.
     * 
     */
    @Export(name="providerName", refs={String.class}, tree="[0]")
    private Output<String> providerName;

    /**
     * @return Cloud provider for which you want to create a private endpoint. Atlas accepts `AWS`, `AZURE` or `GCP`.
     * 
     */
    public Output<String> providerName() {
        return this.providerName;
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public PrivateLinkEndpointService(java.lang.String name) {
        this(name, PrivateLinkEndpointServiceArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public PrivateLinkEndpointService(java.lang.String name, PrivateLinkEndpointServiceArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public PrivateLinkEndpointService(java.lang.String name, PrivateLinkEndpointServiceArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("mongodbatlas:index/privateLinkEndpointService:PrivateLinkEndpointService", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private PrivateLinkEndpointService(java.lang.String name, Output<java.lang.String> id, @Nullable PrivateLinkEndpointServiceState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("mongodbatlas:index/privateLinkEndpointService:PrivateLinkEndpointService", name, state, makeResourceOptions(options, id), false);
    }

    private static PrivateLinkEndpointServiceArgs makeArgs(PrivateLinkEndpointServiceArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? PrivateLinkEndpointServiceArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static PrivateLinkEndpointService get(java.lang.String name, Output<java.lang.String> id, @Nullable PrivateLinkEndpointServiceState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new PrivateLinkEndpointService(name, id, state, options);
    }
}
