// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Mongodbatlas
{
    /// <summary>
    /// `mongodbatlas.AdvancedCluster` provides an Advanced Cluster resource. The resource lets you create, edit and delete advanced clusters.
    /// 
    /// &gt; **IMPORTANT:** If upgrading from our provider versions 1.x.x to 2.0.0 or later, you will be required to update your `mongodbatlas.AdvancedCluster` resource configuration. Please refer this guide for details. This new implementation uses the recommended Terraform Plugin Framework, which, in addition to providing a better user experience and other features, adds support for the `Moved` block between different resource types.
    /// 
    /// &gt; **IMPORTANT:** We recommend all new MongoDB Atlas Terraform users start with the `mongodbatlas.AdvancedCluster` resource.  Key differences between `mongodbatlas.Cluster` and `mongodbatlas.AdvancedCluster` include support for [Multi-Cloud Clusters](https://www.mongodb.com/blog/post/introducing-multicloud-clusters-on-mongodb-atlas), Asymmetric Sharding, and [Independent Scaling of Analytics Node Tiers](https://www.mongodb.com/blog/post/introducing-ability-independently-scale-atlas-analytics-node-tiers). For existing `mongodbatlas.Cluster` resource users see our Migration Guide.
    /// 
    /// &gt; **IMPORTANT:** When modifying cluster configurations, you may see `(known after apply)` markers for many attributes, even those you haven't changed. This is expected behavior. See the "known after apply" verbosity section below for details.
    /// 
    /// &gt; **IMPORTANT:** When configuring auto-scaling, you can now use `UseEffectiveFields` to simplify your Terraform workflow. See the Auto-Scaling with Effective Fields section below for details.
    /// 
    /// &gt; **NOTE:** If Backup Compliance Policy is enabled for the project for which this backup schedule is defined, you cannot modify the backup schedule for an individual cluster below the minimum requirements set in the Backup Compliance Policy.  See [Backup Compliance Policy Prohibited Actions and Considerations](https://www.mongodb.com/docs/atlas/backup/cloud-backup/backup-compliance-policy/#configure-a-backup-compliance-policy).
    /// 
    /// &gt; **NOTE:** A network container is created for each provider/region combination on the advanced cluster. This can be referenced via a computed attribute for use with other resources. Refer to the `replication_specs[#].container_id` attribute in the Attributes Reference for more information.
    /// 
    /// &gt; **NOTE:** To enable Cluster Extended Storage Sizes use the `IsExtendedStorageSizesEnabled` parameter in the mongodbatlas.Project resource.
    /// 
    /// &gt; **NOTE:** The Low-CPU instance clusters are prefixed with `R`, for example `R40`. For complete list of Low-CPU instance clusters see Cluster Configuration Options under each [Cloud Provider](https://www.mongodb.com/docs/atlas/reference/cloud-providers).
    /// 
    /// &gt; **NOTE:** Groups and projects are synonymous terms. You might find GroupId in the official documentation.
    /// 
    /// &gt; **NOTE:** This resource supports Flex clusters. Additionally, you can upgrade M0 clusters to Flex and Flex clusters to Dedicated. When creating a Flex cluster, make sure to set the priority value to 7.
    /// 
    /// ## Example Usage
    /// 
    /// ### Example single provider and single region
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Mongodbatlas = Pulumi.Mongodbatlas;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var @this = new Mongodbatlas.AdvancedCluster("this", new()
    ///     {
    ///         ProjectId = "PROJECT ID",
    ///         Name = "NAME OF CLUSTER",
    ///         ClusterType = "REPLICASET",
    ///         ReplicationSpecs = new[]
    ///         {
    ///             new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecArgs
    ///             {
    ///                 RegionConfigs = new[]
    ///                 {
    ///                     new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs
    ///                     {
    ///                         ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs
    ///                         {
    ///                             InstanceSize = "M10",
    ///                             NodeCount = 3,
    ///                         },
    ///                         AnalyticsSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsArgs
    ///                         {
    ///                             InstanceSize = "M10",
    ///                             NodeCount = 1,
    ///                         },
    ///                         ProviderName = "AWS",
    ///                         Priority = 7,
    ///                         RegionName = "US_EAST_1",
    ///                     },
    ///                 },
    ///             },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ### Example using effective fields with auto-scaling
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Mongodbatlas = Pulumi.Mongodbatlas;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var thisAdvancedCluster = new Mongodbatlas.AdvancedCluster("this", new()
    ///     {
    ///         ProjectId = projectId,
    ///         Name = "auto-scale-cluster",
    ///         ClusterType = "REPLICASET",
    ///         UseEffectiveFields = true,
    ///         ReplicationSpecs = new[]
    ///         {
    ///             new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecArgs
    ///             {
    ///                 RegionConfigs = new[]
    ///                 {
    ///                     new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs
    ///                     {
    ///                         ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs
    ///                         {
    ///                             InstanceSize = "M10",
    ///                             NodeCount = 3,
    ///                         },
    ///                         AutoScaling = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigAutoScalingArgs
    ///                         {
    ///                             ComputeEnabled = true,
    ///                             ComputeScaleDownEnabled = true,
    ///                             ComputeMinInstanceSize = "M10",
    ///                             ComputeMaxInstanceSize = "M30",
    ///                         },
    ///                         ProviderName = "AWS",
    ///                         Priority = 7,
    ///                         RegionName = "US_EAST_1",
    ///                     },
    ///                 },
    ///             },
    ///         },
    ///     });
    /// 
    ///     // Read the effective (actual) values after Atlas scales
    ///     var @this = Mongodbatlas.GetAdvancedCluster.Invoke(new()
    ///     {
    ///         ProjectId = thisAdvancedCluster.ProjectId,
    ///         Name = thisAdvancedCluster.Name,
    ///         UseEffectiveFields = true,
    ///     });
    /// 
    ///     return new Dictionary&lt;string, object?&gt;
    ///     {
    ///         ["configuredInstanceSize"] = @this.Apply(@this =&gt; @this.Apply(getAdvancedClusterResult =&gt; getAdvancedClusterResult.ReplicationSpecs[0]?.RegionConfigs[0]?.ElectableSpecs?.InstanceSize)),
    ///         ["actualInstanceSize"] = @this.Apply(@this =&gt; @this.Apply(getAdvancedClusterResult =&gt; getAdvancedClusterResult.ReplicationSpecs[0]?.RegionConfigs[0]?.EffectiveElectableSpecs?.InstanceSize)),
    ///     };
    /// });
    /// ```
    /// 
    /// **For module authors:** See the Effective Fields Examples for complete examples of using `UseEffectiveFields` and effective specs in reusable Terraform modules.
    /// 
    /// ### Example Tenant Cluster
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Mongodbatlas = Pulumi.Mongodbatlas;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var @this = new Mongodbatlas.AdvancedCluster("this", new()
    ///     {
    ///         ProjectId = "PROJECT ID",
    ///         Name = "NAME OF CLUSTER",
    ///         ClusterType = "REPLICASET",
    ///         ReplicationSpecs = new[]
    ///         {
    ///             new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecArgs
    ///             {
    ///                 RegionConfigs = new[]
    ///                 {
    ///                     new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs
    ///                     {
    ///                         ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs
    ///                         {
    ///                             InstanceSize = "M0",
    ///                         },
    ///                         ProviderName = "TENANT",
    ///                         BackingProviderName = "AWS",
    ///                         RegionName = "US_EAST_1",
    ///                         Priority = 7,
    ///                     },
    ///                 },
    ///             },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// &gt; **NOTE** Upgrading the tenant cluster to a Flex cluster or a dedicated cluster is supported. When upgrading to a Flex cluster, change the `ProviderName` from "TENANT" to "FLEX". See Example Tenant Cluster Upgrade to Flex below. When upgrading to a dedicated cluster, change the `ProviderName` to your preferred provider (AWS, GCP or Azure) and remove the variable `BackingProviderName`. See the Example Tenant Cluster Upgrade below. You can upgrade a tenant cluster only to a single provider on an M10-tier cluster or greater.
    /// 
    /// When upgrading from the tenant, *only* the upgrade changes will be applied. This helps avoid a corrupt state file in the event that the upgrade succeeds but subsequent updates fail within the same `pulumi up`. To apply additional cluster changes, run a secondary `pulumi up` after the upgrade succeeds.
    /// 
    /// ### Example Tenant Cluster Upgrade
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Mongodbatlas = Pulumi.Mongodbatlas;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var @this = new Mongodbatlas.AdvancedCluster("this", new()
    ///     {
    ///         ProjectId = "PROJECT ID",
    ///         Name = "NAME OF CLUSTER",
    ///         ClusterType = "REPLICASET",
    ///         ReplicationSpecs = new[]
    ///         {
    ///             new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecArgs
    ///             {
    ///                 RegionConfigs = new[]
    ///                 {
    ///                     new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs
    ///                     {
    ///                         ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs
    ///                         {
    ///                             InstanceSize = "M10",
    ///                         },
    ///                         ProviderName = "AWS",
    ///                         RegionName = "US_EAST_1",
    ///                         Priority = 7,
    ///                     },
    ///                 },
    ///             },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ### Example Tenant Cluster Upgrade to Flex
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Mongodbatlas = Pulumi.Mongodbatlas;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var @this = new Mongodbatlas.AdvancedCluster("this", new()
    ///     {
    ///         ProjectId = "PROJECT ID",
    ///         Name = "NAME OF CLUSTER",
    ///         ClusterType = "REPLICASET",
    ///         ReplicationSpecs = new[]
    ///         {
    ///             new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecArgs
    ///             {
    ///                 RegionConfigs = new[]
    ///                 {
    ///                     new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs
    ///                     {
    ///                         ProviderName = "FLEX",
    ///                         BackingProviderName = "AWS",
    ///                         RegionName = "US_EAST_1",
    ///                         Priority = 7,
    ///                     },
    ///                 },
    ///             },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ### Example Flex Cluster
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Mongodbatlas = Pulumi.Mongodbatlas;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var @this = new Mongodbatlas.AdvancedCluster("this", new()
    ///     {
    ///         ProjectId = "PROJECT ID",
    ///         Name = "NAME OF CLUSTER",
    ///         ClusterType = "REPLICASET",
    ///         ReplicationSpecs = new[]
    ///         {
    ///             new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecArgs
    ///             {
    ///                 RegionConfigs = new[]
    ///                 {
    ///                     new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs
    ///                     {
    ///                         ProviderName = "FLEX",
    ///                         BackingProviderName = "AWS",
    ///                         RegionName = "US_EAST_1",
    ///                         Priority = 7,
    ///                     },
    ///                 },
    ///             },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// **NOTE**: Upgrading the Flex cluster is supported. When upgrading from a Flex cluster, change the `ProviderName` from "TENANT" to your preferred provider (AWS, GCP or Azure) and remove the variable `BackingProviderName`.  See the Example Flex Cluster Upgrade below. You can upgrade a Flex cluster only to a single provider on an M10-tier cluster or greater.
    /// 
    /// When upgrading from a flex cluster, *only* the upgrade changes will be applied. This helps avoid a corrupt state file in the event that the upgrade succeeds but subsequent updates fail within the same `pulumi up`. To apply additional cluster changes, run a secondary `pulumi up` after the upgrade succeeds.
    /// 
    /// ### Example Flex Cluster Upgrade
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Mongodbatlas = Pulumi.Mongodbatlas;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var @this = new Mongodbatlas.AdvancedCluster("this", new()
    ///     {
    ///         ProjectId = "PROJECT ID",
    ///         Name = "NAME OF CLUSTER",
    ///         ClusterType = "REPLICASET",
    ///         ReplicationSpecs = new[]
    ///         {
    ///             new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecArgs
    ///             {
    ///                 RegionConfigs = new[]
    ///                 {
    ///                     new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs
    ///                     {
    ///                         ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs
    ///                         {
    ///                             InstanceSize = "M10",
    ///                         },
    ///                         ProviderName = "AWS",
    ///                         RegionName = "US_EAST_1",
    ///                         Priority = 7,
    ///                     },
    ///                 },
    ///             },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ### Example Multi-Cloud Cluster
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Mongodbatlas = Pulumi.Mongodbatlas;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var @this = new Mongodbatlas.AdvancedCluster("this", new()
    ///     {
    ///         ProjectId = "PROJECT ID",
    ///         Name = "NAME OF CLUSTER",
    ///         ClusterType = "REPLICASET",
    ///         ReplicationSpecs = new[]
    ///         {
    ///             new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecArgs
    ///             {
    ///                 RegionConfigs = new[]
    ///                 {
    ///                     new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs
    ///                     {
    ///                         ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs
    ///                         {
    ///                             InstanceSize = "M10",
    ///                             NodeCount = 3,
    ///                         },
    ///                         AnalyticsSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsArgs
    ///                         {
    ///                             InstanceSize = "M10",
    ///                             NodeCount = 1,
    ///                         },
    ///                         ProviderName = "AWS",
    ///                         Priority = 7,
    ///                         RegionName = "US_EAST_1",
    ///                     },
    ///                     new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs
    ///                     {
    ///                         ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs
    ///                         {
    ///                             InstanceSize = "M10",
    ///                             NodeCount = 2,
    ///                         },
    ///                         ProviderName = "GCP",
    ///                         Priority = 6,
    ///                         RegionName = "NORTH_AMERICA_NORTHEAST_1",
    ///                     },
    ///                 },
    ///             },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// ### Example of a Multi Cloud Sharded Cluster with 2 shards
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Mongodbatlas = Pulumi.Mongodbatlas;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var @this = new Mongodbatlas.AdvancedCluster("this", new()
    ///     {
    ///         ProjectId = project.Id,
    ///         Name = clusterName,
    ///         ClusterType = "SHARDED",
    ///         BackupEnabled = true,
    ///         ReplicationSpecs = new[]
    ///         {
    ///             new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecArgs
    ///             {
    ///                 RegionConfigs = new[]
    ///                 {
    ///                     new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs
    ///                     {
    ///                         ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs
    ///                         {
    ///                             InstanceSize = "M30",
    ///                             NodeCount = 3,
    ///                         },
    ///                         ProviderName = "AWS",
    ///                         Priority = 7,
    ///                         RegionName = "US_EAST_1",
    ///                     },
    ///                     new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs
    ///                     {
    ///                         ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs
    ///                         {
    ///                             InstanceSize = "M30",
    ///                             NodeCount = 2,
    ///                         },
    ///                         ProviderName = "AZURE",
    ///                         Priority = 6,
    ///                         RegionName = "US_EAST_2",
    ///                     },
    ///                 },
    ///             },
    ///             new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecArgs
    ///             {
    ///                 RegionConfigs = new[]
    ///                 {
    ///                     new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs
    ///                     {
    ///                         ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs
    ///                         {
    ///                             InstanceSize = "M30",
    ///                             NodeCount = 3,
    ///                         },
    ///                         ProviderName = "AWS",
    ///                         Priority = 7,
    ///                         RegionName = "US_EAST_1",
    ///                     },
    ///                     new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs
    ///                     {
    ///                         ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs
    ///                         {
    ///                             InstanceSize = "M30",
    ///                             NodeCount = 2,
    ///                         },
    ///                         ProviderName = "AZURE",
    ///                         Priority = 6,
    ///                         RegionName = "US_EAST_2",
    ///                     },
    ///                 },
    ///             },
    ///         },
    ///         AdvancedConfiguration = new Mongodbatlas.Inputs.AdvancedClusterAdvancedConfigurationArgs
    ///         {
    ///             JavascriptEnabled = true,
    ///             OplogSizeMb = 991,
    ///             SampleRefreshIntervalBiConnector = 300,
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ### Example of a Global Cluster with 2 zones
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Mongodbatlas = Pulumi.Mongodbatlas;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var @this = new Mongodbatlas.AdvancedCluster("this", new()
    ///     {
    ///         ProjectId = project.Id,
    ///         Name = clusterName,
    ///         ClusterType = "GEOSHARDED",
    ///         BackupEnabled = true,
    ///         ReplicationSpecs = new[]
    ///         {
    ///             new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecArgs
    ///             {
    ///                 ZoneName = "zone n1",
    ///                 RegionConfigs = new[]
    ///                 {
    ///                     new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs
    ///                     {
    ///                         ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs
    ///                         {
    ///                             InstanceSize = "M30",
    ///                             NodeCount = 3,
    ///                         },
    ///                         ProviderName = "AWS",
    ///                         Priority = 7,
    ///                         RegionName = "US_EAST_1",
    ///                     },
    ///                     new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs
    ///                     {
    ///                         ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs
    ///                         {
    ///                             InstanceSize = "M30",
    ///                             NodeCount = 2,
    ///                         },
    ///                         ProviderName = "AZURE",
    ///                         Priority = 6,
    ///                         RegionName = "US_EAST_2",
    ///                     },
    ///                 },
    ///             },
    ///             new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecArgs
    ///             {
    ///                 ZoneName = "zone n1",
    ///                 RegionConfigs = new[]
    ///                 {
    ///                     new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs
    ///                     {
    ///                         ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs
    ///                         {
    ///                             InstanceSize = "M30",
    ///                             NodeCount = 3,
    ///                         },
    ///                         ProviderName = "AWS",
    ///                         Priority = 7,
    ///                         RegionName = "US_EAST_1",
    ///                     },
    ///                     new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs
    ///                     {
    ///                         ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs
    ///                         {
    ///                             InstanceSize = "M30",
    ///                             NodeCount = 2,
    ///                         },
    ///                         ProviderName = "AZURE",
    ///                         Priority = 6,
    ///                         RegionName = "US_EAST_2",
    ///                     },
    ///                 },
    ///             },
    ///             new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecArgs
    ///             {
    ///                 ZoneName = "zone n2",
    ///                 RegionConfigs = new[]
    ///                 {
    ///                     new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs
    ///                     {
    ///                         ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs
    ///                         {
    ///                             InstanceSize = "M30",
    ///                             NodeCount = 3,
    ///                         },
    ///                         ProviderName = "AWS",
    ///                         Priority = 7,
    ///                         RegionName = "EU_WEST_1",
    ///                     },
    ///                     new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs
    ///                     {
    ///                         ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs
    ///                         {
    ///                             InstanceSize = "M30",
    ///                             NodeCount = 2,
    ///                         },
    ///                         ProviderName = "AZURE",
    ///                         Priority = 6,
    ///                         RegionName = "EUROPE_NORTH",
    ///                     },
    ///                 },
    ///             },
    ///             new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecArgs
    ///             {
    ///                 ZoneName = "zone n2",
    ///                 RegionConfigs = new[]
    ///                 {
    ///                     new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs
    ///                     {
    ///                         ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs
    ///                         {
    ///                             InstanceSize = "M30",
    ///                             NodeCount = 3,
    ///                         },
    ///                         ProviderName = "AWS",
    ///                         Priority = 7,
    ///                         RegionName = "EU_WEST_1",
    ///                     },
    ///                     new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs
    ///                     {
    ///                         ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs
    ///                         {
    ///                             InstanceSize = "M30",
    ///                             NodeCount = 2,
    ///                         },
    ///                         ProviderName = "AZURE",
    ///                         Priority = 6,
    ///                         RegionName = "EUROPE_NORTH",
    ///                     },
    ///                 },
    ///             },
    ///         },
    ///         AdvancedConfiguration = new Mongodbatlas.Inputs.AdvancedClusterAdvancedConfigurationArgs
    ///         {
    ///             JavascriptEnabled = true,
    ///             OplogSizeMb = 999,
    ///             SampleRefreshIntervalBiConnector = 300,
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ### Example - Return a Connection String
    /// Standard
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     return new Dictionary&lt;string, object?&gt;
    ///     {
    ///         ["standard"] = cluster.ConnectionStrings.Standard,
    ///     };
    /// });
    /// ```
    /// Standard srv
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     return new Dictionary&lt;string, object?&gt;
    ///     {
    ///         ["standardSrv"] = cluster.ConnectionStrings.StandardSrv,
    ///     };
    /// });
    /// ```
    /// Private with Network peering and Custom DNS AWS enabled
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     return new Dictionary&lt;string, object?&gt;
    ///     {
    ///         ["private"] = cluster.ConnectionStrings.Private,
    ///     };
    /// });
    /// ```
    /// Private srv with Network peering and Custom DNS AWS enabled
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     return new Dictionary&lt;string, object?&gt;
    ///     {
    ///         ["privateSrv"] = cluster.ConnectionStrings.PrivateSrv,
    ///     };
    /// });
    /// ```
    /// 
    /// By EndpointServiceId
    /// 
    /// Refer to the following for full privatelink endpoint connection string examples:
    /// * GCP Private Endpoint
    /// * Azure Private Endpoint
    /// * AWS, Private Endpoint
    /// * AWS, Regionalized Private Endpoints
    /// 
    /// ### Further Examples
    /// 
    /// **Cluster Types:**
    /// - Replicaset
    /// - Symmetric Sharded Cluster
    /// - Asymmetric Sharded Cluster
    /// - Global Cluster
    /// - Multi-Cloud
    /// 
    /// **Auto-scaling:**
    /// - Auto-Scaling Per Shard
    /// - Effective Fields Examples
    /// 
    /// **Upgrades &amp; Migrations:**
    /// - Tenant Upgrade
    /// - Flex Upgrade
    /// - Version Upgrade with Pinned FCV
    /// - Migrate Cluster to Advanced Cluster
    /// 
    /// ## Move
    /// 
    /// `mongodbatlas__cluster` resources can be moved to `mongodbatlas.AdvancedCluster` in Terraform v1.8 and later, e.g.:
    /// 
    /// More information about moving resources can be found in our Migration Guide and in the Terraform documentation here and here.
    /// 
    /// ## Auto-Scaling with Effective Fields
    /// 
    /// The `UseEffectiveFields` attribute enhances auto-scaling workflows by eliminating the need for `lifecycle.ignore_changes` blocks and providing visibility into Atlas-managed changes. This feature only applies to dedicated clusters (M10+) and is not supported for flex and tenant clusters.
    /// 
    /// ### Why use_effective_fields?
    /// 
    /// When auto-scaling is enabled on a cluster, Atlas automatically adjusts instance sizes and disk capacity based on workload. Without `UseEffectiveFields`, `lifecycle.ignore_changes` blocks are required to prevent Terraform from reverting these Atlas-managed changes. This approach has limitations:
    /// 
    /// - **Configuration drift**: The actual cluster configuration diverges from your Terraform configuration
    /// - **Maintenance overhead**: Careful management of `IgnoreChanges` blocks is required, including commenting and uncommenting when making intentional changes
    /// - **Limited visibility**: Actual scaled values cannot be easily inspected within Terraform state
    /// 
    /// ### How UseEffectiveFields works
    /// 
    /// The `UseEffectiveFields` attribute changes how the provider handles specification attributes:
    /// 
    /// **When `UseEffectiveFields = false` (default - current behavior):**
    /// - Spec attributes (`ElectableSpecs`, `AnalyticsSpecs`, `ReadOnlySpecs`) behavior:
    ///   - If values are specified in your Terraform configuration (e.g., `InstanceSize = "M10"`), those values remain in your configuration
    ///   - If values are not specified, Atlas provides default values automatically
    /// - With auto-scaling enabled, Atlas scales your cluster but your configured values do not update to match
    /// - This creates plan drift: Terraform shows differences between your configured values and what Atlas has actually deployed
    /// - `lifecycle.ignore_changes` must be used to prevent Terraform from reverting Atlas auto-scaling changes back to your original configuration
    /// 
    /// **When `UseEffectiveFields = true` (new behavior):**
    /// - **Clear separation of concerns**:
    ///   - Spec attributes remain exactly as defined in your Terraform configuration
    ///   - Atlas-computed values (defaults and auto-scaled values) are available separately in effective specs
    /// - No plan drift occurs when Atlas auto-scales your cluster
    /// - Use data sources to read `EffectiveElectableSpecs`, `EffectiveAnalyticsSpecs`, and `EffectiveReadOnlySpecs` for actual values
    /// 
    /// **Key difference:** With `UseEffectiveFields = true`, your configuration stays clean and represents your intent, while effective specs show the reality of what Atlas has provisioned.
    /// 
    /// See the Example using effective fields with auto-scaling in the Example Usage section.
    /// 
    /// ### Manually Updating Specs with UseEffectiveFields
    /// 
    /// When `UseEffectiveFields = true` and auto-scaling is enabled, you can update `InstanceSize`, `DiskSizeGb`, or `DiskIops` in your configuration at any time without validation errors. However, Atlas echoes these values back in state while continuing to use auto-scaled values for actual cluster operations. To have your configured values take effect, temporarily disable auto-scaling:
    /// 
    /// 1. Set `ComputeEnabled = false` and `DiskGbEnabled = false` in the `AutoScaling` block and apply.
    /// 2. Update `InstanceSize`, `DiskSizeGb`, or `DiskIops` to your desired values and apply.
    /// 3. Re-enable auto-scaling by setting `ComputeEnabled` and/or `DiskGbEnabled` back to `True` and apply.
    /// 
    /// This workflow allows you to set specific baseline values from which auto-scaling will resume dynamic adjustments based on workload.
    /// 
    /// ### Terraform Modules
    /// 
    /// `UseEffectiveFields` is particularly valuable for reusable Terraform modules. Without it, separate module implementations are required (one with lifecycle blocks for auto-scaling, one without). With `UseEffectiveFields`, a single module handles both scenarios without lifecycle blocks. See the Effective Fields Examples for complete implementations.
    /// 
    /// ### Migration path and version 3.x
    /// 
    /// **Current behavior (provider v2.x):**
    /// - `UseEffectiveFields` defaults to `False` for full backward compatibility
    /// - Set to `True` to opt into the effective fields behavior
    /// - The attribute will be deprecated later in v2.x releases in preparation for v3.x
    /// 
    /// **Future behavior (provider v3.x):**
    /// - The effective fields behavior will be enabled by default
    /// - The `UseEffectiveFields` attribute will be removed, as the new behavior becomes standard
    /// - This change will reduce plan verbosity by making specification fields Optional-only (removing Computed), eliminating unnecessary `(known after apply)` markers for user-configured values
    /// 
    /// **Potential enhancements (v3.x or later):**
    /// - If customer demand warrants, effective spec fields (`EffectiveElectableSpecs`, `EffectiveAnalyticsSpecs`, `EffectiveReadOnlySpecs`) may be exposed directly in the resource (currently available only via data source)
    /// - This would improve observability by providing direct access to actual operational values from the resource without requiring a separate data source
    /// - Note: Effective fields would still show `(known after apply)` markers, but user-configured spec fields would not, resulting in clearer plan output overall
    /// 
    /// **Migration recommendation:** Adopt `UseEffectiveFields = true` in v2.x to prepare for the v3.x transition and benefit from improved auto-scaling workflows immediately. The recommendation is to toggle the flag and remove any existing `lifecycle.ignore_changes` blocks in the same apply, without combining other changes.
    /// 
    /// ## Considerations and Best Practices
    /// 
    /// ## Import
    /// 
    /// Clusters can be imported using project ID and cluster name, in the format `PROJECTID-CLUSTERNAME`, e.g.
    /// 
    /// ```sh
    /// $ pulumi import mongodbatlas:index/advancedCluster:AdvancedCluster my_cluster 1112222b3bf99403840e8934-Cluster0
    /// ```
    /// 
    /// See detailed information for arguments and attributes: [MongoDB API Advanced Clusters](https://docs.atlas.mongodb.com/reference/api/cluster-advanced/create-one-cluster-advanced/)
    /// 
    /// &gt; **IMPORTANT:**
    /// &lt;br&gt; &amp;#8226; When a cluster is imported, the resulting schema structure will always return the new schema including `ReplicationSpecs` per independent shards of the cluster.
    /// </summary>
    [MongodbatlasResourceType("mongodbatlas:index/advancedCluster:AdvancedCluster")]
    public partial class AdvancedCluster : global::Pulumi.CustomResource
    {
        /// <summary>
        /// If reconfiguration is necessary to regain a primary due to a regional outage, submit this field alongside your topology reconfiguration to request a new regional outage resistant topology. Forced reconfigurations during an outage of the majority of electable nodes carry a risk of data loss if replicated writes (even majority committed writes) have not been replicated to the new primary node. MongoDB Atlas docs contain more information. To proceed with an operation which carries that risk, set `AcceptDataRisksAndForceReplicaSetReconfig` to the current date. Learn more about Reconfiguring a Replica Set during a regional outage [here](https://dochub.mongodb.org/core/regional-outage-reconfigure-replica-set).
        /// </summary>
        [Output("acceptDataRisksAndForceReplicaSetReconfig")]
        public Output<string?> AcceptDataRisksAndForceReplicaSetReconfig { get; private set; } = null!;

        /// <summary>
        /// Additional settings for an Atlas cluster.
        /// </summary>
        [Output("advancedConfiguration")]
        public Output<Outputs.AdvancedClusterAdvancedConfiguration> AdvancedConfiguration { get; private set; } = null!;

        /// <summary>
        /// Flag that indicates whether the cluster can perform backups.
        /// If `True`, the cluster can perform backups. You must set this value to `True` for NVMe clusters.
        /// 
        /// Backup uses:
        /// [Cloud Backups](https://docs.atlas.mongodb.com/backup/cloud-backup/overview/#std-label-backup-cloud-provider) for dedicated clusters.
        /// [Flex Cluster Backups](https://www.mongodb.com/docs/atlas/backup/cloud-backup/flex-cluster-backup/) for flex clusters.
        /// If "`BackupEnabled`"  is `False` (default), the cluster doesn't use Atlas backups.
        /// </summary>
        [Output("backupEnabled")]
        public Output<bool> BackupEnabled { get; private set; } = null!;

        /// <summary>
        /// Configuration settings applied to BI Connector for Atlas on this cluster. The MongoDB Connector for Business Intelligence for Atlas (BI Connector) is only available for M10 and larger clusters. The BI Connector is a powerful tool which provides users SQL-based access to their MongoDB databases. As a result, the BI Connector performs operations which may be CPU and memory intensive. Given the limited hardware resources on M10 and M20 cluster tiers, you may experience performance degradation of the cluster when enabling the BI Connector. If this occurs, upgrade to an M30 or larger cluster or disable the BI Connector. See below.
        /// </summary>
        [Output("biConnectorConfig")]
        public Output<Outputs.AdvancedClusterBiConnectorConfig> BiConnectorConfig { get; private set; } = null!;

        /// <summary>
        /// The cluster ID.
        /// </summary>
        [Output("clusterId")]
        public Output<string> ClusterId { get; private set; } = null!;

        /// <summary>
        /// Type of the cluster that you want to create.
        /// Accepted values include:
        /// - `REPLICASET` Replica set
        /// - `SHARDED`	Sharded cluster
        /// - `GEOSHARDED` Global Cluster
        /// </summary>
        [Output("clusterType")]
        public Output<string> ClusterType { get; private set; } = null!;

        /// <summary>
        /// Config Server Management Mode for creating or updating a sharded cluster. Valid values are `ATLAS_MANAGED` (default) and `FIXED_TO_DEDICATED`. When configured as `ATLAS_MANAGED`, Atlas may automatically switch the cluster's config server type for optimal performance and savings. When configured as `FIXED_TO_DEDICATED`, the cluster will always use a dedicated config server. To learn more, see the [Sharded Cluster Config Servers documentation](https://dochub.mongodb.org/docs/manual/core/sharded-cluster-config-servers/).
        /// </summary>
        [Output("configServerManagementMode")]
        public Output<string> ConfigServerManagementMode { get; private set; } = null!;

        /// <summary>
        /// Describes a sharded cluster's config server type. Valid values are `DEDICATED` and `EMBEDDED`. To learn more, see the [Sharded Cluster Config Servers documentation](https://dochub.mongodb.org/docs/manual/core/sharded-cluster-config-servers/).
        /// </summary>
        [Output("configServerType")]
        public Output<string> ConfigServerType { get; private set; } = null!;

        /// <summary>
        /// Set of connection strings that your applications use to connect to this cluster. More information in [Connection-strings](https://docs.mongodb.com/manual/reference/connection-string/). Use the parameters in this object to connect your applications to this cluster. To learn more about the formats of connection strings, see [Connection String Options](https://docs.atlas.mongodb.com/reference/faq/connection-changes/). NOTE: Atlas returns the contents of this object after the cluster is operational, not while it builds the cluster.
        /// </summary>
        [Output("connectionStrings")]
        public Output<Outputs.AdvancedClusterConnectionStrings> ConnectionStrings { get; private set; } = null!;

        /// <summary>
        /// Date and time when MongoDB Cloud created this cluster. This parameter expresses its value in ISO 8601 format in UTC.
        /// </summary>
        [Output("createDate")]
        public Output<string> CreateDate { get; private set; } = null!;

        /// <summary>
        /// Indicates whether to delete the resource being created if a timeout is reached when waiting for completion. When set to `True` and timeout occurs, it triggers the deletion and returns immediately without waiting for deletion to complete. When set to `False`, the timeout will not trigger resource deletion. If you suspect a transient error when the value is `True`, wait before retrying to allow resource deletion to finish. Default is `True`.
        /// </summary>
        [Output("deleteOnCreateTimeout")]
        public Output<bool> DeleteOnCreateTimeout { get; private set; } = null!;

        /// <summary>
        /// Possible values are AWS, GCP, AZURE or NONE.  Only needed if you desire to manage the keys, see [Encryption at Rest using Customer Key Management](https://docs.atlas.mongodb.com/security-kms-encryption/) for complete documentation.  You must configure encryption at rest for the Atlas project before enabling it on any cluster in the project. For Documentation, see [AWS](https://docs.atlas.mongodb.com/security-aws-kms/), [GCP](https://docs.atlas.mongodb.com/security-kms-encryption/) and [Azure](https://docs.atlas.mongodb.com/security-azure-kms/#std-label-security-azure-kms). Requirements are if `replication_specs[#].region_configs[#].&lt;type&gt;Specs.instance_size` is M10 or greater and `BackupEnabled` is false or omitted.
        /// </summary>
        [Output("encryptionAtRestProvider")]
        public Output<string> EncryptionAtRestProvider { get; private set; } = null!;

        /// <summary>
        /// Flag that indicates if cluster uses Atlas-Managed Sharding (false, default) or Self-Managed Sharding (true). It can only be enabled for Global Clusters (`GEOSHARDED`). It cannot be changed once the cluster is created. Use this mode if you're an advanced user and the default configuration is too restrictive for your workload. If you select this option, you must manually configure the sharding strategy, more information [here](https://www.mongodb.com/docs/atlas/tutorial/create-global-cluster/#select-your-sharding-configuration).
        /// </summary>
        [Output("globalClusterSelfManagedSharding")]
        public Output<bool> GlobalClusterSelfManagedSharding { get; private set; } = null!;

        /// <summary>
        /// Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below. **DEPRECATED** Use `Tags` instead.
        /// </summary>
        [Output("labels")]
        public Output<ImmutableDictionary<string, string>?> Labels { get; private set; } = null!;

        /// <summary>
        /// Version of the cluster to deploy. Atlas supports all the MongoDB versions that have **not** reached [End of Live](https://www.mongodb.com/legal/support-policy/lifecycles) for M10+ clusters. If omitted, Atlas deploys the cluster with the default version. For more details, see [documentation](https://www.mongodb.com/docs/atlas/reference/faq/database/#which-versions-of-mongodb-do-service-clusters-use-). Atlas always deploys the cluster with the latest stable release of the specified version.  If you set a value to this parameter and set `VersionReleaseSystem` `CONTINUOUS`, the resource returns an error. Either clear this parameter or set `VersionReleaseSystem`: `LTS`.
        /// </summary>
        [Output("mongoDbMajorVersion")]
        public Output<string> MongoDbMajorVersion { get; private set; } = null!;

        /// <summary>
        /// Version of MongoDB the cluster runs, in `major-version`.`minor-version` format.
        /// </summary>
        [Output("mongoDbVersion")]
        public Output<string> MongoDbVersion { get; private set; } = null!;

        /// <summary>
        /// Name of the cluster as it appears in Atlas. Once the cluster is created, its name cannot be changed. **WARNING** Changing the name will result in destruction of the existing cluster and the creation of a new cluster.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// Flag that indicates whether the cluster is paused or not. You can pause M10 or larger clusters.  You cannot initiate pausing for a shared/tenant tier cluster. If you try to update a `Paused` cluster you will get a `CANNOT_UPDATE_PAUSED_CLUSTER` error. See [Considerations for Paused Clusters](https://docs.atlas.mongodb.com/pause-terminate-cluster/#considerations-for-paused-clusters).
        /// **NOTE** Pause lasts for up to 30 days. If you don't resume the cluster within 30 days, Atlas resumes the cluster.  When the cluster resumption happens Terraform will flag the changed state.  If you wish to keep the cluster paused, reapply your Terraform configuration.   If you prefer to allow the automated change of state to unpaused use:
        /// `lifecycle {
        /// IgnoreChanges = [paused]
        /// }`
        /// </summary>
        [Output("paused")]
        public Output<bool> Paused { get; private set; } = null!;

        /// <summary>
        /// Pins the Feature Compatibility Version (FCV) to the current MongoDB version with a provided expiration date. To unpin the FCV the `PinnedFcv` attribute must be removed. This operation can take several minutes as the request processes through the MongoDB data plane. Once FCV is unpinned it will not be possible to downgrade the `MongoDbMajorVersion`. It is advised that updates to `PinnedFcv` are done isolated from other cluster changes. If a plan contains multiple changes, the FCV change will be applied first. If FCV is unpinned past the expiration date the `PinnedFcv` attribute must be removed. The following [knowledge hub article](https://kb.corp.mongodb.com/article/000021785/) and [FCV documentation](https://www.mongodb.com/docs/atlas/tutorial/major-version-change/#manage-feature-compatibility--fcv--during-upgrades) can be referenced for more details. See below.
        /// </summary>
        [Output("pinnedFcv")]
        public Output<Outputs.AdvancedClusterPinnedFcv?> PinnedFcv { get; private set; } = null!;

        /// <summary>
        /// Flag that indicates if the cluster uses Continuous Cloud Backup.
        /// </summary>
        [Output("pitEnabled")]
        public Output<bool> PitEnabled { get; private set; } = null!;

        /// <summary>
        /// Unique ID for the project to create the cluster.
        /// </summary>
        [Output("projectId")]
        public Output<string> ProjectId { get; private set; } = null!;

        /// <summary>
        /// Flag that enables or disables log redaction, see the [manual](https://www.mongodb.com/docs/manual/administration/monitoring/#log-redaction) for more information. Use this in conjunction with Encryption at Rest and TLS/SSL (Transport Encryption) to assist compliance with regulatory requirements. **Note**: Changing this setting on a cluster will trigger a rolling restart as soon as the cluster is updated.
        /// </summary>
        [Output("redactClientLogData")]
        public Output<bool> RedactClientLogData { get; private set; } = null!;

        /// <summary>
        /// Replica set scaling mode for your cluster. Valid values are `WORKLOAD_TYPE`, `SEQUENTIAL` and `NODE_TYPE`. By default, Atlas scales under `WORKLOAD_TYPE`. This mode allows Atlas to scale your analytics nodes in parallel to your operational nodes. When configured as `SEQUENTIAL`, Atlas scales all nodes sequentially. This mode is intended for steady-state workloads and applications performing latency-sensitive secondary reads. When configured as `NODE_TYPE`, Atlas scales your electable nodes in parallel with your read-only and analytics nodes. This mode is intended for large, dynamic workloads requiring frequent and timely cluster tier scaling. This is the fastest scaling strategy, but it might impact latency of workloads when performing extensive secondary reads. [Modify the Replica Set Scaling Mode](https://dochub.mongodb.org/core/scale-nodes)
        /// </summary>
        [Output("replicaSetScalingStrategy")]
        public Output<string> ReplicaSetScalingStrategy { get; private set; } = null!;

        /// <summary>
        /// List of settings that configure your cluster regions. This attribute has one object per shard representing node configurations in each shard. For replica sets there is only one object representing node configurations. The `ReplicationSpecs` configuration for all shards within the same zone must be the same, with the exception of `InstanceSize` and `DiskIops` that can scale independently. Note that independent `DiskIops` values are only supported for AWS provisioned IOPS, or Azure regions that support Extended IOPS. See below.
        /// </summary>
        [Output("replicationSpecs")]
        public Output<ImmutableArray<Outputs.AdvancedClusterReplicationSpec>> ReplicationSpecs { get; private set; } = null!;

        /// <summary>
        /// Set to true to retain backup snapshots for the deleted cluster. This parameter applies to the Delete operation and only affects M10 and above clusters. If you encounter the `CANNOT_DELETE_SNAPSHOT_WITH_BACKUP_COMPLIANCE_POLICY` error code, see how to delete a cluster with Backup Compliance Policy.
        /// 
        /// &gt; **NOTE** Prior version of provider had parameter as `BiConnector` state will migrate it to new value you only need to update parameter in your terraform file
        /// </summary>
        [Output("retainBackupsEnabled")]
        public Output<bool?> RetainBackupsEnabled { get; private set; } = null!;

        /// <summary>
        /// Certificate Authority that MongoDB Atlas clusters use. You can specify ISRGROOTX1 (for ISRG Root X1).
        /// </summary>
        [Output("rootCertType")]
        public Output<string> RootCertType { get; private set; } = null!;

        /// <summary>
        /// Current state of the cluster. The possible states are:
        /// - IDLE
        /// - CREATING
        /// - UPDATING
        /// - DELETING
        /// - DELETED
        /// - REPAIRING
        /// * `replication_specs[#].container_id` - A key-value map of the Network Peering Container ID(s) for the configuration specified in `RegionConfigs`. The Container ID is the id of the container created when the first cluster in the region (AWS/Azure) or project (GCP) was created.  The syntax is `"providerName:regionName" = "containerId"`. Example `AWS:US_EAST_1" = "61e0797dde08fb498ca11a71`.
        /// </summary>
        [Output("stateName")]
        public Output<string> StateName { get; private set; } = null!;

        /// <summary>
        /// Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below.
        /// </summary>
        [Output("tags")]
        public Output<ImmutableDictionary<string, string>?> Tags { get; private set; } = null!;

        /// <summary>
        /// Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.
        /// </summary>
        [Output("terminationProtectionEnabled")]
        public Output<bool> TerminationProtectionEnabled { get; private set; } = null!;

        /// <summary>
        /// )
        /// </summary>
        [Output("timeouts")]
        public Output<Outputs.AdvancedClusterTimeouts?> Timeouts { get; private set; } = null!;

        /// <summary>
        /// Controls how hardware specification fields are returned in the response. When set to true, the non-effective specs (`ElectableSpecs`, `ReadOnlySpecs`, `AnalyticsSpecs`) fields return the hardware specifications that the client provided. When set to false (default), the non-effective specs fields show the **current** hardware specifications. Cluster auto-scaling is the primary cause for differences between initial and current hardware specifications. This opt-in feature enhances auto-scaling workflows by eliminating the need for `lifecycle.ignore_changes` blocks and preventing plan drift from Atlas-managed changes. This attribute applies to dedicated clusters, not to tenant or flex clusters. This attribute will be deprecated in provider version 2.x and removed in 3.x when the new behavior becomes default. See Auto-Scaling with Effective Fields for more details.
        /// **Important:** Toggle this flag and remove any existing `lifecycle.ignore_changes` blocks for spec fields in the same apply, without combining other changes. Toggling will result in increased plan verbosity with `(known after apply)` markers, which can be safely ignored. If you previously removed `ReadOnlySpecs` or `AnalyticsSpecs` attributes from your configuration, you'll get a validation error for safety reasons to prevent accidental node loss. To resolve: add the blocks back (to keep nodes) or with `NodeCount = 0` (to delete nodes), apply without toggling the flag, then toggle in a separate apply.
        /// </summary>
        [Output("useEffectiveFields")]
        public Output<bool?> UseEffectiveFields { get; private set; } = null!;

        /// <summary>
        /// Release cadence that Atlas uses for this cluster. This parameter defaults to `LTS`. If you set this field to `CONTINUOUS`, you must omit the `MongoDbMajorVersion` field. Atlas accepts:
        /// - `CONTINUOUS`:  Atlas creates your cluster using the most recent MongoDB release. Atlas automatically updates your cluster to the latest major and rapid MongoDB releases as they become available.
        /// - `LTS`: Atlas creates your cluster using the latest patch release of the MongoDB version that you specify in the mongoDBMajorVersion field. Atlas automatically updates your cluster to subsequent patch releases of this MongoDB version. Atlas doesn't update your cluster to newer rapid or major MongoDB releases as they become available.
        /// </summary>
        [Output("versionReleaseSystem")]
        public Output<string> VersionReleaseSystem { get; private set; } = null!;


        /// <summary>
        /// Create a AdvancedCluster resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public AdvancedCluster(string name, AdvancedClusterArgs args, CustomResourceOptions? options = null)
            : base("mongodbatlas:index/advancedCluster:AdvancedCluster", name, args ?? new AdvancedClusterArgs(), MakeResourceOptions(options, ""))
        {
        }

        private AdvancedCluster(string name, Input<string> id, AdvancedClusterState? state = null, CustomResourceOptions? options = null)
            : base("mongodbatlas:index/advancedCluster:AdvancedCluster", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing AdvancedCluster resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static AdvancedCluster Get(string name, Input<string> id, AdvancedClusterState? state = null, CustomResourceOptions? options = null)
        {
            return new AdvancedCluster(name, id, state, options);
        }
    }

    public sealed class AdvancedClusterArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// If reconfiguration is necessary to regain a primary due to a regional outage, submit this field alongside your topology reconfiguration to request a new regional outage resistant topology. Forced reconfigurations during an outage of the majority of electable nodes carry a risk of data loss if replicated writes (even majority committed writes) have not been replicated to the new primary node. MongoDB Atlas docs contain more information. To proceed with an operation which carries that risk, set `AcceptDataRisksAndForceReplicaSetReconfig` to the current date. Learn more about Reconfiguring a Replica Set during a regional outage [here](https://dochub.mongodb.org/core/regional-outage-reconfigure-replica-set).
        /// </summary>
        [Input("acceptDataRisksAndForceReplicaSetReconfig")]
        public Input<string>? AcceptDataRisksAndForceReplicaSetReconfig { get; set; }

        /// <summary>
        /// Additional settings for an Atlas cluster.
        /// </summary>
        [Input("advancedConfiguration")]
        public Input<Inputs.AdvancedClusterAdvancedConfigurationArgs>? AdvancedConfiguration { get; set; }

        /// <summary>
        /// Flag that indicates whether the cluster can perform backups.
        /// If `True`, the cluster can perform backups. You must set this value to `True` for NVMe clusters.
        /// 
        /// Backup uses:
        /// [Cloud Backups](https://docs.atlas.mongodb.com/backup/cloud-backup/overview/#std-label-backup-cloud-provider) for dedicated clusters.
        /// [Flex Cluster Backups](https://www.mongodb.com/docs/atlas/backup/cloud-backup/flex-cluster-backup/) for flex clusters.
        /// If "`BackupEnabled`"  is `False` (default), the cluster doesn't use Atlas backups.
        /// </summary>
        [Input("backupEnabled")]
        public Input<bool>? BackupEnabled { get; set; }

        /// <summary>
        /// Configuration settings applied to BI Connector for Atlas on this cluster. The MongoDB Connector for Business Intelligence for Atlas (BI Connector) is only available for M10 and larger clusters. The BI Connector is a powerful tool which provides users SQL-based access to their MongoDB databases. As a result, the BI Connector performs operations which may be CPU and memory intensive. Given the limited hardware resources on M10 and M20 cluster tiers, you may experience performance degradation of the cluster when enabling the BI Connector. If this occurs, upgrade to an M30 or larger cluster or disable the BI Connector. See below.
        /// </summary>
        [Input("biConnectorConfig")]
        public Input<Inputs.AdvancedClusterBiConnectorConfigArgs>? BiConnectorConfig { get; set; }

        /// <summary>
        /// Type of the cluster that you want to create.
        /// Accepted values include:
        /// - `REPLICASET` Replica set
        /// - `SHARDED`	Sharded cluster
        /// - `GEOSHARDED` Global Cluster
        /// </summary>
        [Input("clusterType", required: true)]
        public Input<string> ClusterType { get; set; } = null!;

        /// <summary>
        /// Config Server Management Mode for creating or updating a sharded cluster. Valid values are `ATLAS_MANAGED` (default) and `FIXED_TO_DEDICATED`. When configured as `ATLAS_MANAGED`, Atlas may automatically switch the cluster's config server type for optimal performance and savings. When configured as `FIXED_TO_DEDICATED`, the cluster will always use a dedicated config server. To learn more, see the [Sharded Cluster Config Servers documentation](https://dochub.mongodb.org/docs/manual/core/sharded-cluster-config-servers/).
        /// </summary>
        [Input("configServerManagementMode")]
        public Input<string>? ConfigServerManagementMode { get; set; }

        /// <summary>
        /// Indicates whether to delete the resource being created if a timeout is reached when waiting for completion. When set to `True` and timeout occurs, it triggers the deletion and returns immediately without waiting for deletion to complete. When set to `False`, the timeout will not trigger resource deletion. If you suspect a transient error when the value is `True`, wait before retrying to allow resource deletion to finish. Default is `True`.
        /// </summary>
        [Input("deleteOnCreateTimeout")]
        public Input<bool>? DeleteOnCreateTimeout { get; set; }

        /// <summary>
        /// Possible values are AWS, GCP, AZURE or NONE.  Only needed if you desire to manage the keys, see [Encryption at Rest using Customer Key Management](https://docs.atlas.mongodb.com/security-kms-encryption/) for complete documentation.  You must configure encryption at rest for the Atlas project before enabling it on any cluster in the project. For Documentation, see [AWS](https://docs.atlas.mongodb.com/security-aws-kms/), [GCP](https://docs.atlas.mongodb.com/security-kms-encryption/) and [Azure](https://docs.atlas.mongodb.com/security-azure-kms/#std-label-security-azure-kms). Requirements are if `replication_specs[#].region_configs[#].&lt;type&gt;Specs.instance_size` is M10 or greater and `BackupEnabled` is false or omitted.
        /// </summary>
        [Input("encryptionAtRestProvider")]
        public Input<string>? EncryptionAtRestProvider { get; set; }

        /// <summary>
        /// Flag that indicates if cluster uses Atlas-Managed Sharding (false, default) or Self-Managed Sharding (true). It can only be enabled for Global Clusters (`GEOSHARDED`). It cannot be changed once the cluster is created. Use this mode if you're an advanced user and the default configuration is too restrictive for your workload. If you select this option, you must manually configure the sharding strategy, more information [here](https://www.mongodb.com/docs/atlas/tutorial/create-global-cluster/#select-your-sharding-configuration).
        /// </summary>
        [Input("globalClusterSelfManagedSharding")]
        public Input<bool>? GlobalClusterSelfManagedSharding { get; set; }

        [Input("labels")]
        private InputMap<string>? _labels;

        /// <summary>
        /// Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below. **DEPRECATED** Use `Tags` instead.
        /// </summary>
        public InputMap<string> Labels
        {
            get => _labels ?? (_labels = new InputMap<string>());
            set => _labels = value;
        }

        /// <summary>
        /// Version of the cluster to deploy. Atlas supports all the MongoDB versions that have **not** reached [End of Live](https://www.mongodb.com/legal/support-policy/lifecycles) for M10+ clusters. If omitted, Atlas deploys the cluster with the default version. For more details, see [documentation](https://www.mongodb.com/docs/atlas/reference/faq/database/#which-versions-of-mongodb-do-service-clusters-use-). Atlas always deploys the cluster with the latest stable release of the specified version.  If you set a value to this parameter and set `VersionReleaseSystem` `CONTINUOUS`, the resource returns an error. Either clear this parameter or set `VersionReleaseSystem`: `LTS`.
        /// </summary>
        [Input("mongoDbMajorVersion")]
        public Input<string>? MongoDbMajorVersion { get; set; }

        /// <summary>
        /// Name of the cluster as it appears in Atlas. Once the cluster is created, its name cannot be changed. **WARNING** Changing the name will result in destruction of the existing cluster and the creation of a new cluster.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Flag that indicates whether the cluster is paused or not. You can pause M10 or larger clusters.  You cannot initiate pausing for a shared/tenant tier cluster. If you try to update a `Paused` cluster you will get a `CANNOT_UPDATE_PAUSED_CLUSTER` error. See [Considerations for Paused Clusters](https://docs.atlas.mongodb.com/pause-terminate-cluster/#considerations-for-paused-clusters).
        /// **NOTE** Pause lasts for up to 30 days. If you don't resume the cluster within 30 days, Atlas resumes the cluster.  When the cluster resumption happens Terraform will flag the changed state.  If you wish to keep the cluster paused, reapply your Terraform configuration.   If you prefer to allow the automated change of state to unpaused use:
        /// `lifecycle {
        /// IgnoreChanges = [paused]
        /// }`
        /// </summary>
        [Input("paused")]
        public Input<bool>? Paused { get; set; }

        /// <summary>
        /// Pins the Feature Compatibility Version (FCV) to the current MongoDB version with a provided expiration date. To unpin the FCV the `PinnedFcv` attribute must be removed. This operation can take several minutes as the request processes through the MongoDB data plane. Once FCV is unpinned it will not be possible to downgrade the `MongoDbMajorVersion`. It is advised that updates to `PinnedFcv` are done isolated from other cluster changes. If a plan contains multiple changes, the FCV change will be applied first. If FCV is unpinned past the expiration date the `PinnedFcv` attribute must be removed. The following [knowledge hub article](https://kb.corp.mongodb.com/article/000021785/) and [FCV documentation](https://www.mongodb.com/docs/atlas/tutorial/major-version-change/#manage-feature-compatibility--fcv--during-upgrades) can be referenced for more details. See below.
        /// </summary>
        [Input("pinnedFcv")]
        public Input<Inputs.AdvancedClusterPinnedFcvArgs>? PinnedFcv { get; set; }

        /// <summary>
        /// Flag that indicates if the cluster uses Continuous Cloud Backup.
        /// </summary>
        [Input("pitEnabled")]
        public Input<bool>? PitEnabled { get; set; }

        /// <summary>
        /// Unique ID for the project to create the cluster.
        /// </summary>
        [Input("projectId", required: true)]
        public Input<string> ProjectId { get; set; } = null!;

        /// <summary>
        /// Flag that enables or disables log redaction, see the [manual](https://www.mongodb.com/docs/manual/administration/monitoring/#log-redaction) for more information. Use this in conjunction with Encryption at Rest and TLS/SSL (Transport Encryption) to assist compliance with regulatory requirements. **Note**: Changing this setting on a cluster will trigger a rolling restart as soon as the cluster is updated.
        /// </summary>
        [Input("redactClientLogData")]
        public Input<bool>? RedactClientLogData { get; set; }

        /// <summary>
        /// Replica set scaling mode for your cluster. Valid values are `WORKLOAD_TYPE`, `SEQUENTIAL` and `NODE_TYPE`. By default, Atlas scales under `WORKLOAD_TYPE`. This mode allows Atlas to scale your analytics nodes in parallel to your operational nodes. When configured as `SEQUENTIAL`, Atlas scales all nodes sequentially. This mode is intended for steady-state workloads and applications performing latency-sensitive secondary reads. When configured as `NODE_TYPE`, Atlas scales your electable nodes in parallel with your read-only and analytics nodes. This mode is intended for large, dynamic workloads requiring frequent and timely cluster tier scaling. This is the fastest scaling strategy, but it might impact latency of workloads when performing extensive secondary reads. [Modify the Replica Set Scaling Mode](https://dochub.mongodb.org/core/scale-nodes)
        /// </summary>
        [Input("replicaSetScalingStrategy")]
        public Input<string>? ReplicaSetScalingStrategy { get; set; }

        [Input("replicationSpecs", required: true)]
        private InputList<Inputs.AdvancedClusterReplicationSpecArgs>? _replicationSpecs;

        /// <summary>
        /// List of settings that configure your cluster regions. This attribute has one object per shard representing node configurations in each shard. For replica sets there is only one object representing node configurations. The `ReplicationSpecs` configuration for all shards within the same zone must be the same, with the exception of `InstanceSize` and `DiskIops` that can scale independently. Note that independent `DiskIops` values are only supported for AWS provisioned IOPS, or Azure regions that support Extended IOPS. See below.
        /// </summary>
        public InputList<Inputs.AdvancedClusterReplicationSpecArgs> ReplicationSpecs
        {
            get => _replicationSpecs ?? (_replicationSpecs = new InputList<Inputs.AdvancedClusterReplicationSpecArgs>());
            set => _replicationSpecs = value;
        }

        /// <summary>
        /// Set to true to retain backup snapshots for the deleted cluster. This parameter applies to the Delete operation and only affects M10 and above clusters. If you encounter the `CANNOT_DELETE_SNAPSHOT_WITH_BACKUP_COMPLIANCE_POLICY` error code, see how to delete a cluster with Backup Compliance Policy.
        /// 
        /// &gt; **NOTE** Prior version of provider had parameter as `BiConnector` state will migrate it to new value you only need to update parameter in your terraform file
        /// </summary>
        [Input("retainBackupsEnabled")]
        public Input<bool>? RetainBackupsEnabled { get; set; }

        /// <summary>
        /// Certificate Authority that MongoDB Atlas clusters use. You can specify ISRGROOTX1 (for ISRG Root X1).
        /// </summary>
        [Input("rootCertType")]
        public Input<string>? RootCertType { get; set; }

        [Input("tags")]
        private InputMap<string>? _tags;

        /// <summary>
        /// Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below.
        /// </summary>
        public InputMap<string> Tags
        {
            get => _tags ?? (_tags = new InputMap<string>());
            set => _tags = value;
        }

        /// <summary>
        /// Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.
        /// </summary>
        [Input("terminationProtectionEnabled")]
        public Input<bool>? TerminationProtectionEnabled { get; set; }

        /// <summary>
        /// )
        /// </summary>
        [Input("timeouts")]
        public Input<Inputs.AdvancedClusterTimeoutsArgs>? Timeouts { get; set; }

        /// <summary>
        /// Controls how hardware specification fields are returned in the response. When set to true, the non-effective specs (`ElectableSpecs`, `ReadOnlySpecs`, `AnalyticsSpecs`) fields return the hardware specifications that the client provided. When set to false (default), the non-effective specs fields show the **current** hardware specifications. Cluster auto-scaling is the primary cause for differences between initial and current hardware specifications. This opt-in feature enhances auto-scaling workflows by eliminating the need for `lifecycle.ignore_changes` blocks and preventing plan drift from Atlas-managed changes. This attribute applies to dedicated clusters, not to tenant or flex clusters. This attribute will be deprecated in provider version 2.x and removed in 3.x when the new behavior becomes default. See Auto-Scaling with Effective Fields for more details.
        /// **Important:** Toggle this flag and remove any existing `lifecycle.ignore_changes` blocks for spec fields in the same apply, without combining other changes. Toggling will result in increased plan verbosity with `(known after apply)` markers, which can be safely ignored. If you previously removed `ReadOnlySpecs` or `AnalyticsSpecs` attributes from your configuration, you'll get a validation error for safety reasons to prevent accidental node loss. To resolve: add the blocks back (to keep nodes) or with `NodeCount = 0` (to delete nodes), apply without toggling the flag, then toggle in a separate apply.
        /// </summary>
        [Input("useEffectiveFields")]
        public Input<bool>? UseEffectiveFields { get; set; }

        /// <summary>
        /// Release cadence that Atlas uses for this cluster. This parameter defaults to `LTS`. If you set this field to `CONTINUOUS`, you must omit the `MongoDbMajorVersion` field. Atlas accepts:
        /// - `CONTINUOUS`:  Atlas creates your cluster using the most recent MongoDB release. Atlas automatically updates your cluster to the latest major and rapid MongoDB releases as they become available.
        /// - `LTS`: Atlas creates your cluster using the latest patch release of the MongoDB version that you specify in the mongoDBMajorVersion field. Atlas automatically updates your cluster to subsequent patch releases of this MongoDB version. Atlas doesn't update your cluster to newer rapid or major MongoDB releases as they become available.
        /// </summary>
        [Input("versionReleaseSystem")]
        public Input<string>? VersionReleaseSystem { get; set; }

        public AdvancedClusterArgs()
        {
        }
        public static new AdvancedClusterArgs Empty => new AdvancedClusterArgs();
    }

    public sealed class AdvancedClusterState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// If reconfiguration is necessary to regain a primary due to a regional outage, submit this field alongside your topology reconfiguration to request a new regional outage resistant topology. Forced reconfigurations during an outage of the majority of electable nodes carry a risk of data loss if replicated writes (even majority committed writes) have not been replicated to the new primary node. MongoDB Atlas docs contain more information. To proceed with an operation which carries that risk, set `AcceptDataRisksAndForceReplicaSetReconfig` to the current date. Learn more about Reconfiguring a Replica Set during a regional outage [here](https://dochub.mongodb.org/core/regional-outage-reconfigure-replica-set).
        /// </summary>
        [Input("acceptDataRisksAndForceReplicaSetReconfig")]
        public Input<string>? AcceptDataRisksAndForceReplicaSetReconfig { get; set; }

        /// <summary>
        /// Additional settings for an Atlas cluster.
        /// </summary>
        [Input("advancedConfiguration")]
        public Input<Inputs.AdvancedClusterAdvancedConfigurationGetArgs>? AdvancedConfiguration { get; set; }

        /// <summary>
        /// Flag that indicates whether the cluster can perform backups.
        /// If `True`, the cluster can perform backups. You must set this value to `True` for NVMe clusters.
        /// 
        /// Backup uses:
        /// [Cloud Backups](https://docs.atlas.mongodb.com/backup/cloud-backup/overview/#std-label-backup-cloud-provider) for dedicated clusters.
        /// [Flex Cluster Backups](https://www.mongodb.com/docs/atlas/backup/cloud-backup/flex-cluster-backup/) for flex clusters.
        /// If "`BackupEnabled`"  is `False` (default), the cluster doesn't use Atlas backups.
        /// </summary>
        [Input("backupEnabled")]
        public Input<bool>? BackupEnabled { get; set; }

        /// <summary>
        /// Configuration settings applied to BI Connector for Atlas on this cluster. The MongoDB Connector for Business Intelligence for Atlas (BI Connector) is only available for M10 and larger clusters. The BI Connector is a powerful tool which provides users SQL-based access to their MongoDB databases. As a result, the BI Connector performs operations which may be CPU and memory intensive. Given the limited hardware resources on M10 and M20 cluster tiers, you may experience performance degradation of the cluster when enabling the BI Connector. If this occurs, upgrade to an M30 or larger cluster or disable the BI Connector. See below.
        /// </summary>
        [Input("biConnectorConfig")]
        public Input<Inputs.AdvancedClusterBiConnectorConfigGetArgs>? BiConnectorConfig { get; set; }

        /// <summary>
        /// The cluster ID.
        /// </summary>
        [Input("clusterId")]
        public Input<string>? ClusterId { get; set; }

        /// <summary>
        /// Type of the cluster that you want to create.
        /// Accepted values include:
        /// - `REPLICASET` Replica set
        /// - `SHARDED`	Sharded cluster
        /// - `GEOSHARDED` Global Cluster
        /// </summary>
        [Input("clusterType")]
        public Input<string>? ClusterType { get; set; }

        /// <summary>
        /// Config Server Management Mode for creating or updating a sharded cluster. Valid values are `ATLAS_MANAGED` (default) and `FIXED_TO_DEDICATED`. When configured as `ATLAS_MANAGED`, Atlas may automatically switch the cluster's config server type for optimal performance and savings. When configured as `FIXED_TO_DEDICATED`, the cluster will always use a dedicated config server. To learn more, see the [Sharded Cluster Config Servers documentation](https://dochub.mongodb.org/docs/manual/core/sharded-cluster-config-servers/).
        /// </summary>
        [Input("configServerManagementMode")]
        public Input<string>? ConfigServerManagementMode { get; set; }

        /// <summary>
        /// Describes a sharded cluster's config server type. Valid values are `DEDICATED` and `EMBEDDED`. To learn more, see the [Sharded Cluster Config Servers documentation](https://dochub.mongodb.org/docs/manual/core/sharded-cluster-config-servers/).
        /// </summary>
        [Input("configServerType")]
        public Input<string>? ConfigServerType { get; set; }

        /// <summary>
        /// Set of connection strings that your applications use to connect to this cluster. More information in [Connection-strings](https://docs.mongodb.com/manual/reference/connection-string/). Use the parameters in this object to connect your applications to this cluster. To learn more about the formats of connection strings, see [Connection String Options](https://docs.atlas.mongodb.com/reference/faq/connection-changes/). NOTE: Atlas returns the contents of this object after the cluster is operational, not while it builds the cluster.
        /// </summary>
        [Input("connectionStrings")]
        public Input<Inputs.AdvancedClusterConnectionStringsGetArgs>? ConnectionStrings { get; set; }

        /// <summary>
        /// Date and time when MongoDB Cloud created this cluster. This parameter expresses its value in ISO 8601 format in UTC.
        /// </summary>
        [Input("createDate")]
        public Input<string>? CreateDate { get; set; }

        /// <summary>
        /// Indicates whether to delete the resource being created if a timeout is reached when waiting for completion. When set to `True` and timeout occurs, it triggers the deletion and returns immediately without waiting for deletion to complete. When set to `False`, the timeout will not trigger resource deletion. If you suspect a transient error when the value is `True`, wait before retrying to allow resource deletion to finish. Default is `True`.
        /// </summary>
        [Input("deleteOnCreateTimeout")]
        public Input<bool>? DeleteOnCreateTimeout { get; set; }

        /// <summary>
        /// Possible values are AWS, GCP, AZURE or NONE.  Only needed if you desire to manage the keys, see [Encryption at Rest using Customer Key Management](https://docs.atlas.mongodb.com/security-kms-encryption/) for complete documentation.  You must configure encryption at rest for the Atlas project before enabling it on any cluster in the project. For Documentation, see [AWS](https://docs.atlas.mongodb.com/security-aws-kms/), [GCP](https://docs.atlas.mongodb.com/security-kms-encryption/) and [Azure](https://docs.atlas.mongodb.com/security-azure-kms/#std-label-security-azure-kms). Requirements are if `replication_specs[#].region_configs[#].&lt;type&gt;Specs.instance_size` is M10 or greater and `BackupEnabled` is false or omitted.
        /// </summary>
        [Input("encryptionAtRestProvider")]
        public Input<string>? EncryptionAtRestProvider { get; set; }

        /// <summary>
        /// Flag that indicates if cluster uses Atlas-Managed Sharding (false, default) or Self-Managed Sharding (true). It can only be enabled for Global Clusters (`GEOSHARDED`). It cannot be changed once the cluster is created. Use this mode if you're an advanced user and the default configuration is too restrictive for your workload. If you select this option, you must manually configure the sharding strategy, more information [here](https://www.mongodb.com/docs/atlas/tutorial/create-global-cluster/#select-your-sharding-configuration).
        /// </summary>
        [Input("globalClusterSelfManagedSharding")]
        public Input<bool>? GlobalClusterSelfManagedSharding { get; set; }

        [Input("labels")]
        private InputMap<string>? _labels;

        /// <summary>
        /// Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below. **DEPRECATED** Use `Tags` instead.
        /// </summary>
        public InputMap<string> Labels
        {
            get => _labels ?? (_labels = new InputMap<string>());
            set => _labels = value;
        }

        /// <summary>
        /// Version of the cluster to deploy. Atlas supports all the MongoDB versions that have **not** reached [End of Live](https://www.mongodb.com/legal/support-policy/lifecycles) for M10+ clusters. If omitted, Atlas deploys the cluster with the default version. For more details, see [documentation](https://www.mongodb.com/docs/atlas/reference/faq/database/#which-versions-of-mongodb-do-service-clusters-use-). Atlas always deploys the cluster with the latest stable release of the specified version.  If you set a value to this parameter and set `VersionReleaseSystem` `CONTINUOUS`, the resource returns an error. Either clear this parameter or set `VersionReleaseSystem`: `LTS`.
        /// </summary>
        [Input("mongoDbMajorVersion")]
        public Input<string>? MongoDbMajorVersion { get; set; }

        /// <summary>
        /// Version of MongoDB the cluster runs, in `major-version`.`minor-version` format.
        /// </summary>
        [Input("mongoDbVersion")]
        public Input<string>? MongoDbVersion { get; set; }

        /// <summary>
        /// Name of the cluster as it appears in Atlas. Once the cluster is created, its name cannot be changed. **WARNING** Changing the name will result in destruction of the existing cluster and the creation of a new cluster.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Flag that indicates whether the cluster is paused or not. You can pause M10 or larger clusters.  You cannot initiate pausing for a shared/tenant tier cluster. If you try to update a `Paused` cluster you will get a `CANNOT_UPDATE_PAUSED_CLUSTER` error. See [Considerations for Paused Clusters](https://docs.atlas.mongodb.com/pause-terminate-cluster/#considerations-for-paused-clusters).
        /// **NOTE** Pause lasts for up to 30 days. If you don't resume the cluster within 30 days, Atlas resumes the cluster.  When the cluster resumption happens Terraform will flag the changed state.  If you wish to keep the cluster paused, reapply your Terraform configuration.   If you prefer to allow the automated change of state to unpaused use:
        /// `lifecycle {
        /// IgnoreChanges = [paused]
        /// }`
        /// </summary>
        [Input("paused")]
        public Input<bool>? Paused { get; set; }

        /// <summary>
        /// Pins the Feature Compatibility Version (FCV) to the current MongoDB version with a provided expiration date. To unpin the FCV the `PinnedFcv` attribute must be removed. This operation can take several minutes as the request processes through the MongoDB data plane. Once FCV is unpinned it will not be possible to downgrade the `MongoDbMajorVersion`. It is advised that updates to `PinnedFcv` are done isolated from other cluster changes. If a plan contains multiple changes, the FCV change will be applied first. If FCV is unpinned past the expiration date the `PinnedFcv` attribute must be removed. The following [knowledge hub article](https://kb.corp.mongodb.com/article/000021785/) and [FCV documentation](https://www.mongodb.com/docs/atlas/tutorial/major-version-change/#manage-feature-compatibility--fcv--during-upgrades) can be referenced for more details. See below.
        /// </summary>
        [Input("pinnedFcv")]
        public Input<Inputs.AdvancedClusterPinnedFcvGetArgs>? PinnedFcv { get; set; }

        /// <summary>
        /// Flag that indicates if the cluster uses Continuous Cloud Backup.
        /// </summary>
        [Input("pitEnabled")]
        public Input<bool>? PitEnabled { get; set; }

        /// <summary>
        /// Unique ID for the project to create the cluster.
        /// </summary>
        [Input("projectId")]
        public Input<string>? ProjectId { get; set; }

        /// <summary>
        /// Flag that enables or disables log redaction, see the [manual](https://www.mongodb.com/docs/manual/administration/monitoring/#log-redaction) for more information. Use this in conjunction with Encryption at Rest and TLS/SSL (Transport Encryption) to assist compliance with regulatory requirements. **Note**: Changing this setting on a cluster will trigger a rolling restart as soon as the cluster is updated.
        /// </summary>
        [Input("redactClientLogData")]
        public Input<bool>? RedactClientLogData { get; set; }

        /// <summary>
        /// Replica set scaling mode for your cluster. Valid values are `WORKLOAD_TYPE`, `SEQUENTIAL` and `NODE_TYPE`. By default, Atlas scales under `WORKLOAD_TYPE`. This mode allows Atlas to scale your analytics nodes in parallel to your operational nodes. When configured as `SEQUENTIAL`, Atlas scales all nodes sequentially. This mode is intended for steady-state workloads and applications performing latency-sensitive secondary reads. When configured as `NODE_TYPE`, Atlas scales your electable nodes in parallel with your read-only and analytics nodes. This mode is intended for large, dynamic workloads requiring frequent and timely cluster tier scaling. This is the fastest scaling strategy, but it might impact latency of workloads when performing extensive secondary reads. [Modify the Replica Set Scaling Mode](https://dochub.mongodb.org/core/scale-nodes)
        /// </summary>
        [Input("replicaSetScalingStrategy")]
        public Input<string>? ReplicaSetScalingStrategy { get; set; }

        [Input("replicationSpecs")]
        private InputList<Inputs.AdvancedClusterReplicationSpecGetArgs>? _replicationSpecs;

        /// <summary>
        /// List of settings that configure your cluster regions. This attribute has one object per shard representing node configurations in each shard. For replica sets there is only one object representing node configurations. The `ReplicationSpecs` configuration for all shards within the same zone must be the same, with the exception of `InstanceSize` and `DiskIops` that can scale independently. Note that independent `DiskIops` values are only supported for AWS provisioned IOPS, or Azure regions that support Extended IOPS. See below.
        /// </summary>
        public InputList<Inputs.AdvancedClusterReplicationSpecGetArgs> ReplicationSpecs
        {
            get => _replicationSpecs ?? (_replicationSpecs = new InputList<Inputs.AdvancedClusterReplicationSpecGetArgs>());
            set => _replicationSpecs = value;
        }

        /// <summary>
        /// Set to true to retain backup snapshots for the deleted cluster. This parameter applies to the Delete operation and only affects M10 and above clusters. If you encounter the `CANNOT_DELETE_SNAPSHOT_WITH_BACKUP_COMPLIANCE_POLICY` error code, see how to delete a cluster with Backup Compliance Policy.
        /// 
        /// &gt; **NOTE** Prior version of provider had parameter as `BiConnector` state will migrate it to new value you only need to update parameter in your terraform file
        /// </summary>
        [Input("retainBackupsEnabled")]
        public Input<bool>? RetainBackupsEnabled { get; set; }

        /// <summary>
        /// Certificate Authority that MongoDB Atlas clusters use. You can specify ISRGROOTX1 (for ISRG Root X1).
        /// </summary>
        [Input("rootCertType")]
        public Input<string>? RootCertType { get; set; }

        /// <summary>
        /// Current state of the cluster. The possible states are:
        /// - IDLE
        /// - CREATING
        /// - UPDATING
        /// - DELETING
        /// - DELETED
        /// - REPAIRING
        /// * `replication_specs[#].container_id` - A key-value map of the Network Peering Container ID(s) for the configuration specified in `RegionConfigs`. The Container ID is the id of the container created when the first cluster in the region (AWS/Azure) or project (GCP) was created.  The syntax is `"providerName:regionName" = "containerId"`. Example `AWS:US_EAST_1" = "61e0797dde08fb498ca11a71`.
        /// </summary>
        [Input("stateName")]
        public Input<string>? StateName { get; set; }

        [Input("tags")]
        private InputMap<string>? _tags;

        /// <summary>
        /// Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below.
        /// </summary>
        public InputMap<string> Tags
        {
            get => _tags ?? (_tags = new InputMap<string>());
            set => _tags = value;
        }

        /// <summary>
        /// Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.
        /// </summary>
        [Input("terminationProtectionEnabled")]
        public Input<bool>? TerminationProtectionEnabled { get; set; }

        /// <summary>
        /// )
        /// </summary>
        [Input("timeouts")]
        public Input<Inputs.AdvancedClusterTimeoutsGetArgs>? Timeouts { get; set; }

        /// <summary>
        /// Controls how hardware specification fields are returned in the response. When set to true, the non-effective specs (`ElectableSpecs`, `ReadOnlySpecs`, `AnalyticsSpecs`) fields return the hardware specifications that the client provided. When set to false (default), the non-effective specs fields show the **current** hardware specifications. Cluster auto-scaling is the primary cause for differences between initial and current hardware specifications. This opt-in feature enhances auto-scaling workflows by eliminating the need for `lifecycle.ignore_changes` blocks and preventing plan drift from Atlas-managed changes. This attribute applies to dedicated clusters, not to tenant or flex clusters. This attribute will be deprecated in provider version 2.x and removed in 3.x when the new behavior becomes default. See Auto-Scaling with Effective Fields for more details.
        /// **Important:** Toggle this flag and remove any existing `lifecycle.ignore_changes` blocks for spec fields in the same apply, without combining other changes. Toggling will result in increased plan verbosity with `(known after apply)` markers, which can be safely ignored. If you previously removed `ReadOnlySpecs` or `AnalyticsSpecs` attributes from your configuration, you'll get a validation error for safety reasons to prevent accidental node loss. To resolve: add the blocks back (to keep nodes) or with `NodeCount = 0` (to delete nodes), apply without toggling the flag, then toggle in a separate apply.
        /// </summary>
        [Input("useEffectiveFields")]
        public Input<bool>? UseEffectiveFields { get; set; }

        /// <summary>
        /// Release cadence that Atlas uses for this cluster. This parameter defaults to `LTS`. If you set this field to `CONTINUOUS`, you must omit the `MongoDbMajorVersion` field. Atlas accepts:
        /// - `CONTINUOUS`:  Atlas creates your cluster using the most recent MongoDB release. Atlas automatically updates your cluster to the latest major and rapid MongoDB releases as they become available.
        /// - `LTS`: Atlas creates your cluster using the latest patch release of the MongoDB version that you specify in the mongoDBMajorVersion field. Atlas automatically updates your cluster to subsequent patch releases of this MongoDB version. Atlas doesn't update your cluster to newer rapid or major MongoDB releases as they become available.
        /// </summary>
        [Input("versionReleaseSystem")]
        public Input<string>? VersionReleaseSystem { get; set; }

        public AdvancedClusterState()
        {
        }
        public static new AdvancedClusterState Empty => new AdvancedClusterState();
    }
}
