// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Mongodbatlas
{
    /// <summary>
    /// `mongodbatlas.OnlineArchive` resource provides access to create, edit, pause and resume an online archive for a collection.
    /// 
    /// &gt; **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.
    /// 
    /// &gt; **IMPORTANT:** The collection must exists before performing an online archive.
    /// 
    /// &gt; **IMPORTANT:** There are fields that are immutable after creation, i.e if `date_field` value does not exist in the collection, the online archive state will be pending forever, and this field cannot be updated, that means a destroy is required, known error `ONLINE_ARCHIVE_CANNOT_MODIFY_FIELD`
    /// 
    /// ## Example Usage
    /// </summary>
    [MongodbatlasResourceType("mongodbatlas:index/onlineArchive:OnlineArchive")]
    public partial class OnlineArchive : global::Pulumi.CustomResource
    {
        /// <summary>
        /// ID of the online archive.
        /// </summary>
        [Output("archiveId")]
        public Output<string> ArchiveId { get; private set; } = null!;

        /// <summary>
        /// Name of the cluster that contains the collection.
        /// </summary>
        [Output("clusterName")]
        public Output<string> ClusterName { get; private set; } = null!;

        /// <summary>
        /// Name of the collection.
        /// </summary>
        [Output("collName")]
        public Output<string> CollName { get; private set; } = null!;

        /// <summary>
        /// Criteria to use for archiving data.
        /// </summary>
        [Output("criteria")]
        public Output<Outputs.OnlineArchiveCriteria> Criteria { get; private set; } = null!;

        /// <summary>
        /// Name of the database that contains the collection.
        /// </summary>
        [Output("dbName")]
        public Output<string> DbName { get; private set; } = null!;

        /// <summary>
        /// Fields to use to partition data. You can specify up to two frequently queried fields to use for partitioning data. Note that queries that don’t contain the specified fields will require a full collection scan of all archived documents, which will take longer and increase your costs. To learn more about how partition improves query performance, see [Data Structure in S3](https://docs.mongodb.com/datalake/admin/optimize-query-performance/#data-structure-in-s3). The value of a partition field can be up to a maximum of 700 characters. Documents with values exceeding 700 characters are not archived.
        /// </summary>
        [Output("partitionFields")]
        public Output<ImmutableArray<Outputs.OnlineArchivePartitionField>> PartitionFields { get; private set; } = null!;

        /// <summary>
        /// State of the online archive. This is required for pausing an active or resume a paused online archive. The resume request will fail if the collection has another active online archive.
        /// </summary>
        [Output("paused")]
        public Output<bool> Paused { get; private set; } = null!;

        /// <summary>
        /// The unique ID for the project
        /// </summary>
        [Output("projectId")]
        public Output<string> ProjectId { get; private set; } = null!;

        /// <summary>
        /// Status of the online archive. Valid values are: Pending, Archiving, Idle, Pausing, Paused, Orphaned and Deleted
        /// </summary>
        [Output("state")]
        public Output<string> State { get; private set; } = null!;

        [Output("syncCreation")]
        public Output<bool?> SyncCreation { get; private set; } = null!;


        /// <summary>
        /// Create a OnlineArchive resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public OnlineArchive(string name, OnlineArchiveArgs args, CustomResourceOptions? options = null)
            : base("mongodbatlas:index/onlineArchive:OnlineArchive", name, args ?? new OnlineArchiveArgs(), MakeResourceOptions(options, ""))
        {
        }

        private OnlineArchive(string name, Input<string> id, OnlineArchiveState? state = null, CustomResourceOptions? options = null)
            : base("mongodbatlas:index/onlineArchive:OnlineArchive", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing OnlineArchive resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static OnlineArchive Get(string name, Input<string> id, OnlineArchiveState? state = null, CustomResourceOptions? options = null)
        {
            return new OnlineArchive(name, id, state, options);
        }
    }

    public sealed class OnlineArchiveArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Name of the cluster that contains the collection.
        /// </summary>
        [Input("clusterName", required: true)]
        public Input<string> ClusterName { get; set; } = null!;

        /// <summary>
        /// Name of the collection.
        /// </summary>
        [Input("collName", required: true)]
        public Input<string> CollName { get; set; } = null!;

        /// <summary>
        /// Criteria to use for archiving data.
        /// </summary>
        [Input("criteria", required: true)]
        public Input<Inputs.OnlineArchiveCriteriaArgs> Criteria { get; set; } = null!;

        /// <summary>
        /// Name of the database that contains the collection.
        /// </summary>
        [Input("dbName", required: true)]
        public Input<string> DbName { get; set; } = null!;

        [Input("partitionFields")]
        private InputList<Inputs.OnlineArchivePartitionFieldArgs>? _partitionFields;

        /// <summary>
        /// Fields to use to partition data. You can specify up to two frequently queried fields to use for partitioning data. Note that queries that don’t contain the specified fields will require a full collection scan of all archived documents, which will take longer and increase your costs. To learn more about how partition improves query performance, see [Data Structure in S3](https://docs.mongodb.com/datalake/admin/optimize-query-performance/#data-structure-in-s3). The value of a partition field can be up to a maximum of 700 characters. Documents with values exceeding 700 characters are not archived.
        /// </summary>
        public InputList<Inputs.OnlineArchivePartitionFieldArgs> PartitionFields
        {
            get => _partitionFields ?? (_partitionFields = new InputList<Inputs.OnlineArchivePartitionFieldArgs>());
            set => _partitionFields = value;
        }

        /// <summary>
        /// State of the online archive. This is required for pausing an active or resume a paused online archive. The resume request will fail if the collection has another active online archive.
        /// </summary>
        [Input("paused")]
        public Input<bool>? Paused { get; set; }

        /// <summary>
        /// The unique ID for the project
        /// </summary>
        [Input("projectId", required: true)]
        public Input<string> ProjectId { get; set; } = null!;

        [Input("syncCreation")]
        public Input<bool>? SyncCreation { get; set; }

        public OnlineArchiveArgs()
        {
        }
        public static new OnlineArchiveArgs Empty => new OnlineArchiveArgs();
    }

    public sealed class OnlineArchiveState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// ID of the online archive.
        /// </summary>
        [Input("archiveId")]
        public Input<string>? ArchiveId { get; set; }

        /// <summary>
        /// Name of the cluster that contains the collection.
        /// </summary>
        [Input("clusterName")]
        public Input<string>? ClusterName { get; set; }

        /// <summary>
        /// Name of the collection.
        /// </summary>
        [Input("collName")]
        public Input<string>? CollName { get; set; }

        /// <summary>
        /// Criteria to use for archiving data.
        /// </summary>
        [Input("criteria")]
        public Input<Inputs.OnlineArchiveCriteriaGetArgs>? Criteria { get; set; }

        /// <summary>
        /// Name of the database that contains the collection.
        /// </summary>
        [Input("dbName")]
        public Input<string>? DbName { get; set; }

        [Input("partitionFields")]
        private InputList<Inputs.OnlineArchivePartitionFieldGetArgs>? _partitionFields;

        /// <summary>
        /// Fields to use to partition data. You can specify up to two frequently queried fields to use for partitioning data. Note that queries that don’t contain the specified fields will require a full collection scan of all archived documents, which will take longer and increase your costs. To learn more about how partition improves query performance, see [Data Structure in S3](https://docs.mongodb.com/datalake/admin/optimize-query-performance/#data-structure-in-s3). The value of a partition field can be up to a maximum of 700 characters. Documents with values exceeding 700 characters are not archived.
        /// </summary>
        public InputList<Inputs.OnlineArchivePartitionFieldGetArgs> PartitionFields
        {
            get => _partitionFields ?? (_partitionFields = new InputList<Inputs.OnlineArchivePartitionFieldGetArgs>());
            set => _partitionFields = value;
        }

        /// <summary>
        /// State of the online archive. This is required for pausing an active or resume a paused online archive. The resume request will fail if the collection has another active online archive.
        /// </summary>
        [Input("paused")]
        public Input<bool>? Paused { get; set; }

        /// <summary>
        /// The unique ID for the project
        /// </summary>
        [Input("projectId")]
        public Input<string>? ProjectId { get; set; }

        /// <summary>
        /// Status of the online archive. Valid values are: Pending, Archiving, Idle, Pausing, Paused, Orphaned and Deleted
        /// </summary>
        [Input("state")]
        public Input<string>? State { get; set; }

        [Input("syncCreation")]
        public Input<bool>? SyncCreation { get; set; }

        public OnlineArchiveState()
        {
        }
        public static new OnlineArchiveState Empty => new OnlineArchiveState();
    }
}
