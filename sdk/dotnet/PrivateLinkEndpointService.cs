// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Mongodbatlas
{
    /// <summary>
    /// `mongodbatlas.PrivateLinkEndpointService` provides a Private Endpoint Interface Link resource. This represents a Private Endpoint Interface Link, which adds one [Interface Endpoint](https://www.mongodb.com/docs/atlas/security-private-endpoint/#private-endpoint-concepts) to a private endpoint connection in an Atlas project.
    /// 
    /// &gt; **IMPORTANT:** This resource links your cloud provider's Private Endpoint to the MongoDB Atlas Private Endpoint Service. It does not create the service itself (this is done by `mongodbatlas.PrivateLinkEndpoint`). You first create the service in Atlas with `mongodbatlas.PrivateLinkEndpoint`, then the endpoint is created in your cloud provider, and you link them together with the `mongodbatlas.PrivateLinkEndpointService` resource.
    /// 
    /// The private link Terraform module makes use of this resource and simplifies its use.
    /// 
    /// &gt; **NOTE:** You must have Organization Owner or Project Owner role. Create and delete operations wait for all clusters on the project to IDLE to ensure the latest connection strings can be retrieved (default timeout: 2hrs).
    /// 
    /// &gt; **IMPORTANT:** For GCP, MongoDB encourages customers to use the port-mapped architecture by setting `PortMappingEnabled = true` on the `mongodbatlas.PrivateLinkEndpoint` resource. This architecture uses a single set of resources to support up to 150 nodes. The legacy architecture requires dedicated resources for each Atlas node, which can lead to IP address exhaustion. For migration guidance, see the GCP Private Service Connect to Port-Mapped Architecture.
    /// 
    /// ## Example with AWS
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Aws = Pulumi.Aws;
    /// using Mongodbatlas = Pulumi.Mongodbatlas;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var @this = new Mongodbatlas.PrivateLinkEndpoint("this", new()
    ///     {
    ///         ProjectId = "&lt;PROJECT_ID&gt;",
    ///         ProviderName = "AWS",
    ///         Region = "US_EAST_1",
    ///     });
    /// 
    ///     var ptfeService = new Aws.Index.VpcEndpoint("ptfe_service", new()
    ///     {
    ///         VpcId = "vpc-7fc0a543",
    ///         ServiceName = @this.EndpointServiceName,
    ///         VpcEndpointType = "Interface",
    ///         SubnetIds = new[]
    ///         {
    ///             "subnet-de0406d2",
    ///         },
    ///         SecurityGroupIds = new[]
    ///         {
    ///             "sg-3f238186",
    ///         },
    ///     });
    /// 
    ///     var thisPrivateLinkEndpointService = new Mongodbatlas.PrivateLinkEndpointService("this", new()
    ///     {
    ///         ProjectId = @this.ProjectId,
    ///         PrivateLinkId = @this.PrivateLinkId,
    ///         EndpointServiceId = ptfeService.Id,
    ///         ProviderName = "AWS",
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Example with Azure
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Azurerm = Pulumi.Azurerm;
    /// using Mongodbatlas = Pulumi.Mongodbatlas;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var @this = new Mongodbatlas.PrivateLinkEndpoint("this", new()
    ///     {
    ///         ProjectId = projectId,
    ///         ProviderName = "AZURE",
    ///         Region = "eastus2",
    ///     });
    /// 
    ///     var thisPrivateEndpoint = new Azurerm.Index.PrivateEndpoint("this", new()
    ///     {
    ///         Name = "endpoint-this",
    ///         Location = thisAzurermResourceGroup.Location,
    ///         ResourceGroupName = resourceGroupName,
    ///         SubnetId = thisAzurermSubnet.Id,
    ///         PrivateServiceConnection = new[]
    ///         {
    ///             
    ///             {
    ///                 { "name", @this.PrivateLinkServiceName },
    ///                 { "privateConnectionResourceId", @this.PrivateLinkServiceResourceId },
    ///                 { "isManualConnection", true },
    ///                 { "requestMessage", "Azure Private Link this" },
    ///             },
    ///         },
    ///     });
    /// 
    ///     var thisPrivateLinkEndpointService = new Mongodbatlas.PrivateLinkEndpointService("this", new()
    ///     {
    ///         ProjectId = @this.ProjectId,
    ///         PrivateLinkId = @this.PrivateLinkId,
    ///         EndpointServiceId = thisPrivateEndpoint.Id,
    ///         PrivateEndpointIpAddress = thisPrivateEndpoint.PrivateServiceConnection[0].PrivateIpAddress,
    ///         ProviderName = "AZURE",
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Example with GCP (Legacy Architecture)
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Google = Pulumi.Google;
    /// using Mongodbatlas = Pulumi.Mongodbatlas;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var @this = new Mongodbatlas.PrivateLinkEndpoint("this", new()
    ///     {
    ///         ProjectId = projectId,
    ///         ProviderName = "GCP",
    ///         Region = gcpRegion,
    ///     });
    /// 
    ///     // Create a Google Network
    ///     var @default = new Google.Index.ComputeNetwork("default", new()
    ///     {
    ///         Project = gcpProjectId,
    ///         Name = "my-network",
    ///         AutoCreateSubnetworks = false,
    ///     });
    /// 
    ///     // Create a Google Sub Network
    ///     var defaultComputeSubnetwork = new Google.Index.ComputeSubnetwork("default", new()
    ///     {
    ///         Project = @default.Project,
    ///         Name = "my-subnet",
    ///         IpCidrRange = "10.0.0.0/16",
    ///         Region = gcpRegion,
    ///         Network = @default.Id,
    ///     });
    /// 
    ///     // Create Google 50 Addresses (required for GCP legacy private endpoint architecture)
    ///     var defaultComputeAddress = new List&lt;Google.Index.ComputeAddress&gt;();
    ///     for (var rangeIndex = 0; rangeIndex &lt; 50; rangeIndex++)
    ///     {
    ///         var range = new { Value = rangeIndex };
    ///         defaultComputeAddress.Add(new Google.Index.ComputeAddress($"default-{range.Value}", new()
    ///         {
    ///             Project = defaultComputeSubnetwork.Project,
    ///             Name = $"tf-this{range.Value}",
    ///             Subnetwork = defaultComputeSubnetwork.Id,
    ///             AddressType = "INTERNAL",
    ///             Address = $"10.0.42.{range.Value}",
    ///             Region = gcpRegion,
    ///         }, new CustomResourceOptions
    ///         {
    ///             DependsOn =
    ///             {
    ///                 @this,
    ///             },
    ///         }));
    ///     }
    ///     // Create 50 Forwarding rules (required for GCP legacy private endpoint architecture)
    ///     var defaultComputeForwardingRule = new List&lt;Google.Index.ComputeForwardingRule&gt;();
    ///     for (var rangeIndex = 0; rangeIndex &lt; 50; rangeIndex++)
    ///     {
    ///         var range = new { Value = rangeIndex };
    ///         defaultComputeForwardingRule.Add(new Google.Index.ComputeForwardingRule($"default-{range.Value}", new()
    ///         {
    ///             Target = @this.ServiceAttachmentNames[range.Value],
    ///             Project = defaultComputeAddress[range.Value].Project,
    ///             Region = defaultComputeAddress[range.Value].Region,
    ///             Name = defaultComputeAddress[range.Value].Name,
    ///             IpAddress = defaultComputeAddress[range.Value].Id,
    ///             Network = @default.Id,
    ///             LoadBalancingScheme = "",
    ///         }));
    ///     }
    ///     var thisPrivateLinkEndpointService = new Mongodbatlas.PrivateLinkEndpointService("this", new()
    ///     {
    ///         Endpoints = defaultComputeAddress.Select((v, k) =&gt; new { Key = k, Value = v }).Select(entry =&gt; 
    ///         {
    ///             return new Mongodbatlas.Inputs.PrivateLinkEndpointServiceEndpointArgs
    ///             {
    ///                 IpAddress = entry.Value.Address,
    ///                 EndpointName = defaultComputeForwardingRule[entry.Key].Name,
    ///             };
    ///         }).ToList(),
    ///         ProjectId = @this.ProjectId,
    ///         PrivateLinkId = @this.PrivateLinkId,
    ///         ProviderName = "GCP",
    ///         EndpointServiceId = @default.Name,
    ///         GcpProjectId = gcpProjectId,
    ///     }, new CustomResourceOptions
    ///     {
    ///         DependsOn =
    ///         {
    ///             defaultComputeForwardingRule,
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Example with GCP (Port-Mapped Architecture)
    /// 
    /// The port-mapped architecture uses port mapping to reduce resource provisioning. In the GCP legacy private endpoint architecture, service attachments were mapped 1:1 with Atlas nodes (one service attachment per node). In the port-mapped architecture, regardless of cloud provider, one service attachment can be mapped to up to 150 nodes via ports designated per node, enabling direct targeting of specific nodes using only one customer IP address. Enable it by setting `PortMappingEnabled = true` on the `mongodbatlas.PrivateLinkEndpoint` resource.
    /// 
    /// **Important:** For the port-mapped architecture, use `EndpointServiceId` (the forwarding rule name) and `PrivateEndpointIpAddress` (the IP address). The `Endpoints` list is no longer used for the port-mapped architecture.
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Google = Pulumi.Google;
    /// using Mongodbatlas = Pulumi.Mongodbatlas;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var @this = new Mongodbatlas.PrivateLinkEndpoint("this", new()
    ///     {
    ///         ProjectId = projectId,
    ///         ProviderName = "GCP",
    ///         Region = gcpRegion,
    ///         PortMappingEnabled = true,
    ///     });
    /// 
    ///     // Create a Google Network
    ///     var @default = new Google.Index.ComputeNetwork("default", new()
    ///     {
    ///         Project = gcpProjectId,
    ///         Name = "my-network",
    ///         AutoCreateSubnetworks = false,
    ///     });
    /// 
    ///     // Create a Google Sub Network
    ///     var defaultComputeSubnetwork = new Google.Index.ComputeSubnetwork("default", new()
    ///     {
    ///         Project = @default.Project,
    ///         Name = "my-subnet",
    ///         IpCidrRange = "10.0.0.0/16",
    ///         Region = gcpRegion,
    ///         Network = @default.Id,
    ///     });
    /// 
    ///     // Create Google Address (1 address for port-mapped architecture)
    ///     var defaultComputeAddress = new Google.Index.ComputeAddress("default", new()
    ///     {
    ///         Project = defaultComputeSubnetwork.Project,
    ///         Name = "tf-this-psc-endpoint",
    ///         Subnetwork = defaultComputeSubnetwork.Id,
    ///         AddressType = "INTERNAL",
    ///         Address = "10.0.42.1",
    ///         Region = defaultComputeSubnetwork.Region,
    ///     }, new CustomResourceOptions
    ///     {
    ///         DependsOn =
    ///         {
    ///             @this,
    ///         },
    ///     });
    /// 
    ///     // Create Forwarding Rule (1 rule for port-mapped architecture)
    ///     var defaultComputeForwardingRule = new Google.Index.ComputeForwardingRule("default", new()
    ///     {
    ///         Target = @this.ServiceAttachmentNames[0],
    ///         Project = defaultComputeAddress.Project,
    ///         Region = defaultComputeAddress.Region,
    ///         Name = defaultComputeAddress.Name,
    ///         IpAddress = defaultComputeAddress.Id,
    ///         Network = @default.Id,
    ///         LoadBalancingScheme = "",
    ///     });
    /// 
    ///     var thisPrivateLinkEndpointService = new Mongodbatlas.PrivateLinkEndpointService("this", new()
    ///     {
    ///         ProjectId = @this.ProjectId,
    ///         PrivateLinkId = @this.PrivateLinkId,
    ///         ProviderName = "GCP",
    ///         EndpointServiceId = defaultComputeForwardingRule.Name,
    ///         PrivateEndpointIpAddress = defaultComputeAddress.Address,
    ///         GcpProjectId = gcpProjectId,
    ///     }, new CustomResourceOptions
    ///     {
    ///         DependsOn =
    ///         {
    ///             defaultComputeForwardingRule,
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ### Further Examples
    /// - AWS PrivateLink Endpoint and Service
    /// - Azure Private Link Endpoint and Service
    /// - GCP Private Service Connect Endpoint and Service (Port-Mapped Architecture)
    /// 
    /// ## Import
    /// 
    /// Private Endpoint Link Connection can be imported using project ID, private link ID, endpoint service ID, and provider name, in the format `{project_id}--{private_link_id}--{endpoint_service_id}--{provider_name}`, e.g.
    /// 
    /// ```sh
    /// $ pulumi import mongodbatlas:index/privateLinkEndpointService:PrivateLinkEndpointService this 1112222b3bf99403840e8934--3242342343112--vpce-4242342343--AWS
    /// ```
    /// 
    /// For more information, see:
    /// - [MongoDB API Private Endpoint Link Connection](https://www.mongodb.com/docs/api/doc/atlas-admin-api-v2/operation/operation-creategroupprivateendpointendpointserviceendpoint) for detailed arguments and attributes.
    /// - [Set Up a Private Endpoint](https://www.mongodb.com/docs/atlas/security-private-endpoint/) for general guidance on private endpoints in MongoDB Atlas.
    /// </summary>
    [MongodbatlasResourceType("mongodbatlas:index/privateLinkEndpointService:PrivateLinkEndpointService")]
    public partial class PrivateLinkEndpointService : global::Pulumi.CustomResource
    {
        /// <summary>
        /// Status of the interface endpoint for AWS.
        /// Returns one of the following values:
        /// * `NONE` - Atlas created the network load balancer and VPC endpoint service, but AWS hasn't yet created the VPC endpoint.
        /// * `PENDING_ACCEPTANCE` - AWS has received the connection request from your VPC endpoint to the Atlas VPC endpoint service.
        /// * `PENDING` - AWS is establishing the connection between your VPC endpoint and the Atlas VPC endpoint service.
        /// * `AVAILABLE` - Atlas VPC resources are connected to the VPC endpoint in your VPC. You can connect to Atlas clusters in this region using AWS PrivateLink.
        /// * `REJECTED` - AWS failed to establish a connection between Atlas VPC resources to the VPC endpoint in your VPC.
        /// * `DELETING` - Atlas is removing the interface endpoint from the private endpoint connection.
        /// </summary>
        [Output("awsConnectionStatus")]
        public Output<string> AwsConnectionStatus { get; private set; } = null!;

        /// <summary>
        /// Status of the interface endpoint for AZURE.
        /// Returns one of the following values:
        /// * `INITIATING` - Atlas has not yet accepted the connection to your private endpoint.
        /// * `AVAILABLE` - Atlas approved the connection to your private endpoint.
        /// * `FAILED` - Atlas failed to accept the connection your private endpoint.
        /// * `DELETING` - Atlas is removing the connection to your private endpoint from the Private Link service.
        /// </summary>
        [Output("azureStatus")]
        public Output<string> AzureStatus { get; private set; } = null!;

        /// <summary>
        /// Indicates whether to delete the resource being created if a timeout is reached when waiting for completion. When set to `True` and timeout occurs, it triggers the deletion and returns immediately without waiting for deletion to complete. When set to `False`, the timeout will not trigger resource deletion. If you suspect a transient error when the value is `True`, wait before retrying to allow resource deletion to finish. Default is `True`.
        /// </summary>
        [Output("deleteOnCreateTimeout")]
        public Output<bool?> DeleteOnCreateTimeout { get; private set; } = null!;

        /// <summary>
        /// Indicates if Atlas received a request to remove the interface endpoint from the private endpoint connection.
        /// </summary>
        [Output("deleteRequested")]
        public Output<bool> DeleteRequested { get; private set; } = null!;

        [Output("endpointGroupName")]
        public Output<string> EndpointGroupName { get; private set; } = null!;

        /// <summary>
        /// Unique identifier of the interface endpoint you created in your VPC. For `AWS` and `AZURE`, this is the interface endpoint identifier. For `GCP` port-mapped architecture, this is the forwarding rule name. For `GCP` legacy private endpoint architecture, this is the endpoint group name.
        /// </summary>
        [Output("endpointServiceId")]
        public Output<string> EndpointServiceId { get; private set; } = null!;

        /// <summary>
        /// Collection of individual private endpoints that comprise your endpoint group. Only for GCP legacy private endpoint architecture. **Note:** For the port-mapped architecture, this field is no longer used - use `EndpointServiceId` and `PrivateEndpointIpAddress` instead.
        /// </summary>
        [Output("endpoints")]
        public Output<ImmutableArray<Outputs.PrivateLinkEndpointServiceEndpoint>> Endpoints { get; private set; } = null!;

        /// <summary>
        /// Error message pertaining to the interface endpoint. Returns null if there are no errors.
        /// </summary>
        [Output("errorMessage")]
        public Output<string> ErrorMessage { get; private set; } = null!;

        /// <summary>
        /// Status of the individual endpoint. Only populated for port-mapped architecture. Returns one of the following values: `INITIATING`, `AVAILABLE`, `FAILED`, `DELETING`.
        /// </summary>
        [Output("gcpEndpointStatus")]
        public Output<string> GcpEndpointStatus { get; private set; } = null!;

        /// <summary>
        /// Unique identifier of the GCP project in which you created your endpoints. **Required for `GCP`** (both legacy and port-mapped architectures). Only for `GCP`.
        /// </summary>
        [Output("gcpProjectId")]
        public Output<string?> GcpProjectId { get; private set; } = null!;

        /// <summary>
        /// Status of the interface endpoint.
        /// Returns one of the following values:
        /// * `INITIATING` - Atlas has not yet accepted the connection to your private endpoint.
        /// * `AVAILABLE` - Atlas approved the connection to your private endpoint.
        /// * `FAILED` - Atlas failed to accept the connection your private endpoint.
        /// * `DELETING` - Atlas is removing the connection to your private endpoint from the Private Link service.
        /// </summary>
        [Output("gcpStatus")]
        public Output<string> GcpStatus { get; private set; } = null!;

        /// <summary>
        /// Unique identifier of the interface endpoint.
        /// </summary>
        [Output("interfaceEndpointId")]
        public Output<string> InterfaceEndpointId { get; private set; } = null!;

        /// <summary>
        /// Flag that indicates whether the underlying `PrivatelinkEndpoint` resource uses GCP port-mapping. This is a read-only attribute that reflects the architecture type. When `True`, the endpoint service uses the port-mapped architecture. When `False`, it uses the GCP legacy private endpoint architecture. Only applicable for GCP provider.
        /// </summary>
        [Output("portMappingEnabled")]
        public Output<bool> PortMappingEnabled { get; private set; } = null!;

        /// <summary>
        /// Name of the connection for this private endpoint that Atlas generates.
        /// </summary>
        [Output("privateEndpointConnectionName")]
        public Output<string> PrivateEndpointConnectionName { get; private set; } = null!;

        /// <summary>
        /// Private IP address of the private endpoint network interface. **Required for `AZURE and GCP Port-Mapped`.** For port-mapped architecture, this is required and is the IP address of the forwarding rule. For GCP legacy private endpoint architecture, this is not used.
        /// </summary>
        [Output("privateEndpointIpAddress")]
        public Output<string> PrivateEndpointIpAddress { get; private set; } = null!;

        /// <summary>
        /// Unique identifier of the private endpoint.
        /// </summary>
        [Output("privateEndpointResourceId")]
        public Output<string> PrivateEndpointResourceId { get; private set; } = null!;

        /// <summary>
        /// Unique identifier of the `AWS`, `AZURE` or `GCP` PrivateLink connection which is created by `mongodbatlas.PrivateLinkEndpoint` resource.
        /// </summary>
        [Output("privateLinkId")]
        public Output<string> PrivateLinkId { get; private set; } = null!;

        /// <summary>
        /// Unique identifier for the project, also known as `GroupId` in the official documentation.
        /// </summary>
        [Output("projectId")]
        public Output<string> ProjectId { get; private set; } = null!;

        /// <summary>
        /// Cloud provider for which you want to create a private endpoint. Atlas accepts `AWS`, `AZURE` or `GCP`.
        /// </summary>
        [Output("providerName")]
        public Output<string> ProviderName { get; private set; } = null!;


        /// <summary>
        /// Create a PrivateLinkEndpointService resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public PrivateLinkEndpointService(string name, PrivateLinkEndpointServiceArgs args, CustomResourceOptions? options = null)
            : base("mongodbatlas:index/privateLinkEndpointService:PrivateLinkEndpointService", name, args ?? new PrivateLinkEndpointServiceArgs(), MakeResourceOptions(options, ""))
        {
        }

        private PrivateLinkEndpointService(string name, Input<string> id, PrivateLinkEndpointServiceState? state = null, CustomResourceOptions? options = null)
            : base("mongodbatlas:index/privateLinkEndpointService:PrivateLinkEndpointService", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing PrivateLinkEndpointService resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static PrivateLinkEndpointService Get(string name, Input<string> id, PrivateLinkEndpointServiceState? state = null, CustomResourceOptions? options = null)
        {
            return new PrivateLinkEndpointService(name, id, state, options);
        }
    }

    public sealed class PrivateLinkEndpointServiceArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Indicates whether to delete the resource being created if a timeout is reached when waiting for completion. When set to `True` and timeout occurs, it triggers the deletion and returns immediately without waiting for deletion to complete. When set to `False`, the timeout will not trigger resource deletion. If you suspect a transient error when the value is `True`, wait before retrying to allow resource deletion to finish. Default is `True`.
        /// </summary>
        [Input("deleteOnCreateTimeout")]
        public Input<bool>? DeleteOnCreateTimeout { get; set; }

        /// <summary>
        /// Unique identifier of the interface endpoint you created in your VPC. For `AWS` and `AZURE`, this is the interface endpoint identifier. For `GCP` port-mapped architecture, this is the forwarding rule name. For `GCP` legacy private endpoint architecture, this is the endpoint group name.
        /// </summary>
        [Input("endpointServiceId", required: true)]
        public Input<string> EndpointServiceId { get; set; } = null!;

        [Input("endpoints")]
        private InputList<Inputs.PrivateLinkEndpointServiceEndpointArgs>? _endpoints;

        /// <summary>
        /// Collection of individual private endpoints that comprise your endpoint group. Only for GCP legacy private endpoint architecture. **Note:** For the port-mapped architecture, this field is no longer used - use `EndpointServiceId` and `PrivateEndpointIpAddress` instead.
        /// </summary>
        public InputList<Inputs.PrivateLinkEndpointServiceEndpointArgs> Endpoints
        {
            get => _endpoints ?? (_endpoints = new InputList<Inputs.PrivateLinkEndpointServiceEndpointArgs>());
            set => _endpoints = value;
        }

        /// <summary>
        /// Unique identifier of the GCP project in which you created your endpoints. **Required for `GCP`** (both legacy and port-mapped architectures). Only for `GCP`.
        /// </summary>
        [Input("gcpProjectId")]
        public Input<string>? GcpProjectId { get; set; }

        /// <summary>
        /// Private IP address of the private endpoint network interface. **Required for `AZURE and GCP Port-Mapped`.** For port-mapped architecture, this is required and is the IP address of the forwarding rule. For GCP legacy private endpoint architecture, this is not used.
        /// </summary>
        [Input("privateEndpointIpAddress")]
        public Input<string>? PrivateEndpointIpAddress { get; set; }

        /// <summary>
        /// Unique identifier of the `AWS`, `AZURE` or `GCP` PrivateLink connection which is created by `mongodbatlas.PrivateLinkEndpoint` resource.
        /// </summary>
        [Input("privateLinkId", required: true)]
        public Input<string> PrivateLinkId { get; set; } = null!;

        /// <summary>
        /// Unique identifier for the project, also known as `GroupId` in the official documentation.
        /// </summary>
        [Input("projectId", required: true)]
        public Input<string> ProjectId { get; set; } = null!;

        /// <summary>
        /// Cloud provider for which you want to create a private endpoint. Atlas accepts `AWS`, `AZURE` or `GCP`.
        /// </summary>
        [Input("providerName", required: true)]
        public Input<string> ProviderName { get; set; } = null!;

        public PrivateLinkEndpointServiceArgs()
        {
        }
        public static new PrivateLinkEndpointServiceArgs Empty => new PrivateLinkEndpointServiceArgs();
    }

    public sealed class PrivateLinkEndpointServiceState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Status of the interface endpoint for AWS.
        /// Returns one of the following values:
        /// * `NONE` - Atlas created the network load balancer and VPC endpoint service, but AWS hasn't yet created the VPC endpoint.
        /// * `PENDING_ACCEPTANCE` - AWS has received the connection request from your VPC endpoint to the Atlas VPC endpoint service.
        /// * `PENDING` - AWS is establishing the connection between your VPC endpoint and the Atlas VPC endpoint service.
        /// * `AVAILABLE` - Atlas VPC resources are connected to the VPC endpoint in your VPC. You can connect to Atlas clusters in this region using AWS PrivateLink.
        /// * `REJECTED` - AWS failed to establish a connection between Atlas VPC resources to the VPC endpoint in your VPC.
        /// * `DELETING` - Atlas is removing the interface endpoint from the private endpoint connection.
        /// </summary>
        [Input("awsConnectionStatus")]
        public Input<string>? AwsConnectionStatus { get; set; }

        /// <summary>
        /// Status of the interface endpoint for AZURE.
        /// Returns one of the following values:
        /// * `INITIATING` - Atlas has not yet accepted the connection to your private endpoint.
        /// * `AVAILABLE` - Atlas approved the connection to your private endpoint.
        /// * `FAILED` - Atlas failed to accept the connection your private endpoint.
        /// * `DELETING` - Atlas is removing the connection to your private endpoint from the Private Link service.
        /// </summary>
        [Input("azureStatus")]
        public Input<string>? AzureStatus { get; set; }

        /// <summary>
        /// Indicates whether to delete the resource being created if a timeout is reached when waiting for completion. When set to `True` and timeout occurs, it triggers the deletion and returns immediately without waiting for deletion to complete. When set to `False`, the timeout will not trigger resource deletion. If you suspect a transient error when the value is `True`, wait before retrying to allow resource deletion to finish. Default is `True`.
        /// </summary>
        [Input("deleteOnCreateTimeout")]
        public Input<bool>? DeleteOnCreateTimeout { get; set; }

        /// <summary>
        /// Indicates if Atlas received a request to remove the interface endpoint from the private endpoint connection.
        /// </summary>
        [Input("deleteRequested")]
        public Input<bool>? DeleteRequested { get; set; }

        [Input("endpointGroupName")]
        public Input<string>? EndpointGroupName { get; set; }

        /// <summary>
        /// Unique identifier of the interface endpoint you created in your VPC. For `AWS` and `AZURE`, this is the interface endpoint identifier. For `GCP` port-mapped architecture, this is the forwarding rule name. For `GCP` legacy private endpoint architecture, this is the endpoint group name.
        /// </summary>
        [Input("endpointServiceId")]
        public Input<string>? EndpointServiceId { get; set; }

        [Input("endpoints")]
        private InputList<Inputs.PrivateLinkEndpointServiceEndpointGetArgs>? _endpoints;

        /// <summary>
        /// Collection of individual private endpoints that comprise your endpoint group. Only for GCP legacy private endpoint architecture. **Note:** For the port-mapped architecture, this field is no longer used - use `EndpointServiceId` and `PrivateEndpointIpAddress` instead.
        /// </summary>
        public InputList<Inputs.PrivateLinkEndpointServiceEndpointGetArgs> Endpoints
        {
            get => _endpoints ?? (_endpoints = new InputList<Inputs.PrivateLinkEndpointServiceEndpointGetArgs>());
            set => _endpoints = value;
        }

        /// <summary>
        /// Error message pertaining to the interface endpoint. Returns null if there are no errors.
        /// </summary>
        [Input("errorMessage")]
        public Input<string>? ErrorMessage { get; set; }

        /// <summary>
        /// Status of the individual endpoint. Only populated for port-mapped architecture. Returns one of the following values: `INITIATING`, `AVAILABLE`, `FAILED`, `DELETING`.
        /// </summary>
        [Input("gcpEndpointStatus")]
        public Input<string>? GcpEndpointStatus { get; set; }

        /// <summary>
        /// Unique identifier of the GCP project in which you created your endpoints. **Required for `GCP`** (both legacy and port-mapped architectures). Only for `GCP`.
        /// </summary>
        [Input("gcpProjectId")]
        public Input<string>? GcpProjectId { get; set; }

        /// <summary>
        /// Status of the interface endpoint.
        /// Returns one of the following values:
        /// * `INITIATING` - Atlas has not yet accepted the connection to your private endpoint.
        /// * `AVAILABLE` - Atlas approved the connection to your private endpoint.
        /// * `FAILED` - Atlas failed to accept the connection your private endpoint.
        /// * `DELETING` - Atlas is removing the connection to your private endpoint from the Private Link service.
        /// </summary>
        [Input("gcpStatus")]
        public Input<string>? GcpStatus { get; set; }

        /// <summary>
        /// Unique identifier of the interface endpoint.
        /// </summary>
        [Input("interfaceEndpointId")]
        public Input<string>? InterfaceEndpointId { get; set; }

        /// <summary>
        /// Flag that indicates whether the underlying `PrivatelinkEndpoint` resource uses GCP port-mapping. This is a read-only attribute that reflects the architecture type. When `True`, the endpoint service uses the port-mapped architecture. When `False`, it uses the GCP legacy private endpoint architecture. Only applicable for GCP provider.
        /// </summary>
        [Input("portMappingEnabled")]
        public Input<bool>? PortMappingEnabled { get; set; }

        /// <summary>
        /// Name of the connection for this private endpoint that Atlas generates.
        /// </summary>
        [Input("privateEndpointConnectionName")]
        public Input<string>? PrivateEndpointConnectionName { get; set; }

        /// <summary>
        /// Private IP address of the private endpoint network interface. **Required for `AZURE and GCP Port-Mapped`.** For port-mapped architecture, this is required and is the IP address of the forwarding rule. For GCP legacy private endpoint architecture, this is not used.
        /// </summary>
        [Input("privateEndpointIpAddress")]
        public Input<string>? PrivateEndpointIpAddress { get; set; }

        /// <summary>
        /// Unique identifier of the private endpoint.
        /// </summary>
        [Input("privateEndpointResourceId")]
        public Input<string>? PrivateEndpointResourceId { get; set; }

        /// <summary>
        /// Unique identifier of the `AWS`, `AZURE` or `GCP` PrivateLink connection which is created by `mongodbatlas.PrivateLinkEndpoint` resource.
        /// </summary>
        [Input("privateLinkId")]
        public Input<string>? PrivateLinkId { get; set; }

        /// <summary>
        /// Unique identifier for the project, also known as `GroupId` in the official documentation.
        /// </summary>
        [Input("projectId")]
        public Input<string>? ProjectId { get; set; }

        /// <summary>
        /// Cloud provider for which you want to create a private endpoint. Atlas accepts `AWS`, `AZURE` or `GCP`.
        /// </summary>
        [Input("providerName")]
        public Input<string>? ProviderName { get; set; }

        public PrivateLinkEndpointServiceState()
        {
        }
        public static new PrivateLinkEndpointServiceState Empty => new PrivateLinkEndpointServiceState();
    }
}
