// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package mongodbatlas

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// `FederatedDatabaseInstance` provides a Federated Database Instance resource.
//
// > **NOTE:** Groups and projects are synonymous terms. You may find groupId in the official documentation.
//
// ## Example Usage
//
// ### S With MongoDB Atlas Cluster As Storage Database
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := mongodbatlas.NewFederatedDatabaseInstance(ctx, "test", &mongodbatlas.FederatedDatabaseInstanceArgs{
//				ProjectId: pulumi.String("PROJECT ID"),
//				Name:      pulumi.String("TENANT NAME OF THE FEDERATED DATABASE INSTANCE"),
//				StorageDatabases: mongodbatlas.FederatedDatabaseInstanceStorageDatabaseArray{
//					&mongodbatlas.FederatedDatabaseInstanceStorageDatabaseArgs{
//						Name: pulumi.String("VirtualDatabase0"),
//						Collections: mongodbatlas.FederatedDatabaseInstanceStorageDatabaseCollectionArray{
//							&mongodbatlas.FederatedDatabaseInstanceStorageDatabaseCollectionArgs{
//								Name: pulumi.String("NAME OF THE COLLECTION"),
//								DataSources: mongodbatlas.FederatedDatabaseInstanceStorageDatabaseCollectionDataSourceArray{
//									&mongodbatlas.FederatedDatabaseInstanceStorageDatabaseCollectionDataSourceArgs{
//										Collection: pulumi.String("COLLECTION IN THE CLUSTER"),
//										Database:   pulumi.String("DB IN THE CLUSTER"),
//										StoreName:  pulumi.String("CLUSTER NAME"),
//									},
//								},
//							},
//						},
//					},
//				},
//				StorageStores: mongodbatlas.FederatedDatabaseInstanceStorageStoreArray{
//					&mongodbatlas.FederatedDatabaseInstanceStorageStoreArgs{
//						Name:        pulumi.String("STORE 1 NAME"),
//						ClusterName: pulumi.String("CLUSTER NAME"),
//						ProjectId:   pulumi.String("PROJECT ID"),
//						Provider:    pulumi.String("atlas"),
//						ReadPreference: &mongodbatlas.FederatedDatabaseInstanceStorageStoreReadPreferenceArgs{
//							Mode: pulumi.String("secondary"),
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### S With Amazon S3 Bucket As Storage Database
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := mongodbatlas.NewFederatedDatabaseInstance(ctx, "test", &mongodbatlas.FederatedDatabaseInstanceArgs{
//				ProjectId: pulumi.String("PROJECT ID"),
//				Name:      pulumi.String("TENANT NAME OF THE FEDERATED DATABASE INSTANCE"),
//				CloudProviderConfig: &mongodbatlas.FederatedDatabaseInstanceCloudProviderConfigArgs{
//					Aws: &mongodbatlas.FederatedDatabaseInstanceCloudProviderConfigAwsArgs{
//						RoleId:       pulumi.String("AWS ROLE ID"),
//						TestS3Bucket: pulumi.String("S3 BUCKET NAME"),
//					},
//				},
//				StorageDatabases: mongodbatlas.FederatedDatabaseInstanceStorageDatabaseArray{
//					&mongodbatlas.FederatedDatabaseInstanceStorageDatabaseArgs{
//						Name: pulumi.String("VirtualDatabase0"),
//						Collections: mongodbatlas.FederatedDatabaseInstanceStorageDatabaseCollectionArray{
//							&mongodbatlas.FederatedDatabaseInstanceStorageDatabaseCollectionArgs{
//								Name: pulumi.String("NAME OF THE COLLECTION"),
//								DataSources: mongodbatlas.FederatedDatabaseInstanceStorageDatabaseCollectionDataSourceArray{
//									&mongodbatlas.FederatedDatabaseInstanceStorageDatabaseCollectionDataSourceArgs{
//										Collection: pulumi.String("COLLECTION IN THE CLUSTER"),
//										Database:   pulumi.String("DB IN THE CLUSTER"),
//										StoreName:  pulumi.String("CLUSTER NAME"),
//									},
//									&mongodbatlas.FederatedDatabaseInstanceStorageDatabaseCollectionDataSourceArgs{
//										StoreName: pulumi.String("S3 BUCKET NAME"),
//										Path:      pulumi.String("S3 BUCKET PATH"),
//									},
//								},
//							},
//						},
//					},
//				},
//				StorageStores: mongodbatlas.FederatedDatabaseInstanceStorageStoreArray{
//					&mongodbatlas.FederatedDatabaseInstanceStorageStoreArgs{
//						Name:        pulumi.String("STORE 1 NAME"),
//						ClusterName: pulumi.String("CLUSTER NAME"),
//						ProjectId:   pulumi.String("PROJECT ID"),
//						Provider:    pulumi.String("atlas"),
//						ReadPreference: &mongodbatlas.FederatedDatabaseInstanceStorageStoreReadPreferenceArgs{
//							Mode: pulumi.String("secondary"),
//						},
//					},
//					&mongodbatlas.FederatedDatabaseInstanceStorageStoreArgs{
//						Bucket:    pulumi.String("STORE 2 NAME"),
//						Delimiter: pulumi.String("/"),
//						Name:      pulumi.String("S3 BUCKET NAME"),
//						Prefix:    pulumi.String("S3 BUCKET PREFIX"),
//						Provider:  pulumi.String("s3"),
//						Region:    pulumi.String("AWS REGION"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// - The Federated Database Instance can be imported using project ID, name of the instance, in the format `project_id`--`name`, e.g.
//
// ```sh
// $ pulumi import mongodbatlas:index/federatedDatabaseInstance:FederatedDatabaseInstance mongodbatlas_federated_database_instance.example 1112222b3bf99403840e8934--test
// ```
//
// - The Federated Database Instance can be imported using project ID, name of the instance and name of the AWS S3 bucket, in the format `project_id`--`name`--`aws_test_s3_bucket`, e.g.
//
// ```sh
// $ pulumi import mongodbatlas:index/federatedDatabaseInstance:FederatedDatabaseInstance mongodbatlas_federated_database_instance.example 1112222b3bf99403840e8934--test--s3-test
// ```
//
// See [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Data-Federation) Documentation for more information.
type FederatedDatabaseInstance struct {
	pulumi.CustomResourceState

	// Cloud provider linked to this data federated instance.
	// * `cloud_provider_config.aws` - (Required) AWS provider of the cloud service where the Federated Database Instance can access the S3 Bucket. Note this parameter is only required if using `cloudProviderConfig` since AWS is currently the only supported Cloud vendor on this feature at this time.
	// * `cloud_provider_config.aws.role_id` - (Required) Unique identifier of the role that the Federated Instance can use to access the data stores. If necessary, use the Atlas [UI](https://docs.atlas.mongodb.com/security/manage-iam-roles/) or [API](https://docs.atlas.mongodb.com/reference/api/cloud-provider-access-get-roles/) to retrieve the role ID. You must also specify the `testS3Bucket`.
	// * `cloud_provider_config.aws.test_s3_bucket` - (Required) Name of the S3 data bucket that the provided role ID is authorized to access. You must also specify the `roleId`.
	CloudProviderConfig FederatedDatabaseInstanceCloudProviderConfigOutput `pulumi:"cloudProviderConfig"`
	// The cloud provider region to which the Federated Instance routes client connections for data processing.
	// * `data_process_region.cloud_provider` - (Required) Name of the cloud service provider. Atlas Federated Database only supports AWS.
	// * `data_process_region.region` - (Required) Name of the region to which the Federanted Instnace routes client connections for data processing. See the [documention](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Data-Federation/operation/createFederatedDatabase) for the available region.
	DataProcessRegion FederatedDatabaseInstanceDataProcessRegionOutput `pulumi:"dataProcessRegion"`
	// The list of hostnames assigned to the Federated Database Instance. Each string in the array is a hostname assigned to the Federated Database Instance.
	Hostnames pulumi.StringArrayOutput `pulumi:"hostnames"`
	// Name of the Atlas Federated Database Instance.
	Name pulumi.StringOutput `pulumi:"name"`
	// The unique ID for the project to create a Federated Database Instance.
	ProjectId pulumi.StringOutput `pulumi:"projectId"`
	// Current state of the Federated Database Instance:
	// * `ACTIVE` - The Federated Database Instance is active and verified. You can query the data stores associated with the Federated Database Instance.
	// * `DELETED` - The Federated Database Instance was deleted.
	State pulumi.StringOutput `pulumi:"state"`
	// Configuration details for mapping each data store to queryable databases and collections. For complete documentation on this object and its nested fields, see [databases](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#std-label-datalake-databases-reference). An empty object indicates that the Federated Database Instance has no mapping configuration for any data store.
	// * `storage_databases.#.name` - Name of the database to which the Federated Database Instance maps the data contained in the data store.
	// * `storage_databases.#.collections` -     Array of objects where each object represents a collection and data sources that map to a [stores](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#mongodb-datalakeconf-datalakeconf.stores) data store.
	// * `storage_databases.#.collections.#.name` - Name of the collection.
	// * `storage_databases.#.collections.#.data_sources` -     Array of objects where each object represents a stores data store to map with the collection.
	// * `storage_databases.#.collections.#.data_sources.#.store_name` -     Name of a data store to map to the `<collection>`. Must match the name of an object in the stores array.
	// * `storage_databases.#.collections.#.data_sources.#.dataset_name` -     Human-readable label that identifies the dataset that Atlas generates for an ingestion pipeline run or Online Archive.
	// * `storage_databases.#.collections.#.data_sources.#.default_format` - Default format that Federated Database assumes if it encounters a file without an extension while searching the storeName.
	// * `storage_databases.#.collections.#.data_sources.#.path` - File path that controls how MongoDB Cloud searches for and parses files in the storeName before mapping them to a collection. Specify / to capture all files and folders from the prefix path.
	// * `storage_databases.#.collections.#.data_sources.#.database` - Human-readable label that identifies the database, which contains the collection in the cluster.
	// * `storage_databases.#.collections.#.data_sources.#.allow_insecure` - Flag that validates the scheme in the specified URLs. If true, allows insecure HTTP scheme, doesn't verify the server's certificate chain and hostname, and accepts any certificate with any hostname presented by the server. If false, allows secure HTTPS scheme only.
	// * `storage_databases.#.collections.#.data_sources.#.database_regex` - Regex pattern to use for creating the wildcard database.
	// * `storage_databases.#.collections.#.data_sources.#.collection` - Human-readable label that identifies the collection in the database.
	// * `storage_databases.#.collections.#.data_sources.#.collection_regex` - Regex pattern to use for creating the wildcard (*) collection.
	// * `storage_databases.#.collections.#.data_sources.#.provenance_field_name` - Name for the field that includes the provenance of the documents in the results.
	// * `storage_databases.#.collections.#.data_sources.#.storeName` - Human-readable label that identifies the data store that MongoDB Cloud maps to the collection.
	// * `storage_databases.#.collections.#.data_sources.#.urls` - URLs of the publicly accessible data files. You can't specify URLs that require authentication.
	// * `storage_databases.#.views` -     Array of objects where each object represents an [aggregation pipeline](https://docs.mongodb.com/manual/core/aggregation-pipeline/#id1) on a collection. To learn more about views, see [Views](https://docs.mongodb.com/manual/core/views/).
	// * `storage_databases.#.views.#.name` - Name of the view.
	// * `storage_databases.#.views.#.source` -  Name of the source collection for the view.
	// * `storage_databases.#.views.#.pipeline`- Aggregation pipeline stage(s) to apply to the source collection.
	StorageDatabases FederatedDatabaseInstanceStorageDatabaseArrayOutput `pulumi:"storageDatabases"`
	// Each object in the array represents a data store. Federated Database uses the storage.databases configuration details to map data in each data store to queryable databases and collections. For complete documentation on this object and its nested fields, see [stores](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#std-label-datalake-stores-reference). An empty object indicates that the Federated Database Instance has no configured data stores.
	// * `storage_stores.#.name` - Name of the data store.
	// * `storage_stores.#.provider` - Defines where the data is stored.
	// * `storage_stores.#.region` - Name of the AWS region in which the S3 bucket is hosted.
	// * `storage_stores.#.bucket` - Name of the AWS S3 bucket.
	// * `storage_stores.#.prefix` - Prefix the Federated Database Instance applies when searching for files in the S3 bucket.
	// * `storage_stores.#.delimiter` - The delimiter that separates `storage_databases.#.collections.#.data_sources.#.path` segments in the data store.
	// * `storage_stores.#.include_tags` - Determines whether or not to use S3 tags on the files in the given path as additional partition attributes.
	// * `storage_stores.#.cluster_name` - Human-readable label of the MongoDB Cloud cluster on which the store is based.
	// * `storage_stores.#.cluster_id` - ID of the Cluster the Online Archive belongs to.
	// * `storage_stores.#.allow_insecure` - Flag that validates the scheme in the specified URLs.
	// * `storage_stores.#.public` - Flag that indicates whether the bucket is public.
	// * `storage_stores.#.default_format` - Default format that Data Lake assumes if it encounters a file without an extension while searching the storeName.
	// * `storage_stores.#.urls` - Comma-separated list of publicly accessible HTTP URLs where data is stored.
	// * `storage_stores.#.read_preference` - MongoDB Cloud cluster read preference, which describes how to route read requests to the cluster.
	// * `storage_stores.#.read_preference.maxStalenessSeconds` - Maximum replication lag, or staleness, for reads from secondaries.
	// * `storage_stores.#.read_preference.mode` - Read preference mode that specifies to which replica set member to route the read requests.
	// * `storage_stores.#.read_preference.tag_sets` - List that contains tag sets or tag specification documents.
	// * `storage_stores.#.read_preference.tags` - List of all tags within a tag set
	// * `storage_stores.#.read_preference.tags.name` - Human-readable label of the tag.
	// * `storage_stores.#.read_preference.tags.value` - Value of the tag.
	StorageStores FederatedDatabaseInstanceStorageStoreArrayOutput `pulumi:"storageStores"`
}

// NewFederatedDatabaseInstance registers a new resource with the given unique name, arguments, and options.
func NewFederatedDatabaseInstance(ctx *pulumi.Context,
	name string, args *FederatedDatabaseInstanceArgs, opts ...pulumi.ResourceOption) (*FederatedDatabaseInstance, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ProjectId == nil {
		return nil, errors.New("invalid value for required argument 'ProjectId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource FederatedDatabaseInstance
	err := ctx.RegisterResource("mongodbatlas:index/federatedDatabaseInstance:FederatedDatabaseInstance", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetFederatedDatabaseInstance gets an existing FederatedDatabaseInstance resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetFederatedDatabaseInstance(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *FederatedDatabaseInstanceState, opts ...pulumi.ResourceOption) (*FederatedDatabaseInstance, error) {
	var resource FederatedDatabaseInstance
	err := ctx.ReadResource("mongodbatlas:index/federatedDatabaseInstance:FederatedDatabaseInstance", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering FederatedDatabaseInstance resources.
type federatedDatabaseInstanceState struct {
	// Cloud provider linked to this data federated instance.
	// * `cloud_provider_config.aws` - (Required) AWS provider of the cloud service where the Federated Database Instance can access the S3 Bucket. Note this parameter is only required if using `cloudProviderConfig` since AWS is currently the only supported Cloud vendor on this feature at this time.
	// * `cloud_provider_config.aws.role_id` - (Required) Unique identifier of the role that the Federated Instance can use to access the data stores. If necessary, use the Atlas [UI](https://docs.atlas.mongodb.com/security/manage-iam-roles/) or [API](https://docs.atlas.mongodb.com/reference/api/cloud-provider-access-get-roles/) to retrieve the role ID. You must also specify the `testS3Bucket`.
	// * `cloud_provider_config.aws.test_s3_bucket` - (Required) Name of the S3 data bucket that the provided role ID is authorized to access. You must also specify the `roleId`.
	CloudProviderConfig *FederatedDatabaseInstanceCloudProviderConfig `pulumi:"cloudProviderConfig"`
	// The cloud provider region to which the Federated Instance routes client connections for data processing.
	// * `data_process_region.cloud_provider` - (Required) Name of the cloud service provider. Atlas Federated Database only supports AWS.
	// * `data_process_region.region` - (Required) Name of the region to which the Federanted Instnace routes client connections for data processing. See the [documention](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Data-Federation/operation/createFederatedDatabase) for the available region.
	DataProcessRegion *FederatedDatabaseInstanceDataProcessRegion `pulumi:"dataProcessRegion"`
	// The list of hostnames assigned to the Federated Database Instance. Each string in the array is a hostname assigned to the Federated Database Instance.
	Hostnames []string `pulumi:"hostnames"`
	// Name of the Atlas Federated Database Instance.
	Name *string `pulumi:"name"`
	// The unique ID for the project to create a Federated Database Instance.
	ProjectId *string `pulumi:"projectId"`
	// Current state of the Federated Database Instance:
	// * `ACTIVE` - The Federated Database Instance is active and verified. You can query the data stores associated with the Federated Database Instance.
	// * `DELETED` - The Federated Database Instance was deleted.
	State *string `pulumi:"state"`
	// Configuration details for mapping each data store to queryable databases and collections. For complete documentation on this object and its nested fields, see [databases](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#std-label-datalake-databases-reference). An empty object indicates that the Federated Database Instance has no mapping configuration for any data store.
	// * `storage_databases.#.name` - Name of the database to which the Federated Database Instance maps the data contained in the data store.
	// * `storage_databases.#.collections` -     Array of objects where each object represents a collection and data sources that map to a [stores](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#mongodb-datalakeconf-datalakeconf.stores) data store.
	// * `storage_databases.#.collections.#.name` - Name of the collection.
	// * `storage_databases.#.collections.#.data_sources` -     Array of objects where each object represents a stores data store to map with the collection.
	// * `storage_databases.#.collections.#.data_sources.#.store_name` -     Name of a data store to map to the `<collection>`. Must match the name of an object in the stores array.
	// * `storage_databases.#.collections.#.data_sources.#.dataset_name` -     Human-readable label that identifies the dataset that Atlas generates for an ingestion pipeline run or Online Archive.
	// * `storage_databases.#.collections.#.data_sources.#.default_format` - Default format that Federated Database assumes if it encounters a file without an extension while searching the storeName.
	// * `storage_databases.#.collections.#.data_sources.#.path` - File path that controls how MongoDB Cloud searches for and parses files in the storeName before mapping them to a collection. Specify / to capture all files and folders from the prefix path.
	// * `storage_databases.#.collections.#.data_sources.#.database` - Human-readable label that identifies the database, which contains the collection in the cluster.
	// * `storage_databases.#.collections.#.data_sources.#.allow_insecure` - Flag that validates the scheme in the specified URLs. If true, allows insecure HTTP scheme, doesn't verify the server's certificate chain and hostname, and accepts any certificate with any hostname presented by the server. If false, allows secure HTTPS scheme only.
	// * `storage_databases.#.collections.#.data_sources.#.database_regex` - Regex pattern to use for creating the wildcard database.
	// * `storage_databases.#.collections.#.data_sources.#.collection` - Human-readable label that identifies the collection in the database.
	// * `storage_databases.#.collections.#.data_sources.#.collection_regex` - Regex pattern to use for creating the wildcard (*) collection.
	// * `storage_databases.#.collections.#.data_sources.#.provenance_field_name` - Name for the field that includes the provenance of the documents in the results.
	// * `storage_databases.#.collections.#.data_sources.#.storeName` - Human-readable label that identifies the data store that MongoDB Cloud maps to the collection.
	// * `storage_databases.#.collections.#.data_sources.#.urls` - URLs of the publicly accessible data files. You can't specify URLs that require authentication.
	// * `storage_databases.#.views` -     Array of objects where each object represents an [aggregation pipeline](https://docs.mongodb.com/manual/core/aggregation-pipeline/#id1) on a collection. To learn more about views, see [Views](https://docs.mongodb.com/manual/core/views/).
	// * `storage_databases.#.views.#.name` - Name of the view.
	// * `storage_databases.#.views.#.source` -  Name of the source collection for the view.
	// * `storage_databases.#.views.#.pipeline`- Aggregation pipeline stage(s) to apply to the source collection.
	StorageDatabases []FederatedDatabaseInstanceStorageDatabase `pulumi:"storageDatabases"`
	// Each object in the array represents a data store. Federated Database uses the storage.databases configuration details to map data in each data store to queryable databases and collections. For complete documentation on this object and its nested fields, see [stores](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#std-label-datalake-stores-reference). An empty object indicates that the Federated Database Instance has no configured data stores.
	// * `storage_stores.#.name` - Name of the data store.
	// * `storage_stores.#.provider` - Defines where the data is stored.
	// * `storage_stores.#.region` - Name of the AWS region in which the S3 bucket is hosted.
	// * `storage_stores.#.bucket` - Name of the AWS S3 bucket.
	// * `storage_stores.#.prefix` - Prefix the Federated Database Instance applies when searching for files in the S3 bucket.
	// * `storage_stores.#.delimiter` - The delimiter that separates `storage_databases.#.collections.#.data_sources.#.path` segments in the data store.
	// * `storage_stores.#.include_tags` - Determines whether or not to use S3 tags on the files in the given path as additional partition attributes.
	// * `storage_stores.#.cluster_name` - Human-readable label of the MongoDB Cloud cluster on which the store is based.
	// * `storage_stores.#.cluster_id` - ID of the Cluster the Online Archive belongs to.
	// * `storage_stores.#.allow_insecure` - Flag that validates the scheme in the specified URLs.
	// * `storage_stores.#.public` - Flag that indicates whether the bucket is public.
	// * `storage_stores.#.default_format` - Default format that Data Lake assumes if it encounters a file without an extension while searching the storeName.
	// * `storage_stores.#.urls` - Comma-separated list of publicly accessible HTTP URLs where data is stored.
	// * `storage_stores.#.read_preference` - MongoDB Cloud cluster read preference, which describes how to route read requests to the cluster.
	// * `storage_stores.#.read_preference.maxStalenessSeconds` - Maximum replication lag, or staleness, for reads from secondaries.
	// * `storage_stores.#.read_preference.mode` - Read preference mode that specifies to which replica set member to route the read requests.
	// * `storage_stores.#.read_preference.tag_sets` - List that contains tag sets or tag specification documents.
	// * `storage_stores.#.read_preference.tags` - List of all tags within a tag set
	// * `storage_stores.#.read_preference.tags.name` - Human-readable label of the tag.
	// * `storage_stores.#.read_preference.tags.value` - Value of the tag.
	StorageStores []FederatedDatabaseInstanceStorageStore `pulumi:"storageStores"`
}

type FederatedDatabaseInstanceState struct {
	// Cloud provider linked to this data federated instance.
	// * `cloud_provider_config.aws` - (Required) AWS provider of the cloud service where the Federated Database Instance can access the S3 Bucket. Note this parameter is only required if using `cloudProviderConfig` since AWS is currently the only supported Cloud vendor on this feature at this time.
	// * `cloud_provider_config.aws.role_id` - (Required) Unique identifier of the role that the Federated Instance can use to access the data stores. If necessary, use the Atlas [UI](https://docs.atlas.mongodb.com/security/manage-iam-roles/) or [API](https://docs.atlas.mongodb.com/reference/api/cloud-provider-access-get-roles/) to retrieve the role ID. You must also specify the `testS3Bucket`.
	// * `cloud_provider_config.aws.test_s3_bucket` - (Required) Name of the S3 data bucket that the provided role ID is authorized to access. You must also specify the `roleId`.
	CloudProviderConfig FederatedDatabaseInstanceCloudProviderConfigPtrInput
	// The cloud provider region to which the Federated Instance routes client connections for data processing.
	// * `data_process_region.cloud_provider` - (Required) Name of the cloud service provider. Atlas Federated Database only supports AWS.
	// * `data_process_region.region` - (Required) Name of the region to which the Federanted Instnace routes client connections for data processing. See the [documention](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Data-Federation/operation/createFederatedDatabase) for the available region.
	DataProcessRegion FederatedDatabaseInstanceDataProcessRegionPtrInput
	// The list of hostnames assigned to the Federated Database Instance. Each string in the array is a hostname assigned to the Federated Database Instance.
	Hostnames pulumi.StringArrayInput
	// Name of the Atlas Federated Database Instance.
	Name pulumi.StringPtrInput
	// The unique ID for the project to create a Federated Database Instance.
	ProjectId pulumi.StringPtrInput
	// Current state of the Federated Database Instance:
	// * `ACTIVE` - The Federated Database Instance is active and verified. You can query the data stores associated with the Federated Database Instance.
	// * `DELETED` - The Federated Database Instance was deleted.
	State pulumi.StringPtrInput
	// Configuration details for mapping each data store to queryable databases and collections. For complete documentation on this object and its nested fields, see [databases](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#std-label-datalake-databases-reference). An empty object indicates that the Federated Database Instance has no mapping configuration for any data store.
	// * `storage_databases.#.name` - Name of the database to which the Federated Database Instance maps the data contained in the data store.
	// * `storage_databases.#.collections` -     Array of objects where each object represents a collection and data sources that map to a [stores](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#mongodb-datalakeconf-datalakeconf.stores) data store.
	// * `storage_databases.#.collections.#.name` - Name of the collection.
	// * `storage_databases.#.collections.#.data_sources` -     Array of objects where each object represents a stores data store to map with the collection.
	// * `storage_databases.#.collections.#.data_sources.#.store_name` -     Name of a data store to map to the `<collection>`. Must match the name of an object in the stores array.
	// * `storage_databases.#.collections.#.data_sources.#.dataset_name` -     Human-readable label that identifies the dataset that Atlas generates for an ingestion pipeline run or Online Archive.
	// * `storage_databases.#.collections.#.data_sources.#.default_format` - Default format that Federated Database assumes if it encounters a file without an extension while searching the storeName.
	// * `storage_databases.#.collections.#.data_sources.#.path` - File path that controls how MongoDB Cloud searches for and parses files in the storeName before mapping them to a collection. Specify / to capture all files and folders from the prefix path.
	// * `storage_databases.#.collections.#.data_sources.#.database` - Human-readable label that identifies the database, which contains the collection in the cluster.
	// * `storage_databases.#.collections.#.data_sources.#.allow_insecure` - Flag that validates the scheme in the specified URLs. If true, allows insecure HTTP scheme, doesn't verify the server's certificate chain and hostname, and accepts any certificate with any hostname presented by the server. If false, allows secure HTTPS scheme only.
	// * `storage_databases.#.collections.#.data_sources.#.database_regex` - Regex pattern to use for creating the wildcard database.
	// * `storage_databases.#.collections.#.data_sources.#.collection` - Human-readable label that identifies the collection in the database.
	// * `storage_databases.#.collections.#.data_sources.#.collection_regex` - Regex pattern to use for creating the wildcard (*) collection.
	// * `storage_databases.#.collections.#.data_sources.#.provenance_field_name` - Name for the field that includes the provenance of the documents in the results.
	// * `storage_databases.#.collections.#.data_sources.#.storeName` - Human-readable label that identifies the data store that MongoDB Cloud maps to the collection.
	// * `storage_databases.#.collections.#.data_sources.#.urls` - URLs of the publicly accessible data files. You can't specify URLs that require authentication.
	// * `storage_databases.#.views` -     Array of objects where each object represents an [aggregation pipeline](https://docs.mongodb.com/manual/core/aggregation-pipeline/#id1) on a collection. To learn more about views, see [Views](https://docs.mongodb.com/manual/core/views/).
	// * `storage_databases.#.views.#.name` - Name of the view.
	// * `storage_databases.#.views.#.source` -  Name of the source collection for the view.
	// * `storage_databases.#.views.#.pipeline`- Aggregation pipeline stage(s) to apply to the source collection.
	StorageDatabases FederatedDatabaseInstanceStorageDatabaseArrayInput
	// Each object in the array represents a data store. Federated Database uses the storage.databases configuration details to map data in each data store to queryable databases and collections. For complete documentation on this object and its nested fields, see [stores](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#std-label-datalake-stores-reference). An empty object indicates that the Federated Database Instance has no configured data stores.
	// * `storage_stores.#.name` - Name of the data store.
	// * `storage_stores.#.provider` - Defines where the data is stored.
	// * `storage_stores.#.region` - Name of the AWS region in which the S3 bucket is hosted.
	// * `storage_stores.#.bucket` - Name of the AWS S3 bucket.
	// * `storage_stores.#.prefix` - Prefix the Federated Database Instance applies when searching for files in the S3 bucket.
	// * `storage_stores.#.delimiter` - The delimiter that separates `storage_databases.#.collections.#.data_sources.#.path` segments in the data store.
	// * `storage_stores.#.include_tags` - Determines whether or not to use S3 tags on the files in the given path as additional partition attributes.
	// * `storage_stores.#.cluster_name` - Human-readable label of the MongoDB Cloud cluster on which the store is based.
	// * `storage_stores.#.cluster_id` - ID of the Cluster the Online Archive belongs to.
	// * `storage_stores.#.allow_insecure` - Flag that validates the scheme in the specified URLs.
	// * `storage_stores.#.public` - Flag that indicates whether the bucket is public.
	// * `storage_stores.#.default_format` - Default format that Data Lake assumes if it encounters a file without an extension while searching the storeName.
	// * `storage_stores.#.urls` - Comma-separated list of publicly accessible HTTP URLs where data is stored.
	// * `storage_stores.#.read_preference` - MongoDB Cloud cluster read preference, which describes how to route read requests to the cluster.
	// * `storage_stores.#.read_preference.maxStalenessSeconds` - Maximum replication lag, or staleness, for reads from secondaries.
	// * `storage_stores.#.read_preference.mode` - Read preference mode that specifies to which replica set member to route the read requests.
	// * `storage_stores.#.read_preference.tag_sets` - List that contains tag sets or tag specification documents.
	// * `storage_stores.#.read_preference.tags` - List of all tags within a tag set
	// * `storage_stores.#.read_preference.tags.name` - Human-readable label of the tag.
	// * `storage_stores.#.read_preference.tags.value` - Value of the tag.
	StorageStores FederatedDatabaseInstanceStorageStoreArrayInput
}

func (FederatedDatabaseInstanceState) ElementType() reflect.Type {
	return reflect.TypeOf((*federatedDatabaseInstanceState)(nil)).Elem()
}

type federatedDatabaseInstanceArgs struct {
	// Cloud provider linked to this data federated instance.
	// * `cloud_provider_config.aws` - (Required) AWS provider of the cloud service where the Federated Database Instance can access the S3 Bucket. Note this parameter is only required if using `cloudProviderConfig` since AWS is currently the only supported Cloud vendor on this feature at this time.
	// * `cloud_provider_config.aws.role_id` - (Required) Unique identifier of the role that the Federated Instance can use to access the data stores. If necessary, use the Atlas [UI](https://docs.atlas.mongodb.com/security/manage-iam-roles/) or [API](https://docs.atlas.mongodb.com/reference/api/cloud-provider-access-get-roles/) to retrieve the role ID. You must also specify the `testS3Bucket`.
	// * `cloud_provider_config.aws.test_s3_bucket` - (Required) Name of the S3 data bucket that the provided role ID is authorized to access. You must also specify the `roleId`.
	CloudProviderConfig *FederatedDatabaseInstanceCloudProviderConfig `pulumi:"cloudProviderConfig"`
	// The cloud provider region to which the Federated Instance routes client connections for data processing.
	// * `data_process_region.cloud_provider` - (Required) Name of the cloud service provider. Atlas Federated Database only supports AWS.
	// * `data_process_region.region` - (Required) Name of the region to which the Federanted Instnace routes client connections for data processing. See the [documention](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Data-Federation/operation/createFederatedDatabase) for the available region.
	DataProcessRegion *FederatedDatabaseInstanceDataProcessRegion `pulumi:"dataProcessRegion"`
	// Name of the Atlas Federated Database Instance.
	Name *string `pulumi:"name"`
	// The unique ID for the project to create a Federated Database Instance.
	ProjectId string `pulumi:"projectId"`
	// Configuration details for mapping each data store to queryable databases and collections. For complete documentation on this object and its nested fields, see [databases](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#std-label-datalake-databases-reference). An empty object indicates that the Federated Database Instance has no mapping configuration for any data store.
	// * `storage_databases.#.name` - Name of the database to which the Federated Database Instance maps the data contained in the data store.
	// * `storage_databases.#.collections` -     Array of objects where each object represents a collection and data sources that map to a [stores](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#mongodb-datalakeconf-datalakeconf.stores) data store.
	// * `storage_databases.#.collections.#.name` - Name of the collection.
	// * `storage_databases.#.collections.#.data_sources` -     Array of objects where each object represents a stores data store to map with the collection.
	// * `storage_databases.#.collections.#.data_sources.#.store_name` -     Name of a data store to map to the `<collection>`. Must match the name of an object in the stores array.
	// * `storage_databases.#.collections.#.data_sources.#.dataset_name` -     Human-readable label that identifies the dataset that Atlas generates for an ingestion pipeline run or Online Archive.
	// * `storage_databases.#.collections.#.data_sources.#.default_format` - Default format that Federated Database assumes if it encounters a file without an extension while searching the storeName.
	// * `storage_databases.#.collections.#.data_sources.#.path` - File path that controls how MongoDB Cloud searches for and parses files in the storeName before mapping them to a collection. Specify / to capture all files and folders from the prefix path.
	// * `storage_databases.#.collections.#.data_sources.#.database` - Human-readable label that identifies the database, which contains the collection in the cluster.
	// * `storage_databases.#.collections.#.data_sources.#.allow_insecure` - Flag that validates the scheme in the specified URLs. If true, allows insecure HTTP scheme, doesn't verify the server's certificate chain and hostname, and accepts any certificate with any hostname presented by the server. If false, allows secure HTTPS scheme only.
	// * `storage_databases.#.collections.#.data_sources.#.database_regex` - Regex pattern to use for creating the wildcard database.
	// * `storage_databases.#.collections.#.data_sources.#.collection` - Human-readable label that identifies the collection in the database.
	// * `storage_databases.#.collections.#.data_sources.#.collection_regex` - Regex pattern to use for creating the wildcard (*) collection.
	// * `storage_databases.#.collections.#.data_sources.#.provenance_field_name` - Name for the field that includes the provenance of the documents in the results.
	// * `storage_databases.#.collections.#.data_sources.#.storeName` - Human-readable label that identifies the data store that MongoDB Cloud maps to the collection.
	// * `storage_databases.#.collections.#.data_sources.#.urls` - URLs of the publicly accessible data files. You can't specify URLs that require authentication.
	// * `storage_databases.#.views` -     Array of objects where each object represents an [aggregation pipeline](https://docs.mongodb.com/manual/core/aggregation-pipeline/#id1) on a collection. To learn more about views, see [Views](https://docs.mongodb.com/manual/core/views/).
	// * `storage_databases.#.views.#.name` - Name of the view.
	// * `storage_databases.#.views.#.source` -  Name of the source collection for the view.
	// * `storage_databases.#.views.#.pipeline`- Aggregation pipeline stage(s) to apply to the source collection.
	StorageDatabases []FederatedDatabaseInstanceStorageDatabase `pulumi:"storageDatabases"`
	// Each object in the array represents a data store. Federated Database uses the storage.databases configuration details to map data in each data store to queryable databases and collections. For complete documentation on this object and its nested fields, see [stores](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#std-label-datalake-stores-reference). An empty object indicates that the Federated Database Instance has no configured data stores.
	// * `storage_stores.#.name` - Name of the data store.
	// * `storage_stores.#.provider` - Defines where the data is stored.
	// * `storage_stores.#.region` - Name of the AWS region in which the S3 bucket is hosted.
	// * `storage_stores.#.bucket` - Name of the AWS S3 bucket.
	// * `storage_stores.#.prefix` - Prefix the Federated Database Instance applies when searching for files in the S3 bucket.
	// * `storage_stores.#.delimiter` - The delimiter that separates `storage_databases.#.collections.#.data_sources.#.path` segments in the data store.
	// * `storage_stores.#.include_tags` - Determines whether or not to use S3 tags on the files in the given path as additional partition attributes.
	// * `storage_stores.#.cluster_name` - Human-readable label of the MongoDB Cloud cluster on which the store is based.
	// * `storage_stores.#.cluster_id` - ID of the Cluster the Online Archive belongs to.
	// * `storage_stores.#.allow_insecure` - Flag that validates the scheme in the specified URLs.
	// * `storage_stores.#.public` - Flag that indicates whether the bucket is public.
	// * `storage_stores.#.default_format` - Default format that Data Lake assumes if it encounters a file without an extension while searching the storeName.
	// * `storage_stores.#.urls` - Comma-separated list of publicly accessible HTTP URLs where data is stored.
	// * `storage_stores.#.read_preference` - MongoDB Cloud cluster read preference, which describes how to route read requests to the cluster.
	// * `storage_stores.#.read_preference.maxStalenessSeconds` - Maximum replication lag, or staleness, for reads from secondaries.
	// * `storage_stores.#.read_preference.mode` - Read preference mode that specifies to which replica set member to route the read requests.
	// * `storage_stores.#.read_preference.tag_sets` - List that contains tag sets or tag specification documents.
	// * `storage_stores.#.read_preference.tags` - List of all tags within a tag set
	// * `storage_stores.#.read_preference.tags.name` - Human-readable label of the tag.
	// * `storage_stores.#.read_preference.tags.value` - Value of the tag.
	StorageStores []FederatedDatabaseInstanceStorageStore `pulumi:"storageStores"`
}

// The set of arguments for constructing a FederatedDatabaseInstance resource.
type FederatedDatabaseInstanceArgs struct {
	// Cloud provider linked to this data federated instance.
	// * `cloud_provider_config.aws` - (Required) AWS provider of the cloud service where the Federated Database Instance can access the S3 Bucket. Note this parameter is only required if using `cloudProviderConfig` since AWS is currently the only supported Cloud vendor on this feature at this time.
	// * `cloud_provider_config.aws.role_id` - (Required) Unique identifier of the role that the Federated Instance can use to access the data stores. If necessary, use the Atlas [UI](https://docs.atlas.mongodb.com/security/manage-iam-roles/) or [API](https://docs.atlas.mongodb.com/reference/api/cloud-provider-access-get-roles/) to retrieve the role ID. You must also specify the `testS3Bucket`.
	// * `cloud_provider_config.aws.test_s3_bucket` - (Required) Name of the S3 data bucket that the provided role ID is authorized to access. You must also specify the `roleId`.
	CloudProviderConfig FederatedDatabaseInstanceCloudProviderConfigPtrInput
	// The cloud provider region to which the Federated Instance routes client connections for data processing.
	// * `data_process_region.cloud_provider` - (Required) Name of the cloud service provider. Atlas Federated Database only supports AWS.
	// * `data_process_region.region` - (Required) Name of the region to which the Federanted Instnace routes client connections for data processing. See the [documention](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Data-Federation/operation/createFederatedDatabase) for the available region.
	DataProcessRegion FederatedDatabaseInstanceDataProcessRegionPtrInput
	// Name of the Atlas Federated Database Instance.
	Name pulumi.StringPtrInput
	// The unique ID for the project to create a Federated Database Instance.
	ProjectId pulumi.StringInput
	// Configuration details for mapping each data store to queryable databases and collections. For complete documentation on this object and its nested fields, see [databases](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#std-label-datalake-databases-reference). An empty object indicates that the Federated Database Instance has no mapping configuration for any data store.
	// * `storage_databases.#.name` - Name of the database to which the Federated Database Instance maps the data contained in the data store.
	// * `storage_databases.#.collections` -     Array of objects where each object represents a collection and data sources that map to a [stores](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#mongodb-datalakeconf-datalakeconf.stores) data store.
	// * `storage_databases.#.collections.#.name` - Name of the collection.
	// * `storage_databases.#.collections.#.data_sources` -     Array of objects where each object represents a stores data store to map with the collection.
	// * `storage_databases.#.collections.#.data_sources.#.store_name` -     Name of a data store to map to the `<collection>`. Must match the name of an object in the stores array.
	// * `storage_databases.#.collections.#.data_sources.#.dataset_name` -     Human-readable label that identifies the dataset that Atlas generates for an ingestion pipeline run or Online Archive.
	// * `storage_databases.#.collections.#.data_sources.#.default_format` - Default format that Federated Database assumes if it encounters a file without an extension while searching the storeName.
	// * `storage_databases.#.collections.#.data_sources.#.path` - File path that controls how MongoDB Cloud searches for and parses files in the storeName before mapping them to a collection. Specify / to capture all files and folders from the prefix path.
	// * `storage_databases.#.collections.#.data_sources.#.database` - Human-readable label that identifies the database, which contains the collection in the cluster.
	// * `storage_databases.#.collections.#.data_sources.#.allow_insecure` - Flag that validates the scheme in the specified URLs. If true, allows insecure HTTP scheme, doesn't verify the server's certificate chain and hostname, and accepts any certificate with any hostname presented by the server. If false, allows secure HTTPS scheme only.
	// * `storage_databases.#.collections.#.data_sources.#.database_regex` - Regex pattern to use for creating the wildcard database.
	// * `storage_databases.#.collections.#.data_sources.#.collection` - Human-readable label that identifies the collection in the database.
	// * `storage_databases.#.collections.#.data_sources.#.collection_regex` - Regex pattern to use for creating the wildcard (*) collection.
	// * `storage_databases.#.collections.#.data_sources.#.provenance_field_name` - Name for the field that includes the provenance of the documents in the results.
	// * `storage_databases.#.collections.#.data_sources.#.storeName` - Human-readable label that identifies the data store that MongoDB Cloud maps to the collection.
	// * `storage_databases.#.collections.#.data_sources.#.urls` - URLs of the publicly accessible data files. You can't specify URLs that require authentication.
	// * `storage_databases.#.views` -     Array of objects where each object represents an [aggregation pipeline](https://docs.mongodb.com/manual/core/aggregation-pipeline/#id1) on a collection. To learn more about views, see [Views](https://docs.mongodb.com/manual/core/views/).
	// * `storage_databases.#.views.#.name` - Name of the view.
	// * `storage_databases.#.views.#.source` -  Name of the source collection for the view.
	// * `storage_databases.#.views.#.pipeline`- Aggregation pipeline stage(s) to apply to the source collection.
	StorageDatabases FederatedDatabaseInstanceStorageDatabaseArrayInput
	// Each object in the array represents a data store. Federated Database uses the storage.databases configuration details to map data in each data store to queryable databases and collections. For complete documentation on this object and its nested fields, see [stores](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#std-label-datalake-stores-reference). An empty object indicates that the Federated Database Instance has no configured data stores.
	// * `storage_stores.#.name` - Name of the data store.
	// * `storage_stores.#.provider` - Defines where the data is stored.
	// * `storage_stores.#.region` - Name of the AWS region in which the S3 bucket is hosted.
	// * `storage_stores.#.bucket` - Name of the AWS S3 bucket.
	// * `storage_stores.#.prefix` - Prefix the Federated Database Instance applies when searching for files in the S3 bucket.
	// * `storage_stores.#.delimiter` - The delimiter that separates `storage_databases.#.collections.#.data_sources.#.path` segments in the data store.
	// * `storage_stores.#.include_tags` - Determines whether or not to use S3 tags on the files in the given path as additional partition attributes.
	// * `storage_stores.#.cluster_name` - Human-readable label of the MongoDB Cloud cluster on which the store is based.
	// * `storage_stores.#.cluster_id` - ID of the Cluster the Online Archive belongs to.
	// * `storage_stores.#.allow_insecure` - Flag that validates the scheme in the specified URLs.
	// * `storage_stores.#.public` - Flag that indicates whether the bucket is public.
	// * `storage_stores.#.default_format` - Default format that Data Lake assumes if it encounters a file without an extension while searching the storeName.
	// * `storage_stores.#.urls` - Comma-separated list of publicly accessible HTTP URLs where data is stored.
	// * `storage_stores.#.read_preference` - MongoDB Cloud cluster read preference, which describes how to route read requests to the cluster.
	// * `storage_stores.#.read_preference.maxStalenessSeconds` - Maximum replication lag, or staleness, for reads from secondaries.
	// * `storage_stores.#.read_preference.mode` - Read preference mode that specifies to which replica set member to route the read requests.
	// * `storage_stores.#.read_preference.tag_sets` - List that contains tag sets or tag specification documents.
	// * `storage_stores.#.read_preference.tags` - List of all tags within a tag set
	// * `storage_stores.#.read_preference.tags.name` - Human-readable label of the tag.
	// * `storage_stores.#.read_preference.tags.value` - Value of the tag.
	StorageStores FederatedDatabaseInstanceStorageStoreArrayInput
}

func (FederatedDatabaseInstanceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*federatedDatabaseInstanceArgs)(nil)).Elem()
}

type FederatedDatabaseInstanceInput interface {
	pulumi.Input

	ToFederatedDatabaseInstanceOutput() FederatedDatabaseInstanceOutput
	ToFederatedDatabaseInstanceOutputWithContext(ctx context.Context) FederatedDatabaseInstanceOutput
}

func (*FederatedDatabaseInstance) ElementType() reflect.Type {
	return reflect.TypeOf((**FederatedDatabaseInstance)(nil)).Elem()
}

func (i *FederatedDatabaseInstance) ToFederatedDatabaseInstanceOutput() FederatedDatabaseInstanceOutput {
	return i.ToFederatedDatabaseInstanceOutputWithContext(context.Background())
}

func (i *FederatedDatabaseInstance) ToFederatedDatabaseInstanceOutputWithContext(ctx context.Context) FederatedDatabaseInstanceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FederatedDatabaseInstanceOutput)
}

// FederatedDatabaseInstanceArrayInput is an input type that accepts FederatedDatabaseInstanceArray and FederatedDatabaseInstanceArrayOutput values.
// You can construct a concrete instance of `FederatedDatabaseInstanceArrayInput` via:
//
//	FederatedDatabaseInstanceArray{ FederatedDatabaseInstanceArgs{...} }
type FederatedDatabaseInstanceArrayInput interface {
	pulumi.Input

	ToFederatedDatabaseInstanceArrayOutput() FederatedDatabaseInstanceArrayOutput
	ToFederatedDatabaseInstanceArrayOutputWithContext(context.Context) FederatedDatabaseInstanceArrayOutput
}

type FederatedDatabaseInstanceArray []FederatedDatabaseInstanceInput

func (FederatedDatabaseInstanceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*FederatedDatabaseInstance)(nil)).Elem()
}

func (i FederatedDatabaseInstanceArray) ToFederatedDatabaseInstanceArrayOutput() FederatedDatabaseInstanceArrayOutput {
	return i.ToFederatedDatabaseInstanceArrayOutputWithContext(context.Background())
}

func (i FederatedDatabaseInstanceArray) ToFederatedDatabaseInstanceArrayOutputWithContext(ctx context.Context) FederatedDatabaseInstanceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FederatedDatabaseInstanceArrayOutput)
}

// FederatedDatabaseInstanceMapInput is an input type that accepts FederatedDatabaseInstanceMap and FederatedDatabaseInstanceMapOutput values.
// You can construct a concrete instance of `FederatedDatabaseInstanceMapInput` via:
//
//	FederatedDatabaseInstanceMap{ "key": FederatedDatabaseInstanceArgs{...} }
type FederatedDatabaseInstanceMapInput interface {
	pulumi.Input

	ToFederatedDatabaseInstanceMapOutput() FederatedDatabaseInstanceMapOutput
	ToFederatedDatabaseInstanceMapOutputWithContext(context.Context) FederatedDatabaseInstanceMapOutput
}

type FederatedDatabaseInstanceMap map[string]FederatedDatabaseInstanceInput

func (FederatedDatabaseInstanceMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*FederatedDatabaseInstance)(nil)).Elem()
}

func (i FederatedDatabaseInstanceMap) ToFederatedDatabaseInstanceMapOutput() FederatedDatabaseInstanceMapOutput {
	return i.ToFederatedDatabaseInstanceMapOutputWithContext(context.Background())
}

func (i FederatedDatabaseInstanceMap) ToFederatedDatabaseInstanceMapOutputWithContext(ctx context.Context) FederatedDatabaseInstanceMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FederatedDatabaseInstanceMapOutput)
}

type FederatedDatabaseInstanceOutput struct{ *pulumi.OutputState }

func (FederatedDatabaseInstanceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FederatedDatabaseInstance)(nil)).Elem()
}

func (o FederatedDatabaseInstanceOutput) ToFederatedDatabaseInstanceOutput() FederatedDatabaseInstanceOutput {
	return o
}

func (o FederatedDatabaseInstanceOutput) ToFederatedDatabaseInstanceOutputWithContext(ctx context.Context) FederatedDatabaseInstanceOutput {
	return o
}

// Cloud provider linked to this data federated instance.
// * `cloud_provider_config.aws` - (Required) AWS provider of the cloud service where the Federated Database Instance can access the S3 Bucket. Note this parameter is only required if using `cloudProviderConfig` since AWS is currently the only supported Cloud vendor on this feature at this time.
// * `cloud_provider_config.aws.role_id` - (Required) Unique identifier of the role that the Federated Instance can use to access the data stores. If necessary, use the Atlas [UI](https://docs.atlas.mongodb.com/security/manage-iam-roles/) or [API](https://docs.atlas.mongodb.com/reference/api/cloud-provider-access-get-roles/) to retrieve the role ID. You must also specify the `testS3Bucket`.
// * `cloud_provider_config.aws.test_s3_bucket` - (Required) Name of the S3 data bucket that the provided role ID is authorized to access. You must also specify the `roleId`.
func (o FederatedDatabaseInstanceOutput) CloudProviderConfig() FederatedDatabaseInstanceCloudProviderConfigOutput {
	return o.ApplyT(func(v *FederatedDatabaseInstance) FederatedDatabaseInstanceCloudProviderConfigOutput {
		return v.CloudProviderConfig
	}).(FederatedDatabaseInstanceCloudProviderConfigOutput)
}

// The cloud provider region to which the Federated Instance routes client connections for data processing.
// * `data_process_region.cloud_provider` - (Required) Name of the cloud service provider. Atlas Federated Database only supports AWS.
// * `data_process_region.region` - (Required) Name of the region to which the Federanted Instnace routes client connections for data processing. See the [documention](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Data-Federation/operation/createFederatedDatabase) for the available region.
func (o FederatedDatabaseInstanceOutput) DataProcessRegion() FederatedDatabaseInstanceDataProcessRegionOutput {
	return o.ApplyT(func(v *FederatedDatabaseInstance) FederatedDatabaseInstanceDataProcessRegionOutput {
		return v.DataProcessRegion
	}).(FederatedDatabaseInstanceDataProcessRegionOutput)
}

// The list of hostnames assigned to the Federated Database Instance. Each string in the array is a hostname assigned to the Federated Database Instance.
func (o FederatedDatabaseInstanceOutput) Hostnames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FederatedDatabaseInstance) pulumi.StringArrayOutput { return v.Hostnames }).(pulumi.StringArrayOutput)
}

// Name of the Atlas Federated Database Instance.
func (o FederatedDatabaseInstanceOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *FederatedDatabaseInstance) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The unique ID for the project to create a Federated Database Instance.
func (o FederatedDatabaseInstanceOutput) ProjectId() pulumi.StringOutput {
	return o.ApplyT(func(v *FederatedDatabaseInstance) pulumi.StringOutput { return v.ProjectId }).(pulumi.StringOutput)
}

// Current state of the Federated Database Instance:
// * `ACTIVE` - The Federated Database Instance is active and verified. You can query the data stores associated with the Federated Database Instance.
// * `DELETED` - The Federated Database Instance was deleted.
func (o FederatedDatabaseInstanceOutput) State() pulumi.StringOutput {
	return o.ApplyT(func(v *FederatedDatabaseInstance) pulumi.StringOutput { return v.State }).(pulumi.StringOutput)
}

// Configuration details for mapping each data store to queryable databases and collections. For complete documentation on this object and its nested fields, see [databases](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#std-label-datalake-databases-reference). An empty object indicates that the Federated Database Instance has no mapping configuration for any data store.
// * `storage_databases.#.name` - Name of the database to which the Federated Database Instance maps the data contained in the data store.
// * `storage_databases.#.collections` -     Array of objects where each object represents a collection and data sources that map to a [stores](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#mongodb-datalakeconf-datalakeconf.stores) data store.
// * `storage_databases.#.collections.#.name` - Name of the collection.
// * `storage_databases.#.collections.#.data_sources` -     Array of objects where each object represents a stores data store to map with the collection.
// * `storage_databases.#.collections.#.data_sources.#.store_name` -     Name of a data store to map to the `<collection>`. Must match the name of an object in the stores array.
// * `storage_databases.#.collections.#.data_sources.#.dataset_name` -     Human-readable label that identifies the dataset that Atlas generates for an ingestion pipeline run or Online Archive.
// * `storage_databases.#.collections.#.data_sources.#.default_format` - Default format that Federated Database assumes if it encounters a file without an extension while searching the storeName.
// * `storage_databases.#.collections.#.data_sources.#.path` - File path that controls how MongoDB Cloud searches for and parses files in the storeName before mapping them to a collection. Specify / to capture all files and folders from the prefix path.
// * `storage_databases.#.collections.#.data_sources.#.database` - Human-readable label that identifies the database, which contains the collection in the cluster.
// * `storage_databases.#.collections.#.data_sources.#.allow_insecure` - Flag that validates the scheme in the specified URLs. If true, allows insecure HTTP scheme, doesn't verify the server's certificate chain and hostname, and accepts any certificate with any hostname presented by the server. If false, allows secure HTTPS scheme only.
// * `storage_databases.#.collections.#.data_sources.#.database_regex` - Regex pattern to use for creating the wildcard database.
// * `storage_databases.#.collections.#.data_sources.#.collection` - Human-readable label that identifies the collection in the database.
// * `storage_databases.#.collections.#.data_sources.#.collection_regex` - Regex pattern to use for creating the wildcard (*) collection.
// * `storage_databases.#.collections.#.data_sources.#.provenance_field_name` - Name for the field that includes the provenance of the documents in the results.
// * `storage_databases.#.collections.#.data_sources.#.storeName` - Human-readable label that identifies the data store that MongoDB Cloud maps to the collection.
// * `storage_databases.#.collections.#.data_sources.#.urls` - URLs of the publicly accessible data files. You can't specify URLs that require authentication.
// * `storage_databases.#.views` -     Array of objects where each object represents an [aggregation pipeline](https://docs.mongodb.com/manual/core/aggregation-pipeline/#id1) on a collection. To learn more about views, see [Views](https://docs.mongodb.com/manual/core/views/).
// * `storage_databases.#.views.#.name` - Name of the view.
// * `storage_databases.#.views.#.source` -  Name of the source collection for the view.
// * `storage_databases.#.views.#.pipeline`- Aggregation pipeline stage(s) to apply to the source collection.
func (o FederatedDatabaseInstanceOutput) StorageDatabases() FederatedDatabaseInstanceStorageDatabaseArrayOutput {
	return o.ApplyT(func(v *FederatedDatabaseInstance) FederatedDatabaseInstanceStorageDatabaseArrayOutput {
		return v.StorageDatabases
	}).(FederatedDatabaseInstanceStorageDatabaseArrayOutput)
}

// Each object in the array represents a data store. Federated Database uses the storage.databases configuration details to map data in each data store to queryable databases and collections. For complete documentation on this object and its nested fields, see [stores](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#std-label-datalake-stores-reference). An empty object indicates that the Federated Database Instance has no configured data stores.
// * `storage_stores.#.name` - Name of the data store.
// * `storage_stores.#.provider` - Defines where the data is stored.
// * `storage_stores.#.region` - Name of the AWS region in which the S3 bucket is hosted.
// * `storage_stores.#.bucket` - Name of the AWS S3 bucket.
// * `storage_stores.#.prefix` - Prefix the Federated Database Instance applies when searching for files in the S3 bucket.
// * `storage_stores.#.delimiter` - The delimiter that separates `storage_databases.#.collections.#.data_sources.#.path` segments in the data store.
// * `storage_stores.#.include_tags` - Determines whether or not to use S3 tags on the files in the given path as additional partition attributes.
// * `storage_stores.#.cluster_name` - Human-readable label of the MongoDB Cloud cluster on which the store is based.
// * `storage_stores.#.cluster_id` - ID of the Cluster the Online Archive belongs to.
// * `storage_stores.#.allow_insecure` - Flag that validates the scheme in the specified URLs.
// * `storage_stores.#.public` - Flag that indicates whether the bucket is public.
// * `storage_stores.#.default_format` - Default format that Data Lake assumes if it encounters a file without an extension while searching the storeName.
// * `storage_stores.#.urls` - Comma-separated list of publicly accessible HTTP URLs where data is stored.
// * `storage_stores.#.read_preference` - MongoDB Cloud cluster read preference, which describes how to route read requests to the cluster.
// * `storage_stores.#.read_preference.maxStalenessSeconds` - Maximum replication lag, or staleness, for reads from secondaries.
// * `storage_stores.#.read_preference.mode` - Read preference mode that specifies to which replica set member to route the read requests.
// * `storage_stores.#.read_preference.tag_sets` - List that contains tag sets or tag specification documents.
// * `storage_stores.#.read_preference.tags` - List of all tags within a tag set
// * `storage_stores.#.read_preference.tags.name` - Human-readable label of the tag.
// * `storage_stores.#.read_preference.tags.value` - Value of the tag.
func (o FederatedDatabaseInstanceOutput) StorageStores() FederatedDatabaseInstanceStorageStoreArrayOutput {
	return o.ApplyT(func(v *FederatedDatabaseInstance) FederatedDatabaseInstanceStorageStoreArrayOutput {
		return v.StorageStores
	}).(FederatedDatabaseInstanceStorageStoreArrayOutput)
}

type FederatedDatabaseInstanceArrayOutput struct{ *pulumi.OutputState }

func (FederatedDatabaseInstanceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*FederatedDatabaseInstance)(nil)).Elem()
}

func (o FederatedDatabaseInstanceArrayOutput) ToFederatedDatabaseInstanceArrayOutput() FederatedDatabaseInstanceArrayOutput {
	return o
}

func (o FederatedDatabaseInstanceArrayOutput) ToFederatedDatabaseInstanceArrayOutputWithContext(ctx context.Context) FederatedDatabaseInstanceArrayOutput {
	return o
}

func (o FederatedDatabaseInstanceArrayOutput) Index(i pulumi.IntInput) FederatedDatabaseInstanceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *FederatedDatabaseInstance {
		return vs[0].([]*FederatedDatabaseInstance)[vs[1].(int)]
	}).(FederatedDatabaseInstanceOutput)
}

type FederatedDatabaseInstanceMapOutput struct{ *pulumi.OutputState }

func (FederatedDatabaseInstanceMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*FederatedDatabaseInstance)(nil)).Elem()
}

func (o FederatedDatabaseInstanceMapOutput) ToFederatedDatabaseInstanceMapOutput() FederatedDatabaseInstanceMapOutput {
	return o
}

func (o FederatedDatabaseInstanceMapOutput) ToFederatedDatabaseInstanceMapOutputWithContext(ctx context.Context) FederatedDatabaseInstanceMapOutput {
	return o
}

func (o FederatedDatabaseInstanceMapOutput) MapIndex(k pulumi.StringInput) FederatedDatabaseInstanceOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *FederatedDatabaseInstance {
		return vs[0].(map[string]*FederatedDatabaseInstance)[vs[1].(string)]
	}).(FederatedDatabaseInstanceOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*FederatedDatabaseInstanceInput)(nil)).Elem(), &FederatedDatabaseInstance{})
	pulumi.RegisterInputType(reflect.TypeOf((*FederatedDatabaseInstanceArrayInput)(nil)).Elem(), FederatedDatabaseInstanceArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*FederatedDatabaseInstanceMapInput)(nil)).Elem(), FederatedDatabaseInstanceMap{})
	pulumi.RegisterOutputType(FederatedDatabaseInstanceOutput{})
	pulumi.RegisterOutputType(FederatedDatabaseInstanceArrayOutput{})
	pulumi.RegisterOutputType(FederatedDatabaseInstanceMapOutput{})
}
