// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package mongodbatlas

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// `Teams` provides a Team resource. The resource lets you create, edit and delete Teams. Also, Teams can be assigned to multiple projects, and team members’ access to the project is determined by the team’s project role.
//
// > **IMPORTANT:** MongoDB Atlas Team limits: max 250 teams in an organization and max 100 teams per project.
//
// > **NOTE:** Groups and projects are synonymous terms. You may find groupId in the official documentation.
//
// MongoDB Atlas Team limits: max 250 teams in an organization and max 100 teams per project.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		_, err := mongodbatlas.NewTeams(ctx, "test", &mongodbatlas.TeamsArgs{
// 			OrgId: pulumi.String("<ORGANIZATION-ID>"),
// 			Usernames: pulumi.StringArray{
// 				pulumi.String("user1@email.com"),
// 				pulumi.String("user2@email.com"),
// 				pulumi.String("user3@email.com"),
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
//
// ## Import
//
// Teams can be imported using the organization ID and team id, in the format ORGID-TEAMID, e.g.
//
// ```sh
//  $ pulumi import mongodbatlas:index/teams:Teams my_team 1112222b3bf99403840e8934-1112222b3bf99403840e8935
// ```
//
//  See detailed information for arguments and attributes[MongoDB API Teams](https://docs.atlas.mongodb.com/reference/api/teams-create-one/)
type Teams struct {
	pulumi.CustomResourceState

	// The name of the team you want to create.
	Name pulumi.StringOutput `pulumi:"name"`
	// The unique identifier for the organization you want to associate the team with.
	OrgId pulumi.StringOutput `pulumi:"orgId"`
	// The unique identifier for the team.
	TeamId pulumi.StringOutput `pulumi:"teamId"`
	// The Atlas usernames (email address). You can only add Atlas users who are part of the organization. Users who have not accepted an invitation to join the organization cannot be added as team members. There is a maximum of 250 Atlas users per team.
	Usernames pulumi.StringArrayOutput `pulumi:"usernames"`
}

// NewTeams registers a new resource with the given unique name, arguments, and options.
func NewTeams(ctx *pulumi.Context,
	name string, args *TeamsArgs, opts ...pulumi.ResourceOption) (*Teams, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.OrgId == nil {
		return nil, errors.New("invalid value for required argument 'OrgId'")
	}
	if args.Usernames == nil {
		return nil, errors.New("invalid value for required argument 'Usernames'")
	}
	var resource Teams
	err := ctx.RegisterResource("mongodbatlas:index/teams:Teams", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetTeams gets an existing Teams resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetTeams(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *TeamsState, opts ...pulumi.ResourceOption) (*Teams, error) {
	var resource Teams
	err := ctx.ReadResource("mongodbatlas:index/teams:Teams", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Teams resources.
type teamsState struct {
	// The name of the team you want to create.
	Name *string `pulumi:"name"`
	// The unique identifier for the organization you want to associate the team with.
	OrgId *string `pulumi:"orgId"`
	// The unique identifier for the team.
	TeamId *string `pulumi:"teamId"`
	// The Atlas usernames (email address). You can only add Atlas users who are part of the organization. Users who have not accepted an invitation to join the organization cannot be added as team members. There is a maximum of 250 Atlas users per team.
	Usernames []string `pulumi:"usernames"`
}

type TeamsState struct {
	// The name of the team you want to create.
	Name pulumi.StringPtrInput
	// The unique identifier for the organization you want to associate the team with.
	OrgId pulumi.StringPtrInput
	// The unique identifier for the team.
	TeamId pulumi.StringPtrInput
	// The Atlas usernames (email address). You can only add Atlas users who are part of the organization. Users who have not accepted an invitation to join the organization cannot be added as team members. There is a maximum of 250 Atlas users per team.
	Usernames pulumi.StringArrayInput
}

func (TeamsState) ElementType() reflect.Type {
	return reflect.TypeOf((*teamsState)(nil)).Elem()
}

type teamsArgs struct {
	// The name of the team you want to create.
	Name *string `pulumi:"name"`
	// The unique identifier for the organization you want to associate the team with.
	OrgId string `pulumi:"orgId"`
	// The Atlas usernames (email address). You can only add Atlas users who are part of the organization. Users who have not accepted an invitation to join the organization cannot be added as team members. There is a maximum of 250 Atlas users per team.
	Usernames []string `pulumi:"usernames"`
}

// The set of arguments for constructing a Teams resource.
type TeamsArgs struct {
	// The name of the team you want to create.
	Name pulumi.StringPtrInput
	// The unique identifier for the organization you want to associate the team with.
	OrgId pulumi.StringInput
	// The Atlas usernames (email address). You can only add Atlas users who are part of the organization. Users who have not accepted an invitation to join the organization cannot be added as team members. There is a maximum of 250 Atlas users per team.
	Usernames pulumi.StringArrayInput
}

func (TeamsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*teamsArgs)(nil)).Elem()
}

type TeamsInput interface {
	pulumi.Input

	ToTeamsOutput() TeamsOutput
	ToTeamsOutputWithContext(ctx context.Context) TeamsOutput
}

func (*Teams) ElementType() reflect.Type {
	return reflect.TypeOf((**Teams)(nil)).Elem()
}

func (i *Teams) ToTeamsOutput() TeamsOutput {
	return i.ToTeamsOutputWithContext(context.Background())
}

func (i *Teams) ToTeamsOutputWithContext(ctx context.Context) TeamsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TeamsOutput)
}

// TeamsArrayInput is an input type that accepts TeamsArray and TeamsArrayOutput values.
// You can construct a concrete instance of `TeamsArrayInput` via:
//
//          TeamsArray{ TeamsArgs{...} }
type TeamsArrayInput interface {
	pulumi.Input

	ToTeamsArrayOutput() TeamsArrayOutput
	ToTeamsArrayOutputWithContext(context.Context) TeamsArrayOutput
}

type TeamsArray []TeamsInput

func (TeamsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Teams)(nil)).Elem()
}

func (i TeamsArray) ToTeamsArrayOutput() TeamsArrayOutput {
	return i.ToTeamsArrayOutputWithContext(context.Background())
}

func (i TeamsArray) ToTeamsArrayOutputWithContext(ctx context.Context) TeamsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TeamsArrayOutput)
}

// TeamsMapInput is an input type that accepts TeamsMap and TeamsMapOutput values.
// You can construct a concrete instance of `TeamsMapInput` via:
//
//          TeamsMap{ "key": TeamsArgs{...} }
type TeamsMapInput interface {
	pulumi.Input

	ToTeamsMapOutput() TeamsMapOutput
	ToTeamsMapOutputWithContext(context.Context) TeamsMapOutput
}

type TeamsMap map[string]TeamsInput

func (TeamsMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Teams)(nil)).Elem()
}

func (i TeamsMap) ToTeamsMapOutput() TeamsMapOutput {
	return i.ToTeamsMapOutputWithContext(context.Background())
}

func (i TeamsMap) ToTeamsMapOutputWithContext(ctx context.Context) TeamsMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TeamsMapOutput)
}

type TeamsOutput struct{ *pulumi.OutputState }

func (TeamsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Teams)(nil)).Elem()
}

func (o TeamsOutput) ToTeamsOutput() TeamsOutput {
	return o
}

func (o TeamsOutput) ToTeamsOutputWithContext(ctx context.Context) TeamsOutput {
	return o
}

type TeamsArrayOutput struct{ *pulumi.OutputState }

func (TeamsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Teams)(nil)).Elem()
}

func (o TeamsArrayOutput) ToTeamsArrayOutput() TeamsArrayOutput {
	return o
}

func (o TeamsArrayOutput) ToTeamsArrayOutputWithContext(ctx context.Context) TeamsArrayOutput {
	return o
}

func (o TeamsArrayOutput) Index(i pulumi.IntInput) TeamsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Teams {
		return vs[0].([]*Teams)[vs[1].(int)]
	}).(TeamsOutput)
}

type TeamsMapOutput struct{ *pulumi.OutputState }

func (TeamsMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Teams)(nil)).Elem()
}

func (o TeamsMapOutput) ToTeamsMapOutput() TeamsMapOutput {
	return o
}

func (o TeamsMapOutput) ToTeamsMapOutputWithContext(ctx context.Context) TeamsMapOutput {
	return o
}

func (o TeamsMapOutput) MapIndex(k pulumi.StringInput) TeamsOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Teams {
		return vs[0].(map[string]*Teams)[vs[1].(string)]
	}).(TeamsOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*TeamsInput)(nil)).Elem(), &Teams{})
	pulumi.RegisterInputType(reflect.TypeOf((*TeamsArrayInput)(nil)).Elem(), TeamsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TeamsMapInput)(nil)).Elem(), TeamsMap{})
	pulumi.RegisterOutputType(TeamsOutput{})
	pulumi.RegisterOutputType(TeamsArrayOutput{})
	pulumi.RegisterOutputType(TeamsMapOutput{})
}
