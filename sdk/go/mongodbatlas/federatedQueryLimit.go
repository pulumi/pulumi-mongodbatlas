// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package mongodbatlas

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// `FederatedQueryLimit` provides a Federated Database Instance Query Limits resource. To learn more about Atlas Data Federation see https://www.mongodb.com/docs/atlas/data-federation/overview/.
//
// > **NOTE:** Groups and projects are synonymous terms. You may find groupId in the official documentation.
//
// ## Example Usage
// ### S
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := mongodbatlas.NewFederatedQueryLimit(ctx, "test", &mongodbatlas.FederatedQueryLimitArgs{
//				LimitName:     pulumi.String("bytesProcessed.weekly"),
//				OverrunPolicy: pulumi.String("BLOCK"),
//				ProjectId:     pulumi.String("64707f06c519c20c3a2b1b03"),
//				TenantName:    pulumi.String("FederatedDatabseInstance0"),
//				Value:         pulumi.Int(5147483648),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// The Federated Database Instance Query Limit can be imported using project ID, name of the instance and limit name, in the format: `project_id`--`tenant_name`--`limit_name`, e.g.
//
// ```sh
//
//	$ pulumi import mongodbatlas:index/federatedQueryLimit:FederatedQueryLimit example 1112222b3bf99403840e8934--FederatedDatabaseInstance0--bytesProcessed.daily
//
// ```
//
//	See [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Data-Federation/operation/createOneDataFederationQueryLimit) Documentation for more information.
type FederatedQueryLimit struct {
	pulumi.CustomResourceState

	// Amount that indicates the current usage of the limit.
	CurrentUsage pulumi.IntOutput `pulumi:"currentUsage"`
	// Default value of the limit.
	DefaultLimit     pulumi.IntPtrOutput `pulumi:"defaultLimit"`
	LastModifiedDate pulumi.StringOutput `pulumi:"lastModifiedDate"`
	// String enum that indicates whether the identity provider is active or not. Accepted values are:
	// * `bytesProcessed.query`: Limit on the number of bytes processed during a single data federation query.
	// * `bytesProcessed.daily`: Limit on the number of bytes processed for the data federation instance for the current day.
	// * `bytesProcessed.weekly`: Limit on the number of bytes processed for the data federation instance for the current week.
	// * `bytesProcessed.monthly`: Limit on the number of bytes processed for the data federation instance for the current month.
	LimitName    pulumi.StringOutput `pulumi:"limitName"`
	MaximumLimit pulumi.IntPtrOutput `pulumi:"maximumLimit"`
	// String enum that identifies action to take when the usage limit is exceeded. If limit span is set to QUERY, this is ignored because MongoDB Cloud stops the query when it exceeds the usage limit. Accepted values are "BLOCK" OR "BLOCK_AND_KILL"
	OverrunPolicy pulumi.StringOutput `pulumi:"overrunPolicy"`
	// The unique ID for the project to create a Federated Database Instance.
	ProjectId pulumi.StringOutput `pulumi:"projectId"`
	// Name of the Atlas Federated Database Instance.
	TenantName pulumi.StringOutput `pulumi:"tenantName"`
	// Amount to set the limit to.
	Value pulumi.IntOutput `pulumi:"value"`
}

// NewFederatedQueryLimit registers a new resource with the given unique name, arguments, and options.
func NewFederatedQueryLimit(ctx *pulumi.Context,
	name string, args *FederatedQueryLimitArgs, opts ...pulumi.ResourceOption) (*FederatedQueryLimit, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.LimitName == nil {
		return nil, errors.New("invalid value for required argument 'LimitName'")
	}
	if args.OverrunPolicy == nil {
		return nil, errors.New("invalid value for required argument 'OverrunPolicy'")
	}
	if args.ProjectId == nil {
		return nil, errors.New("invalid value for required argument 'ProjectId'")
	}
	if args.TenantName == nil {
		return nil, errors.New("invalid value for required argument 'TenantName'")
	}
	if args.Value == nil {
		return nil, errors.New("invalid value for required argument 'Value'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource FederatedQueryLimit
	err := ctx.RegisterResource("mongodbatlas:index/federatedQueryLimit:FederatedQueryLimit", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetFederatedQueryLimit gets an existing FederatedQueryLimit resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetFederatedQueryLimit(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *FederatedQueryLimitState, opts ...pulumi.ResourceOption) (*FederatedQueryLimit, error) {
	var resource FederatedQueryLimit
	err := ctx.ReadResource("mongodbatlas:index/federatedQueryLimit:FederatedQueryLimit", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering FederatedQueryLimit resources.
type federatedQueryLimitState struct {
	// Amount that indicates the current usage of the limit.
	CurrentUsage *int `pulumi:"currentUsage"`
	// Default value of the limit.
	DefaultLimit     *int    `pulumi:"defaultLimit"`
	LastModifiedDate *string `pulumi:"lastModifiedDate"`
	// String enum that indicates whether the identity provider is active or not. Accepted values are:
	// * `bytesProcessed.query`: Limit on the number of bytes processed during a single data federation query.
	// * `bytesProcessed.daily`: Limit on the number of bytes processed for the data federation instance for the current day.
	// * `bytesProcessed.weekly`: Limit on the number of bytes processed for the data federation instance for the current week.
	// * `bytesProcessed.monthly`: Limit on the number of bytes processed for the data federation instance for the current month.
	LimitName    *string `pulumi:"limitName"`
	MaximumLimit *int    `pulumi:"maximumLimit"`
	// String enum that identifies action to take when the usage limit is exceeded. If limit span is set to QUERY, this is ignored because MongoDB Cloud stops the query when it exceeds the usage limit. Accepted values are "BLOCK" OR "BLOCK_AND_KILL"
	OverrunPolicy *string `pulumi:"overrunPolicy"`
	// The unique ID for the project to create a Federated Database Instance.
	ProjectId *string `pulumi:"projectId"`
	// Name of the Atlas Federated Database Instance.
	TenantName *string `pulumi:"tenantName"`
	// Amount to set the limit to.
	Value *int `pulumi:"value"`
}

type FederatedQueryLimitState struct {
	// Amount that indicates the current usage of the limit.
	CurrentUsage pulumi.IntPtrInput
	// Default value of the limit.
	DefaultLimit     pulumi.IntPtrInput
	LastModifiedDate pulumi.StringPtrInput
	// String enum that indicates whether the identity provider is active or not. Accepted values are:
	// * `bytesProcessed.query`: Limit on the number of bytes processed during a single data federation query.
	// * `bytesProcessed.daily`: Limit on the number of bytes processed for the data federation instance for the current day.
	// * `bytesProcessed.weekly`: Limit on the number of bytes processed for the data federation instance for the current week.
	// * `bytesProcessed.monthly`: Limit on the number of bytes processed for the data federation instance for the current month.
	LimitName    pulumi.StringPtrInput
	MaximumLimit pulumi.IntPtrInput
	// String enum that identifies action to take when the usage limit is exceeded. If limit span is set to QUERY, this is ignored because MongoDB Cloud stops the query when it exceeds the usage limit. Accepted values are "BLOCK" OR "BLOCK_AND_KILL"
	OverrunPolicy pulumi.StringPtrInput
	// The unique ID for the project to create a Federated Database Instance.
	ProjectId pulumi.StringPtrInput
	// Name of the Atlas Federated Database Instance.
	TenantName pulumi.StringPtrInput
	// Amount to set the limit to.
	Value pulumi.IntPtrInput
}

func (FederatedQueryLimitState) ElementType() reflect.Type {
	return reflect.TypeOf((*federatedQueryLimitState)(nil)).Elem()
}

type federatedQueryLimitArgs struct {
	// Default value of the limit.
	DefaultLimit *int `pulumi:"defaultLimit"`
	// String enum that indicates whether the identity provider is active or not. Accepted values are:
	// * `bytesProcessed.query`: Limit on the number of bytes processed during a single data federation query.
	// * `bytesProcessed.daily`: Limit on the number of bytes processed for the data federation instance for the current day.
	// * `bytesProcessed.weekly`: Limit on the number of bytes processed for the data federation instance for the current week.
	// * `bytesProcessed.monthly`: Limit on the number of bytes processed for the data federation instance for the current month.
	LimitName    string `pulumi:"limitName"`
	MaximumLimit *int   `pulumi:"maximumLimit"`
	// String enum that identifies action to take when the usage limit is exceeded. If limit span is set to QUERY, this is ignored because MongoDB Cloud stops the query when it exceeds the usage limit. Accepted values are "BLOCK" OR "BLOCK_AND_KILL"
	OverrunPolicy string `pulumi:"overrunPolicy"`
	// The unique ID for the project to create a Federated Database Instance.
	ProjectId string `pulumi:"projectId"`
	// Name of the Atlas Federated Database Instance.
	TenantName string `pulumi:"tenantName"`
	// Amount to set the limit to.
	Value int `pulumi:"value"`
}

// The set of arguments for constructing a FederatedQueryLimit resource.
type FederatedQueryLimitArgs struct {
	// Default value of the limit.
	DefaultLimit pulumi.IntPtrInput
	// String enum that indicates whether the identity provider is active or not. Accepted values are:
	// * `bytesProcessed.query`: Limit on the number of bytes processed during a single data federation query.
	// * `bytesProcessed.daily`: Limit on the number of bytes processed for the data federation instance for the current day.
	// * `bytesProcessed.weekly`: Limit on the number of bytes processed for the data federation instance for the current week.
	// * `bytesProcessed.monthly`: Limit on the number of bytes processed for the data federation instance for the current month.
	LimitName    pulumi.StringInput
	MaximumLimit pulumi.IntPtrInput
	// String enum that identifies action to take when the usage limit is exceeded. If limit span is set to QUERY, this is ignored because MongoDB Cloud stops the query when it exceeds the usage limit. Accepted values are "BLOCK" OR "BLOCK_AND_KILL"
	OverrunPolicy pulumi.StringInput
	// The unique ID for the project to create a Federated Database Instance.
	ProjectId pulumi.StringInput
	// Name of the Atlas Federated Database Instance.
	TenantName pulumi.StringInput
	// Amount to set the limit to.
	Value pulumi.IntInput
}

func (FederatedQueryLimitArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*federatedQueryLimitArgs)(nil)).Elem()
}

type FederatedQueryLimitInput interface {
	pulumi.Input

	ToFederatedQueryLimitOutput() FederatedQueryLimitOutput
	ToFederatedQueryLimitOutputWithContext(ctx context.Context) FederatedQueryLimitOutput
}

func (*FederatedQueryLimit) ElementType() reflect.Type {
	return reflect.TypeOf((**FederatedQueryLimit)(nil)).Elem()
}

func (i *FederatedQueryLimit) ToFederatedQueryLimitOutput() FederatedQueryLimitOutput {
	return i.ToFederatedQueryLimitOutputWithContext(context.Background())
}

func (i *FederatedQueryLimit) ToFederatedQueryLimitOutputWithContext(ctx context.Context) FederatedQueryLimitOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FederatedQueryLimitOutput)
}

// FederatedQueryLimitArrayInput is an input type that accepts FederatedQueryLimitArray and FederatedQueryLimitArrayOutput values.
// You can construct a concrete instance of `FederatedQueryLimitArrayInput` via:
//
//	FederatedQueryLimitArray{ FederatedQueryLimitArgs{...} }
type FederatedQueryLimitArrayInput interface {
	pulumi.Input

	ToFederatedQueryLimitArrayOutput() FederatedQueryLimitArrayOutput
	ToFederatedQueryLimitArrayOutputWithContext(context.Context) FederatedQueryLimitArrayOutput
}

type FederatedQueryLimitArray []FederatedQueryLimitInput

func (FederatedQueryLimitArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*FederatedQueryLimit)(nil)).Elem()
}

func (i FederatedQueryLimitArray) ToFederatedQueryLimitArrayOutput() FederatedQueryLimitArrayOutput {
	return i.ToFederatedQueryLimitArrayOutputWithContext(context.Background())
}

func (i FederatedQueryLimitArray) ToFederatedQueryLimitArrayOutputWithContext(ctx context.Context) FederatedQueryLimitArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FederatedQueryLimitArrayOutput)
}

// FederatedQueryLimitMapInput is an input type that accepts FederatedQueryLimitMap and FederatedQueryLimitMapOutput values.
// You can construct a concrete instance of `FederatedQueryLimitMapInput` via:
//
//	FederatedQueryLimitMap{ "key": FederatedQueryLimitArgs{...} }
type FederatedQueryLimitMapInput interface {
	pulumi.Input

	ToFederatedQueryLimitMapOutput() FederatedQueryLimitMapOutput
	ToFederatedQueryLimitMapOutputWithContext(context.Context) FederatedQueryLimitMapOutput
}

type FederatedQueryLimitMap map[string]FederatedQueryLimitInput

func (FederatedQueryLimitMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*FederatedQueryLimit)(nil)).Elem()
}

func (i FederatedQueryLimitMap) ToFederatedQueryLimitMapOutput() FederatedQueryLimitMapOutput {
	return i.ToFederatedQueryLimitMapOutputWithContext(context.Background())
}

func (i FederatedQueryLimitMap) ToFederatedQueryLimitMapOutputWithContext(ctx context.Context) FederatedQueryLimitMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FederatedQueryLimitMapOutput)
}

type FederatedQueryLimitOutput struct{ *pulumi.OutputState }

func (FederatedQueryLimitOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FederatedQueryLimit)(nil)).Elem()
}

func (o FederatedQueryLimitOutput) ToFederatedQueryLimitOutput() FederatedQueryLimitOutput {
	return o
}

func (o FederatedQueryLimitOutput) ToFederatedQueryLimitOutputWithContext(ctx context.Context) FederatedQueryLimitOutput {
	return o
}

// Amount that indicates the current usage of the limit.
func (o FederatedQueryLimitOutput) CurrentUsage() pulumi.IntOutput {
	return o.ApplyT(func(v *FederatedQueryLimit) pulumi.IntOutput { return v.CurrentUsage }).(pulumi.IntOutput)
}

// Default value of the limit.
func (o FederatedQueryLimitOutput) DefaultLimit() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *FederatedQueryLimit) pulumi.IntPtrOutput { return v.DefaultLimit }).(pulumi.IntPtrOutput)
}

func (o FederatedQueryLimitOutput) LastModifiedDate() pulumi.StringOutput {
	return o.ApplyT(func(v *FederatedQueryLimit) pulumi.StringOutput { return v.LastModifiedDate }).(pulumi.StringOutput)
}

// String enum that indicates whether the identity provider is active or not. Accepted values are:
// * `bytesProcessed.query`: Limit on the number of bytes processed during a single data federation query.
// * `bytesProcessed.daily`: Limit on the number of bytes processed for the data federation instance for the current day.
// * `bytesProcessed.weekly`: Limit on the number of bytes processed for the data federation instance for the current week.
// * `bytesProcessed.monthly`: Limit on the number of bytes processed for the data federation instance for the current month.
func (o FederatedQueryLimitOutput) LimitName() pulumi.StringOutput {
	return o.ApplyT(func(v *FederatedQueryLimit) pulumi.StringOutput { return v.LimitName }).(pulumi.StringOutput)
}

func (o FederatedQueryLimitOutput) MaximumLimit() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *FederatedQueryLimit) pulumi.IntPtrOutput { return v.MaximumLimit }).(pulumi.IntPtrOutput)
}

// String enum that identifies action to take when the usage limit is exceeded. If limit span is set to QUERY, this is ignored because MongoDB Cloud stops the query when it exceeds the usage limit. Accepted values are "BLOCK" OR "BLOCK_AND_KILL"
func (o FederatedQueryLimitOutput) OverrunPolicy() pulumi.StringOutput {
	return o.ApplyT(func(v *FederatedQueryLimit) pulumi.StringOutput { return v.OverrunPolicy }).(pulumi.StringOutput)
}

// The unique ID for the project to create a Federated Database Instance.
func (o FederatedQueryLimitOutput) ProjectId() pulumi.StringOutput {
	return o.ApplyT(func(v *FederatedQueryLimit) pulumi.StringOutput { return v.ProjectId }).(pulumi.StringOutput)
}

// Name of the Atlas Federated Database Instance.
func (o FederatedQueryLimitOutput) TenantName() pulumi.StringOutput {
	return o.ApplyT(func(v *FederatedQueryLimit) pulumi.StringOutput { return v.TenantName }).(pulumi.StringOutput)
}

// Amount to set the limit to.
func (o FederatedQueryLimitOutput) Value() pulumi.IntOutput {
	return o.ApplyT(func(v *FederatedQueryLimit) pulumi.IntOutput { return v.Value }).(pulumi.IntOutput)
}

type FederatedQueryLimitArrayOutput struct{ *pulumi.OutputState }

func (FederatedQueryLimitArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*FederatedQueryLimit)(nil)).Elem()
}

func (o FederatedQueryLimitArrayOutput) ToFederatedQueryLimitArrayOutput() FederatedQueryLimitArrayOutput {
	return o
}

func (o FederatedQueryLimitArrayOutput) ToFederatedQueryLimitArrayOutputWithContext(ctx context.Context) FederatedQueryLimitArrayOutput {
	return o
}

func (o FederatedQueryLimitArrayOutput) Index(i pulumi.IntInput) FederatedQueryLimitOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *FederatedQueryLimit {
		return vs[0].([]*FederatedQueryLimit)[vs[1].(int)]
	}).(FederatedQueryLimitOutput)
}

type FederatedQueryLimitMapOutput struct{ *pulumi.OutputState }

func (FederatedQueryLimitMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*FederatedQueryLimit)(nil)).Elem()
}

func (o FederatedQueryLimitMapOutput) ToFederatedQueryLimitMapOutput() FederatedQueryLimitMapOutput {
	return o
}

func (o FederatedQueryLimitMapOutput) ToFederatedQueryLimitMapOutputWithContext(ctx context.Context) FederatedQueryLimitMapOutput {
	return o
}

func (o FederatedQueryLimitMapOutput) MapIndex(k pulumi.StringInput) FederatedQueryLimitOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *FederatedQueryLimit {
		return vs[0].(map[string]*FederatedQueryLimit)[vs[1].(string)]
	}).(FederatedQueryLimitOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*FederatedQueryLimitInput)(nil)).Elem(), &FederatedQueryLimit{})
	pulumi.RegisterInputType(reflect.TypeOf((*FederatedQueryLimitArrayInput)(nil)).Elem(), FederatedQueryLimitArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*FederatedQueryLimitMapInput)(nil)).Elem(), FederatedQueryLimitMap{})
	pulumi.RegisterOutputType(FederatedQueryLimitOutput{})
	pulumi.RegisterOutputType(FederatedQueryLimitArrayOutput{})
	pulumi.RegisterOutputType(FederatedQueryLimitMapOutput{})
}
