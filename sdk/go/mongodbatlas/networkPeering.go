// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package mongodbatlas

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Example Usage
//
// ### Container & Peering Connection
// ### Example with AWS
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/ec2"
// 	"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		_, err := mongodbatlas.NewNetworkContainer(ctx, "testNetworkContainer", &mongodbatlas.NetworkContainerArgs{
// 			ProjectId:      pulumi.Any(local.Project_id),
// 			AtlasCidrBlock: pulumi.String("10.8.0.0/21"),
// 			ProviderName:   pulumi.String("AWS"),
// 			RegionName:     pulumi.String("US_EAST_1"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		testNetworkPeering, err := mongodbatlas.NewNetworkPeering(ctx, "testNetworkPeering", &mongodbatlas.NetworkPeeringArgs{
// 			AccepterRegionName:  pulumi.String("us-east-1"),
// 			ProjectId:           pulumi.Any(local.Project_id),
// 			ContainerId:         pulumi.String("507f1f77bcf86cd799439011"),
// 			ProviderName:        pulumi.String("AWS"),
// 			RouteTableCidrBlock: pulumi.String("192.168.0.0/24"),
// 			VpcId:               pulumi.String("vpc-abc123abc123"),
// 			AwsAccountId:        pulumi.String("abc123abc123"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = ec2.NewVpcPeeringConnectionAccepter(ctx, "peer", &ec2.VpcPeeringConnectionAccepterArgs{
// 			VpcPeeringConnectionId: testNetworkPeering.ConnectionId,
// 			AutoAccept:             pulumi.Bool(true),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
// ### Example with GCP
//
// ```go
// package main
//
// import (
// 	"fmt"
//
// 	"github.com/pulumi/pulumi-gcp/sdk/v5/go/gcp/compute"
// 	"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		testNetworkContainer, err := mongodbatlas.NewNetworkContainer(ctx, "testNetworkContainer", &mongodbatlas.NetworkContainerArgs{
// 			ProjectId:      pulumi.Any(local.Project_id),
// 			AtlasCidrBlock: pulumi.String("10.8.0.0/21"),
// 			ProviderName:   pulumi.String("GCP"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		testNetworkPeering, err := mongodbatlas.NewNetworkPeering(ctx, "testNetworkPeering", &mongodbatlas.NetworkPeeringArgs{
// 			ProjectId:    pulumi.Any(local.Project_id),
// 			ContainerId:  testNetworkContainer.ContainerId,
// 			ProviderName: pulumi.String("GCP"),
// 			GcpProjectId: pulumi.Any(local.GCP_PROJECT_ID),
// 			NetworkName:  pulumi.String("default"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_default, err := compute.LookupNetwork(ctx, &compute.LookupNetworkArgs{
// 			Name: "default",
// 		}, nil)
// 		if err != nil {
// 			return err
// 		}
// 		_, err = compute.NewNetworkPeering(ctx, "peering", &compute.NetworkPeeringArgs{
// 			Network: pulumi.String(_default.SelfLink),
// 			PeerNetwork: pulumi.All(testNetworkPeering.AtlasGcpProjectId, testNetworkPeering.AtlasVpcName).ApplyT(func(_args []interface{}) (string, error) {
// 				atlasGcpProjectId := _args[0].(string)
// 				atlasVpcName := _args[1].(string)
// 				return fmt.Sprintf("%v%v%v%v", "https://www.googleapis.com/compute/v1/projects/", atlasGcpProjectId, "/global/networks/", atlasVpcName), nil
// 			}).(pulumi.StringOutput),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = mongodbatlas.NewCluster(ctx, "testCluster", &mongodbatlas.ClusterArgs{
// 			ProjectId:   pulumi.Any(local.Project_id),
// 			NumShards:   pulumi.Int(1),
// 			DiskSizeGb:  pulumi.Float64(5),
// 			ClusterType: pulumi.String("REPLICASET"),
// 			ReplicationSpecs: ClusterReplicationSpecArray{
// 				&ClusterReplicationSpecArgs{
// 					NumShards: pulumi.Int(1),
// 					RegionsConfigs: ClusterReplicationSpecRegionsConfigArray{
// 						&ClusterReplicationSpecRegionsConfigArgs{
// 							RegionName:     pulumi.String("US_EAST_4"),
// 							ElectableNodes: pulumi.Int(3),
// 							Priority:       pulumi.Int(7),
// 							ReadOnlyNodes:  pulumi.Int(0),
// 						},
// 					},
// 				},
// 			},
// 			AutoScalingDiskGbEnabled: pulumi.Bool(true),
// 			MongoDbMajorVersion:      pulumi.String("4.2"),
// 			ProviderName:             pulumi.String("GCP"),
// 			ProviderInstanceSizeName: pulumi.String("M10"),
// 		}, pulumi.DependsOn([]pulumi.Resource{
// 			pulumi.Resource("google_compute_network_peering.peering"),
// 		}))
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
// ### Example with Azure
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		testNetworkContainer, err := mongodbatlas.NewNetworkContainer(ctx, "testNetworkContainer", &mongodbatlas.NetworkContainerArgs{
// 			ProjectId:      pulumi.Any(local.Project_id),
// 			AtlasCidrBlock: pulumi.Any(local.ATLAS_CIDR_BLOCK),
// 			ProviderName:   pulumi.String("AZURE"),
// 			Region:         pulumi.String("US_EAST_2"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = mongodbatlas.NewNetworkPeering(ctx, "testNetworkPeering", &mongodbatlas.NetworkPeeringArgs{
// 			ProjectId:           pulumi.Any(local.Project_id),
// 			ContainerId:         testNetworkContainer.ContainerId,
// 			ProviderName:        pulumi.String("AZURE"),
// 			AzureDirectoryId:    pulumi.Any(local.AZURE_DIRECTORY_ID),
// 			AzureSubscriptionId: pulumi.Any(local.AZURE_SUBSCRIPTION_ID),
// 			ResourceGroupName:   pulumi.Any(local.AZURE_RESOURCES_GROUP_NAME),
// 			VnetName:            pulumi.Any(local.AZURE_VNET_NAME),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = mongodbatlas.NewCluster(ctx, "testCluster", &mongodbatlas.ClusterArgs{
// 			ProjectId:   pulumi.Any(local.Project_id),
// 			ClusterType: pulumi.String("REPLICASET"),
// 			ReplicationSpecs: ClusterReplicationSpecArray{
// 				&ClusterReplicationSpecArgs{
// 					NumShards: pulumi.Int(1),
// 					RegionsConfigs: ClusterReplicationSpecRegionsConfigArray{
// 						&ClusterReplicationSpecRegionsConfigArgs{
// 							RegionName:     pulumi.String("US_EAST_2"),
// 							ElectableNodes: pulumi.Int(3),
// 							Priority:       pulumi.Int(7),
// 							ReadOnlyNodes:  pulumi.Int(0),
// 						},
// 					},
// 				},
// 			},
// 			AutoScalingDiskGbEnabled: pulumi.Bool(true),
// 			MongoDbMajorVersion:      pulumi.String("4.2"),
// 			ProviderName:             pulumi.String("AZURE"),
// 			ProviderDiskTypeName:     pulumi.String("P4"),
// 			ProviderInstanceSizeName: pulumi.String("M10"),
// 		}, pulumi.DependsOn([]pulumi.Resource{
// 			pulumi.Resource("mongodbatlas_network_peering.test"),
// 		}))
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
// ### Peering Connection Only, Container Exists
// You can create a peering connection if an appropriate container for your cloud provider already exists in your project (see the networkContainer resource for more information).  A container may already exist if you have already created a cluster in your project, if so you may obtain the `containerId` from the cluster resource as shown in the examples below.
// ### Example with AWS
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/ec2"
// 	"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		test, err := mongodbatlas.NewCluster(ctx, "test", &mongodbatlas.ClusterArgs{
// 			ProjectId:   pulumi.Any(local.Project_id),
// 			DiskSizeGb:  pulumi.Float64(5),
// 			ClusterType: pulumi.String("REPLICASET"),
// 			ReplicationSpecs: ClusterReplicationSpecArray{
// 				&ClusterReplicationSpecArgs{
// 					NumShards: pulumi.Int(1),
// 					RegionsConfigs: ClusterReplicationSpecRegionsConfigArray{
// 						&ClusterReplicationSpecRegionsConfigArgs{
// 							RegionName:     pulumi.String("US_EAST_2"),
// 							ElectableNodes: pulumi.Int(3),
// 							Priority:       pulumi.Int(7),
// 							ReadOnlyNodes:  pulumi.Int(0),
// 						},
// 					},
// 				},
// 			},
// 			AutoScalingDiskGbEnabled: pulumi.Bool(false),
// 			MongoDbMajorVersion:      pulumi.String("4.2"),
// 			ProviderName:             pulumi.String("AWS"),
// 			ProviderInstanceSizeName: pulumi.String("M10"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = ec2.NewDefaultVpc(ctx, "default", &ec2.DefaultVpcArgs{
// 			Tags: pulumi.StringMap{
// 				"Name": pulumi.String("Default VPC"),
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		mongoPeer, err := mongodbatlas.NewNetworkPeering(ctx, "mongoPeer", &mongodbatlas.NetworkPeeringArgs{
// 			AccepterRegionName:  pulumi.String("us-east-2"),
// 			ProjectId:           pulumi.Any(local.Project_id),
// 			ContainerId:         test.ContainerId,
// 			ProviderName:        pulumi.String("AWS"),
// 			RouteTableCidrBlock: pulumi.String("172.31.0.0/16"),
// 			VpcId:               _default.ID(),
// 			AwsAccountId:        pulumi.Any(local.AWS_ACCOUNT_ID),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = ec2.NewVpcPeeringConnectionAccepter(ctx, "awsPeer", &ec2.VpcPeeringConnectionAccepterArgs{
// 			VpcPeeringConnectionId: mongoPeer.ConnectionId,
// 			AutoAccept:             pulumi.Bool(true),
// 			Tags: pulumi.StringMap{
// 				"Side": pulumi.String("Accepter"),
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
// ### Example with GCP
// ```go
// package main
//
// import (
// 	"fmt"
//
// 	"github.com/pulumi/pulumi-gcp/sdk/v5/go/gcp/compute"
// 	"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		testCluster, err := mongodbatlas.NewCluster(ctx, "testCluster", &mongodbatlas.ClusterArgs{
// 			ProjectId:   pulumi.Any(local.Project_id),
// 			DiskSizeGb:  pulumi.Float64(5),
// 			ClusterType: pulumi.String("REPLICASET"),
// 			ReplicationSpecs: ClusterReplicationSpecArray{
// 				&ClusterReplicationSpecArgs{
// 					NumShards: pulumi.Int(1),
// 					RegionsConfigs: ClusterReplicationSpecRegionsConfigArray{
// 						&ClusterReplicationSpecRegionsConfigArgs{
// 							RegionName:     pulumi.String("US_EAST_2"),
// 							ElectableNodes: pulumi.Int(3),
// 							Priority:       pulumi.Int(7),
// 							ReadOnlyNodes:  pulumi.Int(0),
// 						},
// 					},
// 				},
// 			},
// 			AutoScalingDiskGbEnabled: pulumi.Bool(true),
// 			MongoDbMajorVersion:      pulumi.String("4.2"),
// 			ProviderName:             pulumi.String("GCP"),
// 			ProviderInstanceSizeName: pulumi.String("M10"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		testNetworkPeering, err := mongodbatlas.NewNetworkPeering(ctx, "testNetworkPeering", &mongodbatlas.NetworkPeeringArgs{
// 			ProjectId:      pulumi.Any(local.Project_id),
// 			AtlasCidrBlock: pulumi.String("192.168.0.0/18"),
// 			ContainerId:    testCluster.ContainerId,
// 			ProviderName:   pulumi.String("GCP"),
// 			GcpProjectId:   pulumi.Any(local.GCP_PROJECT_ID),
// 			NetworkName:    pulumi.String("default"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_default, err := compute.LookupNetwork(ctx, &compute.LookupNetworkArgs{
// 			Name: "default",
// 		}, nil)
// 		if err != nil {
// 			return err
// 		}
// 		_, err = compute.NewNetworkPeering(ctx, "peering", &compute.NetworkPeeringArgs{
// 			Network: pulumi.String(_default.SelfLink),
// 			PeerNetwork: pulumi.All(testNetworkPeering.AtlasGcpProjectId, testNetworkPeering.AtlasVpcName).ApplyT(func(_args []interface{}) (string, error) {
// 				atlasGcpProjectId := _args[0].(string)
// 				atlasVpcName := _args[1].(string)
// 				return fmt.Sprintf("%v%v%v%v", "https://www.googleapis.com/compute/v1/projects/", atlasGcpProjectId, "/global/networks/", atlasVpcName), nil
// 			}).(pulumi.StringOutput),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
// ### Example with Azure
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		testCluster, err := mongodbatlas.NewCluster(ctx, "testCluster", &mongodbatlas.ClusterArgs{
// 			ProjectId:   pulumi.Any(local.Project_id),
// 			ClusterType: pulumi.String("REPLICASET"),
// 			ReplicationSpecs: ClusterReplicationSpecArray{
// 				&ClusterReplicationSpecArgs{
// 					NumShards: pulumi.Int(1),
// 					RegionsConfigs: ClusterReplicationSpecRegionsConfigArray{
// 						&ClusterReplicationSpecRegionsConfigArgs{
// 							RegionName:     pulumi.String("US_EAST_2"),
// 							ElectableNodes: pulumi.Int(3),
// 							Priority:       pulumi.Int(7),
// 							ReadOnlyNodes:  pulumi.Int(0),
// 						},
// 					},
// 				},
// 			},
// 			AutoScalingDiskGbEnabled: pulumi.Bool(false),
// 			MongoDbMajorVersion:      pulumi.String("4.2"),
// 			ProviderName:             pulumi.String("AZURE"),
// 			ProviderInstanceSizeName: pulumi.String("M10"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = mongodbatlas.NewNetworkPeering(ctx, "testNetworkPeering", &mongodbatlas.NetworkPeeringArgs{
// 			ProjectId:           pulumi.Any(local.Project_id),
// 			ContainerId:         testCluster.ContainerId,
// 			ProviderName:        pulumi.String("AZURE"),
// 			AzureDirectoryId:    pulumi.Any(local.AZURE_DIRECTORY_ID),
// 			AzureSubscriptionId: pulumi.Any(local.AZURE_SUBSCRIPTION_ID),
// 			ResourceGroupName:   pulumi.Any(local.AZURE_RESOURCE_GROUP_NAME),
// 			VnetName:            pulumi.Any(local.AZURE_VNET_NAME),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
//
// ## Import
//
// Clusters can be imported using project ID and network peering id, in the format `PROJECTID-PEERID-PROVIDERNAME`, e.g.
//
// ```sh
//  $ pulumi import mongodbatlas:index/networkPeering:NetworkPeering my_peering 1112222b3bf99403840e8934-5cbf563d87d9d67253be590a-AWS
// ```
//
//  See detailed information for arguments and attributes[MongoDB API Network Peering Connection](https://docs.atlas.mongodb.com/reference/api/vpc-create-peering-connection/)
type NetworkPeering struct {
	pulumi.CustomResourceState

	// Specifies the AWS region where the peer VPC resides. For complete lists of supported regions, see [Amazon Web Services](https://docs.atlas.mongodb.com/reference/amazon-aws/).
	AccepterRegionName pulumi.StringOutput `pulumi:"accepterRegionName"`
	AtlasCidrBlock     pulumi.StringOutput `pulumi:"atlasCidrBlock"`
	// The Atlas GCP Project ID for the GCP VPC used by your atlas cluster that it is need to set up the reciprocal connection.
	AtlasGcpProjectId pulumi.StringOutput `pulumi:"atlasGcpProjectId"`
	AtlasId           pulumi.StringOutput `pulumi:"atlasId"`
	AtlasVpcName      pulumi.StringOutput `pulumi:"atlasVpcName"`
	// AWS Account ID of the owner of the peer VPC.
	AwsAccountId pulumi.StringOutput `pulumi:"awsAccountId"`
	// Unique identifier for an Azure AD directory.
	AzureDirectoryId pulumi.StringOutput `pulumi:"azureDirectoryId"`
	// Unique identifier of the Azure subscription in which the VNet resides.
	AzureSubscriptionId pulumi.StringOutput `pulumi:"azureSubscriptionId"`
	// Unique identifier of the Atlas network peering container.
	ConnectionId pulumi.StringOutput `pulumi:"connectionId"`
	// Unique identifier of the MongoDB Atlas container for the provider (GCP) or provider/region (AWS, AZURE). You can create an MongoDB Atlas container using the networkContainer resource or it can be obtained from the cluster returned values if a cluster has been created before the first container.
	ContainerId pulumi.StringOutput `pulumi:"containerId"`
	// When `"status" : "FAILED"`, Atlas provides a description of the error.
	ErrorMessage pulumi.StringOutput `pulumi:"errorMessage"`
	// Description of the Atlas error when `status` is `Failed`, Otherwise, Atlas returns `null`.
	ErrorState pulumi.StringOutput `pulumi:"errorState"`
	// Error state, if any. The VPC peering connection error state value can be one of the following: `REJECTED`, `EXPIRED`, `INVALID_ARGUMENT`.
	ErrorStateName pulumi.StringOutput `pulumi:"errorStateName"`
	// GCP project ID of the owner of the network peer.
	GcpProjectId pulumi.StringOutput `pulumi:"gcpProjectId"`
	// Name of the network peer to which Atlas connects.
	NetworkName pulumi.StringOutput `pulumi:"networkName"`
	// Unique identifier of the Atlas network peer.
	PeerId pulumi.StringOutput `pulumi:"peerId"`
	// The unique ID for the MongoDB Atlas project to create the database user.
	ProjectId pulumi.StringOutput `pulumi:"projectId"`
	// Cloud provider to whom the peering connection is being made. (Possible Values `AWS`, `AZURE`, `GCP`).
	ProviderName pulumi.StringOutput `pulumi:"providerName"`
	// Name of your Azure resource group.
	ResourceGroupName pulumi.StringOutput `pulumi:"resourceGroupName"`
	// AWS VPC CIDR block or subnet.
	RouteTableCidrBlock pulumi.StringOutput `pulumi:"routeTableCidrBlock"`
	// Status of the Atlas network peering connection.  Azure/GCP: `ADDING_PEER`, `AVAILABLE`, `FAILED`, `DELETING` GCP Only:  `WAITING_FOR_USER`.
	Status pulumi.StringOutput `pulumi:"status"`
	// (AWS Only) The VPC peering connection status value can be one of the following: `INITIATING`, `PENDING_ACCEPTANCE`, `FAILED`, `FINALIZING`, `AVAILABLE`, `TERMINATING`.
	StatusName pulumi.StringOutput `pulumi:"statusName"`
	// Name of your Azure VNet.
	VnetName pulumi.StringOutput `pulumi:"vnetName"`
	// Unique identifier of the AWS peer VPC (Note: this is **not** the same as the Atlas AWS VPC that is returned by the networkContainer resource).
	VpcId pulumi.StringOutput `pulumi:"vpcId"`
}

// NewNetworkPeering registers a new resource with the given unique name, arguments, and options.
func NewNetworkPeering(ctx *pulumi.Context,
	name string, args *NetworkPeeringArgs, opts ...pulumi.ResourceOption) (*NetworkPeering, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ContainerId == nil {
		return nil, errors.New("invalid value for required argument 'ContainerId'")
	}
	if args.ProjectId == nil {
		return nil, errors.New("invalid value for required argument 'ProjectId'")
	}
	if args.ProviderName == nil {
		return nil, errors.New("invalid value for required argument 'ProviderName'")
	}
	var resource NetworkPeering
	err := ctx.RegisterResource("mongodbatlas:index/networkPeering:NetworkPeering", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetNetworkPeering gets an existing NetworkPeering resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetNetworkPeering(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *NetworkPeeringState, opts ...pulumi.ResourceOption) (*NetworkPeering, error) {
	var resource NetworkPeering
	err := ctx.ReadResource("mongodbatlas:index/networkPeering:NetworkPeering", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering NetworkPeering resources.
type networkPeeringState struct {
	// Specifies the AWS region where the peer VPC resides. For complete lists of supported regions, see [Amazon Web Services](https://docs.atlas.mongodb.com/reference/amazon-aws/).
	AccepterRegionName *string `pulumi:"accepterRegionName"`
	AtlasCidrBlock     *string `pulumi:"atlasCidrBlock"`
	// The Atlas GCP Project ID for the GCP VPC used by your atlas cluster that it is need to set up the reciprocal connection.
	AtlasGcpProjectId *string `pulumi:"atlasGcpProjectId"`
	AtlasId           *string `pulumi:"atlasId"`
	AtlasVpcName      *string `pulumi:"atlasVpcName"`
	// AWS Account ID of the owner of the peer VPC.
	AwsAccountId *string `pulumi:"awsAccountId"`
	// Unique identifier for an Azure AD directory.
	AzureDirectoryId *string `pulumi:"azureDirectoryId"`
	// Unique identifier of the Azure subscription in which the VNet resides.
	AzureSubscriptionId *string `pulumi:"azureSubscriptionId"`
	// Unique identifier of the Atlas network peering container.
	ConnectionId *string `pulumi:"connectionId"`
	// Unique identifier of the MongoDB Atlas container for the provider (GCP) or provider/region (AWS, AZURE). You can create an MongoDB Atlas container using the networkContainer resource or it can be obtained from the cluster returned values if a cluster has been created before the first container.
	ContainerId *string `pulumi:"containerId"`
	// When `"status" : "FAILED"`, Atlas provides a description of the error.
	ErrorMessage *string `pulumi:"errorMessage"`
	// Description of the Atlas error when `status` is `Failed`, Otherwise, Atlas returns `null`.
	ErrorState *string `pulumi:"errorState"`
	// Error state, if any. The VPC peering connection error state value can be one of the following: `REJECTED`, `EXPIRED`, `INVALID_ARGUMENT`.
	ErrorStateName *string `pulumi:"errorStateName"`
	// GCP project ID of the owner of the network peer.
	GcpProjectId *string `pulumi:"gcpProjectId"`
	// Name of the network peer to which Atlas connects.
	NetworkName *string `pulumi:"networkName"`
	// Unique identifier of the Atlas network peer.
	PeerId *string `pulumi:"peerId"`
	// The unique ID for the MongoDB Atlas project to create the database user.
	ProjectId *string `pulumi:"projectId"`
	// Cloud provider to whom the peering connection is being made. (Possible Values `AWS`, `AZURE`, `GCP`).
	ProviderName *string `pulumi:"providerName"`
	// Name of your Azure resource group.
	ResourceGroupName *string `pulumi:"resourceGroupName"`
	// AWS VPC CIDR block or subnet.
	RouteTableCidrBlock *string `pulumi:"routeTableCidrBlock"`
	// Status of the Atlas network peering connection.  Azure/GCP: `ADDING_PEER`, `AVAILABLE`, `FAILED`, `DELETING` GCP Only:  `WAITING_FOR_USER`.
	Status *string `pulumi:"status"`
	// (AWS Only) The VPC peering connection status value can be one of the following: `INITIATING`, `PENDING_ACCEPTANCE`, `FAILED`, `FINALIZING`, `AVAILABLE`, `TERMINATING`.
	StatusName *string `pulumi:"statusName"`
	// Name of your Azure VNet.
	VnetName *string `pulumi:"vnetName"`
	// Unique identifier of the AWS peer VPC (Note: this is **not** the same as the Atlas AWS VPC that is returned by the networkContainer resource).
	VpcId *string `pulumi:"vpcId"`
}

type NetworkPeeringState struct {
	// Specifies the AWS region where the peer VPC resides. For complete lists of supported regions, see [Amazon Web Services](https://docs.atlas.mongodb.com/reference/amazon-aws/).
	AccepterRegionName pulumi.StringPtrInput
	AtlasCidrBlock     pulumi.StringPtrInput
	// The Atlas GCP Project ID for the GCP VPC used by your atlas cluster that it is need to set up the reciprocal connection.
	AtlasGcpProjectId pulumi.StringPtrInput
	AtlasId           pulumi.StringPtrInput
	AtlasVpcName      pulumi.StringPtrInput
	// AWS Account ID of the owner of the peer VPC.
	AwsAccountId pulumi.StringPtrInput
	// Unique identifier for an Azure AD directory.
	AzureDirectoryId pulumi.StringPtrInput
	// Unique identifier of the Azure subscription in which the VNet resides.
	AzureSubscriptionId pulumi.StringPtrInput
	// Unique identifier of the Atlas network peering container.
	ConnectionId pulumi.StringPtrInput
	// Unique identifier of the MongoDB Atlas container for the provider (GCP) or provider/region (AWS, AZURE). You can create an MongoDB Atlas container using the networkContainer resource or it can be obtained from the cluster returned values if a cluster has been created before the first container.
	ContainerId pulumi.StringPtrInput
	// When `"status" : "FAILED"`, Atlas provides a description of the error.
	ErrorMessage pulumi.StringPtrInput
	// Description of the Atlas error when `status` is `Failed`, Otherwise, Atlas returns `null`.
	ErrorState pulumi.StringPtrInput
	// Error state, if any. The VPC peering connection error state value can be one of the following: `REJECTED`, `EXPIRED`, `INVALID_ARGUMENT`.
	ErrorStateName pulumi.StringPtrInput
	// GCP project ID of the owner of the network peer.
	GcpProjectId pulumi.StringPtrInput
	// Name of the network peer to which Atlas connects.
	NetworkName pulumi.StringPtrInput
	// Unique identifier of the Atlas network peer.
	PeerId pulumi.StringPtrInput
	// The unique ID for the MongoDB Atlas project to create the database user.
	ProjectId pulumi.StringPtrInput
	// Cloud provider to whom the peering connection is being made. (Possible Values `AWS`, `AZURE`, `GCP`).
	ProviderName pulumi.StringPtrInput
	// Name of your Azure resource group.
	ResourceGroupName pulumi.StringPtrInput
	// AWS VPC CIDR block or subnet.
	RouteTableCidrBlock pulumi.StringPtrInput
	// Status of the Atlas network peering connection.  Azure/GCP: `ADDING_PEER`, `AVAILABLE`, `FAILED`, `DELETING` GCP Only:  `WAITING_FOR_USER`.
	Status pulumi.StringPtrInput
	// (AWS Only) The VPC peering connection status value can be one of the following: `INITIATING`, `PENDING_ACCEPTANCE`, `FAILED`, `FINALIZING`, `AVAILABLE`, `TERMINATING`.
	StatusName pulumi.StringPtrInput
	// Name of your Azure VNet.
	VnetName pulumi.StringPtrInput
	// Unique identifier of the AWS peer VPC (Note: this is **not** the same as the Atlas AWS VPC that is returned by the networkContainer resource).
	VpcId pulumi.StringPtrInput
}

func (NetworkPeeringState) ElementType() reflect.Type {
	return reflect.TypeOf((*networkPeeringState)(nil)).Elem()
}

type networkPeeringArgs struct {
	// Specifies the AWS region where the peer VPC resides. For complete lists of supported regions, see [Amazon Web Services](https://docs.atlas.mongodb.com/reference/amazon-aws/).
	AccepterRegionName *string `pulumi:"accepterRegionName"`
	AtlasCidrBlock     *string `pulumi:"atlasCidrBlock"`
	// The Atlas GCP Project ID for the GCP VPC used by your atlas cluster that it is need to set up the reciprocal connection.
	AtlasGcpProjectId *string `pulumi:"atlasGcpProjectId"`
	AtlasVpcName      *string `pulumi:"atlasVpcName"`
	// AWS Account ID of the owner of the peer VPC.
	AwsAccountId *string `pulumi:"awsAccountId"`
	// Unique identifier for an Azure AD directory.
	AzureDirectoryId *string `pulumi:"azureDirectoryId"`
	// Unique identifier of the Azure subscription in which the VNet resides.
	AzureSubscriptionId *string `pulumi:"azureSubscriptionId"`
	// Unique identifier of the MongoDB Atlas container for the provider (GCP) or provider/region (AWS, AZURE). You can create an MongoDB Atlas container using the networkContainer resource or it can be obtained from the cluster returned values if a cluster has been created before the first container.
	ContainerId string `pulumi:"containerId"`
	// GCP project ID of the owner of the network peer.
	GcpProjectId *string `pulumi:"gcpProjectId"`
	// Name of the network peer to which Atlas connects.
	NetworkName *string `pulumi:"networkName"`
	// The unique ID for the MongoDB Atlas project to create the database user.
	ProjectId string `pulumi:"projectId"`
	// Cloud provider to whom the peering connection is being made. (Possible Values `AWS`, `AZURE`, `GCP`).
	ProviderName string `pulumi:"providerName"`
	// Name of your Azure resource group.
	ResourceGroupName *string `pulumi:"resourceGroupName"`
	// AWS VPC CIDR block or subnet.
	RouteTableCidrBlock *string `pulumi:"routeTableCidrBlock"`
	// Name of your Azure VNet.
	VnetName *string `pulumi:"vnetName"`
	// Unique identifier of the AWS peer VPC (Note: this is **not** the same as the Atlas AWS VPC that is returned by the networkContainer resource).
	VpcId *string `pulumi:"vpcId"`
}

// The set of arguments for constructing a NetworkPeering resource.
type NetworkPeeringArgs struct {
	// Specifies the AWS region where the peer VPC resides. For complete lists of supported regions, see [Amazon Web Services](https://docs.atlas.mongodb.com/reference/amazon-aws/).
	AccepterRegionName pulumi.StringPtrInput
	AtlasCidrBlock     pulumi.StringPtrInput
	// The Atlas GCP Project ID for the GCP VPC used by your atlas cluster that it is need to set up the reciprocal connection.
	AtlasGcpProjectId pulumi.StringPtrInput
	AtlasVpcName      pulumi.StringPtrInput
	// AWS Account ID of the owner of the peer VPC.
	AwsAccountId pulumi.StringPtrInput
	// Unique identifier for an Azure AD directory.
	AzureDirectoryId pulumi.StringPtrInput
	// Unique identifier of the Azure subscription in which the VNet resides.
	AzureSubscriptionId pulumi.StringPtrInput
	// Unique identifier of the MongoDB Atlas container for the provider (GCP) or provider/region (AWS, AZURE). You can create an MongoDB Atlas container using the networkContainer resource or it can be obtained from the cluster returned values if a cluster has been created before the first container.
	ContainerId pulumi.StringInput
	// GCP project ID of the owner of the network peer.
	GcpProjectId pulumi.StringPtrInput
	// Name of the network peer to which Atlas connects.
	NetworkName pulumi.StringPtrInput
	// The unique ID for the MongoDB Atlas project to create the database user.
	ProjectId pulumi.StringInput
	// Cloud provider to whom the peering connection is being made. (Possible Values `AWS`, `AZURE`, `GCP`).
	ProviderName pulumi.StringInput
	// Name of your Azure resource group.
	ResourceGroupName pulumi.StringPtrInput
	// AWS VPC CIDR block or subnet.
	RouteTableCidrBlock pulumi.StringPtrInput
	// Name of your Azure VNet.
	VnetName pulumi.StringPtrInput
	// Unique identifier of the AWS peer VPC (Note: this is **not** the same as the Atlas AWS VPC that is returned by the networkContainer resource).
	VpcId pulumi.StringPtrInput
}

func (NetworkPeeringArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*networkPeeringArgs)(nil)).Elem()
}

type NetworkPeeringInput interface {
	pulumi.Input

	ToNetworkPeeringOutput() NetworkPeeringOutput
	ToNetworkPeeringOutputWithContext(ctx context.Context) NetworkPeeringOutput
}

func (*NetworkPeering) ElementType() reflect.Type {
	return reflect.TypeOf((**NetworkPeering)(nil)).Elem()
}

func (i *NetworkPeering) ToNetworkPeeringOutput() NetworkPeeringOutput {
	return i.ToNetworkPeeringOutputWithContext(context.Background())
}

func (i *NetworkPeering) ToNetworkPeeringOutputWithContext(ctx context.Context) NetworkPeeringOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkPeeringOutput)
}

// NetworkPeeringArrayInput is an input type that accepts NetworkPeeringArray and NetworkPeeringArrayOutput values.
// You can construct a concrete instance of `NetworkPeeringArrayInput` via:
//
//          NetworkPeeringArray{ NetworkPeeringArgs{...} }
type NetworkPeeringArrayInput interface {
	pulumi.Input

	ToNetworkPeeringArrayOutput() NetworkPeeringArrayOutput
	ToNetworkPeeringArrayOutputWithContext(context.Context) NetworkPeeringArrayOutput
}

type NetworkPeeringArray []NetworkPeeringInput

func (NetworkPeeringArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*NetworkPeering)(nil)).Elem()
}

func (i NetworkPeeringArray) ToNetworkPeeringArrayOutput() NetworkPeeringArrayOutput {
	return i.ToNetworkPeeringArrayOutputWithContext(context.Background())
}

func (i NetworkPeeringArray) ToNetworkPeeringArrayOutputWithContext(ctx context.Context) NetworkPeeringArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkPeeringArrayOutput)
}

// NetworkPeeringMapInput is an input type that accepts NetworkPeeringMap and NetworkPeeringMapOutput values.
// You can construct a concrete instance of `NetworkPeeringMapInput` via:
//
//          NetworkPeeringMap{ "key": NetworkPeeringArgs{...} }
type NetworkPeeringMapInput interface {
	pulumi.Input

	ToNetworkPeeringMapOutput() NetworkPeeringMapOutput
	ToNetworkPeeringMapOutputWithContext(context.Context) NetworkPeeringMapOutput
}

type NetworkPeeringMap map[string]NetworkPeeringInput

func (NetworkPeeringMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*NetworkPeering)(nil)).Elem()
}

func (i NetworkPeeringMap) ToNetworkPeeringMapOutput() NetworkPeeringMapOutput {
	return i.ToNetworkPeeringMapOutputWithContext(context.Background())
}

func (i NetworkPeeringMap) ToNetworkPeeringMapOutputWithContext(ctx context.Context) NetworkPeeringMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkPeeringMapOutput)
}

type NetworkPeeringOutput struct{ *pulumi.OutputState }

func (NetworkPeeringOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NetworkPeering)(nil)).Elem()
}

func (o NetworkPeeringOutput) ToNetworkPeeringOutput() NetworkPeeringOutput {
	return o
}

func (o NetworkPeeringOutput) ToNetworkPeeringOutputWithContext(ctx context.Context) NetworkPeeringOutput {
	return o
}

type NetworkPeeringArrayOutput struct{ *pulumi.OutputState }

func (NetworkPeeringArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*NetworkPeering)(nil)).Elem()
}

func (o NetworkPeeringArrayOutput) ToNetworkPeeringArrayOutput() NetworkPeeringArrayOutput {
	return o
}

func (o NetworkPeeringArrayOutput) ToNetworkPeeringArrayOutputWithContext(ctx context.Context) NetworkPeeringArrayOutput {
	return o
}

func (o NetworkPeeringArrayOutput) Index(i pulumi.IntInput) NetworkPeeringOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *NetworkPeering {
		return vs[0].([]*NetworkPeering)[vs[1].(int)]
	}).(NetworkPeeringOutput)
}

type NetworkPeeringMapOutput struct{ *pulumi.OutputState }

func (NetworkPeeringMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*NetworkPeering)(nil)).Elem()
}

func (o NetworkPeeringMapOutput) ToNetworkPeeringMapOutput() NetworkPeeringMapOutput {
	return o
}

func (o NetworkPeeringMapOutput) ToNetworkPeeringMapOutputWithContext(ctx context.Context) NetworkPeeringMapOutput {
	return o
}

func (o NetworkPeeringMapOutput) MapIndex(k pulumi.StringInput) NetworkPeeringOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *NetworkPeering {
		return vs[0].(map[string]*NetworkPeering)[vs[1].(string)]
	}).(NetworkPeeringOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkPeeringInput)(nil)).Elem(), &NetworkPeering{})
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkPeeringArrayInput)(nil)).Elem(), NetworkPeeringArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkPeeringMapInput)(nil)).Elem(), NetworkPeeringMap{})
	pulumi.RegisterOutputType(NetworkPeeringOutput{})
	pulumi.RegisterOutputType(NetworkPeeringArrayOutput{})
	pulumi.RegisterOutputType(NetworkPeeringMapOutput{})
}
