// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package mongodbatlas

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// `OnlineArchive` resource provides access to create, edit, pause and resume an online archive for a collection.
//
// > **NOTE:** Groups and projects are synonymous terms. You may find groupId in the official documentation.
//
// > **IMPORTANT:** The collection must exists before performing an online archive.
//
// > **IMPORTANT:** There are fields that are immutable after creation, i.e if `dateField` value does not exist in the collection, the online archive state will be pending forever, and this field cannot be updated, that means a destroy is required, known error `ONLINE_ARCHIVE_CANNOT_MODIFY_FIELD`
//
// ## Example Usage
type OnlineArchive struct {
	pulumi.CustomResourceState

	// ID of the online archive.
	ArchiveId pulumi.StringOutput `pulumi:"archiveId"`
	// Name of the cluster that contains the collection.
	ClusterName pulumi.StringOutput `pulumi:"clusterName"`
	// Name of the collection.
	CollName pulumi.StringOutput `pulumi:"collName"`
	// Criteria to use for archiving data.
	Criteria OnlineArchiveCriteriaOutput `pulumi:"criteria"`
	// Name of the database that contains the collection.
	DbName pulumi.StringOutput `pulumi:"dbName"`
	// Fields to use to partition data. You can specify up to two frequently queried fields to use for partitioning data. Note that queries that don’t contain the specified fields will require a full collection scan of all archived documents, which will take longer and increase your costs. To learn more about how partition improves query performance, see [Data Structure in S3](https://docs.mongodb.com/datalake/admin/optimize-query-performance/#data-structure-in-s3). The value of a partition field can be up to a maximum of 700 characters. Documents with values exceeding 700 characters are not archived.
	PartitionFields OnlineArchivePartitionFieldArrayOutput `pulumi:"partitionFields"`
	// State of the online archive. This is required for pausing an active or resume a paused online archive. The resume request will fail if the collection has another active online archive.
	Paused pulumi.BoolOutput `pulumi:"paused"`
	// The unique ID for the project
	ProjectId pulumi.StringOutput `pulumi:"projectId"`
	// Status of the online archive. Valid values are: Pending, Archiving, Idle, Pausing, Paused, Orphaned and Deleted
	State        pulumi.StringOutput  `pulumi:"state"`
	SyncCreation pulumi.BoolPtrOutput `pulumi:"syncCreation"`
}

// NewOnlineArchive registers a new resource with the given unique name, arguments, and options.
func NewOnlineArchive(ctx *pulumi.Context,
	name string, args *OnlineArchiveArgs, opts ...pulumi.ResourceOption) (*OnlineArchive, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ClusterName == nil {
		return nil, errors.New("invalid value for required argument 'ClusterName'")
	}
	if args.CollName == nil {
		return nil, errors.New("invalid value for required argument 'CollName'")
	}
	if args.Criteria == nil {
		return nil, errors.New("invalid value for required argument 'Criteria'")
	}
	if args.DbName == nil {
		return nil, errors.New("invalid value for required argument 'DbName'")
	}
	if args.ProjectId == nil {
		return nil, errors.New("invalid value for required argument 'ProjectId'")
	}
	var resource OnlineArchive
	err := ctx.RegisterResource("mongodbatlas:index/onlineArchive:OnlineArchive", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetOnlineArchive gets an existing OnlineArchive resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetOnlineArchive(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *OnlineArchiveState, opts ...pulumi.ResourceOption) (*OnlineArchive, error) {
	var resource OnlineArchive
	err := ctx.ReadResource("mongodbatlas:index/onlineArchive:OnlineArchive", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering OnlineArchive resources.
type onlineArchiveState struct {
	// ID of the online archive.
	ArchiveId *string `pulumi:"archiveId"`
	// Name of the cluster that contains the collection.
	ClusterName *string `pulumi:"clusterName"`
	// Name of the collection.
	CollName *string `pulumi:"collName"`
	// Criteria to use for archiving data.
	Criteria *OnlineArchiveCriteria `pulumi:"criteria"`
	// Name of the database that contains the collection.
	DbName *string `pulumi:"dbName"`
	// Fields to use to partition data. You can specify up to two frequently queried fields to use for partitioning data. Note that queries that don’t contain the specified fields will require a full collection scan of all archived documents, which will take longer and increase your costs. To learn more about how partition improves query performance, see [Data Structure in S3](https://docs.mongodb.com/datalake/admin/optimize-query-performance/#data-structure-in-s3). The value of a partition field can be up to a maximum of 700 characters. Documents with values exceeding 700 characters are not archived.
	PartitionFields []OnlineArchivePartitionField `pulumi:"partitionFields"`
	// State of the online archive. This is required for pausing an active or resume a paused online archive. The resume request will fail if the collection has another active online archive.
	Paused *bool `pulumi:"paused"`
	// The unique ID for the project
	ProjectId *string `pulumi:"projectId"`
	// Status of the online archive. Valid values are: Pending, Archiving, Idle, Pausing, Paused, Orphaned and Deleted
	State        *string `pulumi:"state"`
	SyncCreation *bool   `pulumi:"syncCreation"`
}

type OnlineArchiveState struct {
	// ID of the online archive.
	ArchiveId pulumi.StringPtrInput
	// Name of the cluster that contains the collection.
	ClusterName pulumi.StringPtrInput
	// Name of the collection.
	CollName pulumi.StringPtrInput
	// Criteria to use for archiving data.
	Criteria OnlineArchiveCriteriaPtrInput
	// Name of the database that contains the collection.
	DbName pulumi.StringPtrInput
	// Fields to use to partition data. You can specify up to two frequently queried fields to use for partitioning data. Note that queries that don’t contain the specified fields will require a full collection scan of all archived documents, which will take longer and increase your costs. To learn more about how partition improves query performance, see [Data Structure in S3](https://docs.mongodb.com/datalake/admin/optimize-query-performance/#data-structure-in-s3). The value of a partition field can be up to a maximum of 700 characters. Documents with values exceeding 700 characters are not archived.
	PartitionFields OnlineArchivePartitionFieldArrayInput
	// State of the online archive. This is required for pausing an active or resume a paused online archive. The resume request will fail if the collection has another active online archive.
	Paused pulumi.BoolPtrInput
	// The unique ID for the project
	ProjectId pulumi.StringPtrInput
	// Status of the online archive. Valid values are: Pending, Archiving, Idle, Pausing, Paused, Orphaned and Deleted
	State        pulumi.StringPtrInput
	SyncCreation pulumi.BoolPtrInput
}

func (OnlineArchiveState) ElementType() reflect.Type {
	return reflect.TypeOf((*onlineArchiveState)(nil)).Elem()
}

type onlineArchiveArgs struct {
	// Name of the cluster that contains the collection.
	ClusterName string `pulumi:"clusterName"`
	// Name of the collection.
	CollName string `pulumi:"collName"`
	// Criteria to use for archiving data.
	Criteria OnlineArchiveCriteria `pulumi:"criteria"`
	// Name of the database that contains the collection.
	DbName string `pulumi:"dbName"`
	// Fields to use to partition data. You can specify up to two frequently queried fields to use for partitioning data. Note that queries that don’t contain the specified fields will require a full collection scan of all archived documents, which will take longer and increase your costs. To learn more about how partition improves query performance, see [Data Structure in S3](https://docs.mongodb.com/datalake/admin/optimize-query-performance/#data-structure-in-s3). The value of a partition field can be up to a maximum of 700 characters. Documents with values exceeding 700 characters are not archived.
	PartitionFields []OnlineArchivePartitionField `pulumi:"partitionFields"`
	// State of the online archive. This is required for pausing an active or resume a paused online archive. The resume request will fail if the collection has another active online archive.
	Paused *bool `pulumi:"paused"`
	// The unique ID for the project
	ProjectId    string `pulumi:"projectId"`
	SyncCreation *bool  `pulumi:"syncCreation"`
}

// The set of arguments for constructing a OnlineArchive resource.
type OnlineArchiveArgs struct {
	// Name of the cluster that contains the collection.
	ClusterName pulumi.StringInput
	// Name of the collection.
	CollName pulumi.StringInput
	// Criteria to use for archiving data.
	Criteria OnlineArchiveCriteriaInput
	// Name of the database that contains the collection.
	DbName pulumi.StringInput
	// Fields to use to partition data. You can specify up to two frequently queried fields to use for partitioning data. Note that queries that don’t contain the specified fields will require a full collection scan of all archived documents, which will take longer and increase your costs. To learn more about how partition improves query performance, see [Data Structure in S3](https://docs.mongodb.com/datalake/admin/optimize-query-performance/#data-structure-in-s3). The value of a partition field can be up to a maximum of 700 characters. Documents with values exceeding 700 characters are not archived.
	PartitionFields OnlineArchivePartitionFieldArrayInput
	// State of the online archive. This is required for pausing an active or resume a paused online archive. The resume request will fail if the collection has another active online archive.
	Paused pulumi.BoolPtrInput
	// The unique ID for the project
	ProjectId    pulumi.StringInput
	SyncCreation pulumi.BoolPtrInput
}

func (OnlineArchiveArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*onlineArchiveArgs)(nil)).Elem()
}

type OnlineArchiveInput interface {
	pulumi.Input

	ToOnlineArchiveOutput() OnlineArchiveOutput
	ToOnlineArchiveOutputWithContext(ctx context.Context) OnlineArchiveOutput
}

func (*OnlineArchive) ElementType() reflect.Type {
	return reflect.TypeOf((**OnlineArchive)(nil)).Elem()
}

func (i *OnlineArchive) ToOnlineArchiveOutput() OnlineArchiveOutput {
	return i.ToOnlineArchiveOutputWithContext(context.Background())
}

func (i *OnlineArchive) ToOnlineArchiveOutputWithContext(ctx context.Context) OnlineArchiveOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OnlineArchiveOutput)
}

// OnlineArchiveArrayInput is an input type that accepts OnlineArchiveArray and OnlineArchiveArrayOutput values.
// You can construct a concrete instance of `OnlineArchiveArrayInput` via:
//
//          OnlineArchiveArray{ OnlineArchiveArgs{...} }
type OnlineArchiveArrayInput interface {
	pulumi.Input

	ToOnlineArchiveArrayOutput() OnlineArchiveArrayOutput
	ToOnlineArchiveArrayOutputWithContext(context.Context) OnlineArchiveArrayOutput
}

type OnlineArchiveArray []OnlineArchiveInput

func (OnlineArchiveArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*OnlineArchive)(nil)).Elem()
}

func (i OnlineArchiveArray) ToOnlineArchiveArrayOutput() OnlineArchiveArrayOutput {
	return i.ToOnlineArchiveArrayOutputWithContext(context.Background())
}

func (i OnlineArchiveArray) ToOnlineArchiveArrayOutputWithContext(ctx context.Context) OnlineArchiveArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OnlineArchiveArrayOutput)
}

// OnlineArchiveMapInput is an input type that accepts OnlineArchiveMap and OnlineArchiveMapOutput values.
// You can construct a concrete instance of `OnlineArchiveMapInput` via:
//
//          OnlineArchiveMap{ "key": OnlineArchiveArgs{...} }
type OnlineArchiveMapInput interface {
	pulumi.Input

	ToOnlineArchiveMapOutput() OnlineArchiveMapOutput
	ToOnlineArchiveMapOutputWithContext(context.Context) OnlineArchiveMapOutput
}

type OnlineArchiveMap map[string]OnlineArchiveInput

func (OnlineArchiveMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*OnlineArchive)(nil)).Elem()
}

func (i OnlineArchiveMap) ToOnlineArchiveMapOutput() OnlineArchiveMapOutput {
	return i.ToOnlineArchiveMapOutputWithContext(context.Background())
}

func (i OnlineArchiveMap) ToOnlineArchiveMapOutputWithContext(ctx context.Context) OnlineArchiveMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(OnlineArchiveMapOutput)
}

type OnlineArchiveOutput struct{ *pulumi.OutputState }

func (OnlineArchiveOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**OnlineArchive)(nil)).Elem()
}

func (o OnlineArchiveOutput) ToOnlineArchiveOutput() OnlineArchiveOutput {
	return o
}

func (o OnlineArchiveOutput) ToOnlineArchiveOutputWithContext(ctx context.Context) OnlineArchiveOutput {
	return o
}

type OnlineArchiveArrayOutput struct{ *pulumi.OutputState }

func (OnlineArchiveArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*OnlineArchive)(nil)).Elem()
}

func (o OnlineArchiveArrayOutput) ToOnlineArchiveArrayOutput() OnlineArchiveArrayOutput {
	return o
}

func (o OnlineArchiveArrayOutput) ToOnlineArchiveArrayOutputWithContext(ctx context.Context) OnlineArchiveArrayOutput {
	return o
}

func (o OnlineArchiveArrayOutput) Index(i pulumi.IntInput) OnlineArchiveOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *OnlineArchive {
		return vs[0].([]*OnlineArchive)[vs[1].(int)]
	}).(OnlineArchiveOutput)
}

type OnlineArchiveMapOutput struct{ *pulumi.OutputState }

func (OnlineArchiveMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*OnlineArchive)(nil)).Elem()
}

func (o OnlineArchiveMapOutput) ToOnlineArchiveMapOutput() OnlineArchiveMapOutput {
	return o
}

func (o OnlineArchiveMapOutput) ToOnlineArchiveMapOutputWithContext(ctx context.Context) OnlineArchiveMapOutput {
	return o
}

func (o OnlineArchiveMapOutput) MapIndex(k pulumi.StringInput) OnlineArchiveOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *OnlineArchive {
		return vs[0].(map[string]*OnlineArchive)[vs[1].(string)]
	}).(OnlineArchiveOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*OnlineArchiveInput)(nil)).Elem(), &OnlineArchive{})
	pulumi.RegisterInputType(reflect.TypeOf((*OnlineArchiveArrayInput)(nil)).Elem(), OnlineArchiveArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*OnlineArchiveMapInput)(nil)).Elem(), OnlineArchiveMap{})
	pulumi.RegisterOutputType(OnlineArchiveOutput{})
	pulumi.RegisterOutputType(OnlineArchiveArrayOutput{})
	pulumi.RegisterOutputType(OnlineArchiveMapOutput{})
}
